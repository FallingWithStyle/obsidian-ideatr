/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/HelpIcon.ts
function getTutorialPath(topic) {
  const mapping = TUTORIAL_MAP[topic];
  if (!mapping) {
    return "Tutorials/00-Index.md";
  }
  const anchor = mapping.anchor ? `#${mapping.anchor.replace("#", "")}` : "";
  return `Tutorials/${mapping.file}${anchor}`;
}
async function openTutorial(app, topic) {
  const tutorialPath = getTutorialPath(topic);
  const mapping = TUTORIAL_MAP[topic];
  const possiblePaths = [
    tutorialPath,
    // Tutorials/XX-File.md (capitalized)
    tutorialPath.replace("Tutorials/", "tutorials/"),
    // tutorials/XX-File.md (lowercase, backward compat)
    `Ideatr/${tutorialPath}`,
    `Ideatr/${tutorialPath.replace("Tutorials/", "tutorials/")}`,
    `Ideatr/Tutorials/${mapping.file}`,
    `Ideatr/tutorials/${mapping.file}`
  ];
  for (const path9 of possiblePaths) {
    const file = app.vault.getAbstractFileByPath(path9);
    if (file && file instanceof import_obsidian2.TFile) {
      await app.workspace.openLinkText(path9, "", true);
      return;
    }
  }
  const indexPaths = [
    "Tutorials/00-Index.md",
    "tutorials/00-Index.md",
    // backward compatibility
    "Ideatr/Tutorials/00-Index.md",
    "Ideatr/tutorials/00-Index.md"
  ];
  for (const indexPath of indexPaths) {
    const indexFile = app.vault.getAbstractFileByPath(indexPath);
    if (indexFile && indexFile instanceof import_obsidian2.TFile) {
      await app.workspace.openLinkText(indexFile.path, "", true);
      return;
    }
  }
  new import_obsidian2.Notice(`Tutorial file not found. Please ensure tutorials are available in your vault.`);
}
function createHelpIcon(app, topic, tooltip) {
  const icon = document.createElement("span");
  icon.addClass("ideatr-help-icon");
  icon.setAttribute("aria-label", tooltip || "Get help");
  icon.innerHTML = "?";
  icon.style.cursor = "pointer";
  icon.style.display = "inline-flex";
  icon.style.alignItems = "center";
  icon.style.justifyContent = "center";
  icon.style.width = "16px";
  icon.style.height = "16px";
  icon.style.borderRadius = "50%";
  icon.style.backgroundColor = "var(--background-modifier-border)";
  icon.style.color = "var(--text-muted)";
  icon.style.fontSize = "12px";
  icon.style.fontWeight = "bold";
  icon.style.marginLeft = "4px";
  icon.style.verticalAlign = "middle";
  icon.style.lineHeight = "1";
  icon.addEventListener("mouseenter", () => {
    icon.style.backgroundColor = "var(--interactive-accent)";
    icon.style.color = "var(--text-on-accent)";
  });
  icon.addEventListener("mouseleave", () => {
    icon.style.backgroundColor = "var(--background-modifier-border)";
    icon.style.color = "var(--text-muted)";
  });
  icon.addEventListener("click", async (e) => {
    e.stopPropagation();
    await openTutorial(app, topic);
  });
  if (tooltip) {
    icon.setAttribute("title", tooltip);
  }
  return icon;
}
var import_obsidian2, TUTORIAL_MAP;
var init_HelpIcon = __esm({
  "src/utils/HelpIcon.ts"() {
    "use strict";
    import_obsidian2 = require("obsidian");
    TUTORIAL_MAP = {
      "getting-started": { file: "01-Getting-Started.md" },
      "capture-workflows": { file: "02-Capture-Workflows.md" },
      "validation": { file: "03-Validation-Guide.md" },
      "transformation": { file: "04-Transformation-Tools.md" },
      "lifecycle": { file: "05-Lifecycle-Management.md" },
      "dashboard": { file: "06-Dashboard-Guide.md" },
      "graph-view": { file: "07-Graph-View-Guide.md" },
      "batch-operations": { file: "08-Batch-Operations.md" },
      "advanced-features": { file: "09-Advanced-Features.md" },
      "ideate-button": { file: "02-Capture-Workflows.md" },
      "save-button": { file: "02-Capture-Workflows.md" },
      "triage-inbox": { file: "06-Dashboard-Guide.md", anchor: "#triage-inbox" },
      "clusters": { file: "06-Dashboard-Guide.md", anchor: "#clusters-panel" },
      "resurfacing": { file: "06-Dashboard-Guide.md", anchor: "#resurfacing-panel" },
      "filters": { file: "06-Dashboard-Guide.md", anchor: "#filtering" },
      "status-management": { file: "05-Lifecycle-Management.md", anchor: "#status-management" },
      "domain-checking": { file: "03-Validation-Guide.md", anchor: "#domain-checking" },
      "existence-search": { file: "03-Validation-Guide.md", anchor: "#existence-search" },
      "duplicate-detection": { file: "03-Validation-Guide.md", anchor: "#duplicate-detection" },
      "related-notes": { file: "03-Validation-Guide.md", anchor: "#related-notes-discovery" },
      "name-variants": { file: "04-Transformation-Tools.md", anchor: "#name-variants" },
      "scaffolds": { file: "04-Transformation-Tools.md", anchor: "#scaffolds" },
      "mutations": { file: "04-Transformation-Tools.md", anchor: "#mutations" },
      "expansion": { file: "04-Transformation-Tools.md", anchor: "#expansion" },
      "reorganization": { file: "04-Transformation-Tools.md", anchor: "#reorganization" },
      "archiving": { file: "05-Lifecycle-Management.md", anchor: "#archiving-ideas" },
      "codename": { file: "05-Lifecycle-Management.md", anchor: "#codename-generation" },
      "project-elevation": { file: "05-Lifecycle-Management.md", anchor: "#project-elevation" }
    };
  }
});

// src/services/TutorialService.ts
var TutorialService_exports = {};
__export(TutorialService_exports, {
  TutorialService: () => TutorialService
});
var import_obsidian21, TutorialService;
var init_TutorialService = __esm({
  "src/services/TutorialService.ts"() {
    "use strict";
    import_obsidian21 = require("obsidian");
    init_HelpIcon();
    TutorialService = class {
      constructor(app) {
        this.app = app;
      }
      /**
       * Open the tutorial index
       */
      async openIndex() {
        const indexPaths = [
          "Tutorials/00-Index.md",
          "tutorials/00-Index.md",
          // backward compatibility
          "Ideatr/Tutorials/00-Index.md",
          "Ideatr/tutorials/00-Index.md"
        ];
        for (const indexPath of indexPaths) {
          const file = this.app.vault.getAbstractFileByPath(indexPath);
          if (file && file instanceof import_obsidian21.TFile) {
            await this.app.workspace.openLinkText(indexPath, "", true);
            return;
          }
        }
        new import_obsidian21.Notice("Tutorial files not found. Please ensure tutorials are available in your vault.");
      }
      /**
       * Open a specific tutorial topic
       */
      async openTopic(topic) {
        await openTutorial(this.app, topic);
      }
      /**
       * Get the path to a tutorial file
       */
      getTutorialPath(topic) {
        return getTutorialPath(topic);
      }
      /**
       * Check if tutorial files are available
       */
      async areTutorialsAvailable() {
        const indexPaths = [
          "Tutorials/00-Index.md",
          "tutorials/00-Index.md",
          // backward compatibility
          "Ideatr/Tutorials/00-Index.md",
          "Ideatr/tutorials/00-Index.md"
        ];
        for (const indexPath of indexPaths) {
          const file = this.app.vault.getAbstractFileByPath(indexPath);
          if (file && file instanceof import_obsidian21.TFile) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// src/views/MutationErrorModal.ts
var MutationErrorModal_exports = {};
__export(MutationErrorModal_exports, {
  MutationErrorModal: () => MutationErrorModal
});
var import_obsidian37, MutationErrorModal;
var init_MutationErrorModal = __esm({
  "src/views/MutationErrorModal.ts"() {
    "use strict";
    import_obsidian37 = require("obsidian");
    MutationErrorModal = class extends import_obsidian37.Modal {
      errorDetails;
      onRetry;
      constructor(app, errorDetails, onRetry) {
        super(app);
        this.errorDetails = errorDetails;
        this.onRetry = onRetry;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Failed to Generate Mutations" });
        contentEl.addClass("ideatr-error-modal");
        const errorMessage = contentEl.createDiv("ideatr-error-message");
        errorMessage.createEl("p", {
          text: this.errorDetails.message,
          cls: "ideatr-error-text"
        });
        if (this.errorDetails.responseLength !== void 0) {
          const details = contentEl.createDiv("ideatr-error-details");
          details.createEl("p", {
            text: `Response length: ${this.errorDetails.responseLength} characters`,
            cls: "ideatr-error-detail"
          });
          if (this.errorDetails.responsePreview) {
            const previewLabel = details.createEl("strong", {
              text: "Response preview:"
            });
            previewLabel.style.display = "block";
            previewLabel.style.marginTop = "10px";
            previewLabel.style.marginBottom = "5px";
            const preview = details.createEl("pre", {
              text: this.errorDetails.responsePreview,
              cls: "ideatr-error-preview"
            });
            preview.style.fontSize = "0.9em";
            preview.style.maxHeight = "200px";
            preview.style.overflow = "auto";
            preview.style.padding = "10px";
            preview.style.backgroundColor = "var(--background-secondary)";
            preview.style.borderRadius = "4px";
            preview.style.whiteSpace = "pre-wrap";
            preview.style.wordBreak = "break-word";
          }
        }
        const causes = contentEl.createDiv("ideatr-error-causes");
        causes.createEl("strong", {
          text: "Possible causes:",
          cls: "ideatr-error-causes-title"
        });
        const causesList = causes.createEl("ul", {
          cls: "ideatr-error-causes-list"
        });
        if (this.errorDetails.responseLength === 0) {
          causesList.createEl("li", {
            text: "The AI model stopped generating or returned an empty response"
          });
          causesList.createEl("li", {
            text: "The model may have hit a token limit or encountered an error"
          });
          causesList.createEl("li", {
            text: "Try reducing the number of mutations requested or using a different model"
          });
        } else {
          causesList.createEl("li", {
            text: "The AI model returned malformed JSON that could not be parsed"
          });
          causesList.createEl("li", {
            text: "The response may have been cut off mid-generation"
          });
          causesList.createEl("li", {
            text: "Try again - the model may generate valid JSON on retry"
          });
        }
        const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
        buttonContainer.style.marginTop = "20px";
        if (this.errorDetails.canRetry && this.onRetry) {
          const retryButton = buttonContainer.createEl("button", {
            text: "Retry",
            cls: "mod-cta"
          });
          retryButton.addEventListener("click", async () => {
            this.close();
            new import_obsidian37.Notice("Retrying mutation generation...");
            try {
              await this.onRetry();
            } catch (error) {
              new import_obsidian37.Notice(`Retry failed: ${error instanceof Error ? error.message : "Unknown error"}`);
            }
          });
        }
        const closeButton = buttonContainer.createEl("button", {
          text: "Close"
        });
        closeButton.addEventListener("click", () => {
          this.close();
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IdeatrPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian67 = require("obsidian");

// src/capture/CaptureModal.ts
var import_obsidian5 = require("obsidian");

// src/capture/InputValidator.ts
var MIN_IDEA_LENGTH = 3;
var MAX_IDEA_LENGTH = 5e3;
function validateIdeaText(text) {
  const trimmed = text.trim();
  if (trimmed.length === 0) {
    return {
      valid: false,
      error: "Idea cannot be empty"
    };
  }
  if (trimmed.length < MIN_IDEA_LENGTH) {
    return {
      valid: false,
      error: `Idea must be at least ${MIN_IDEA_LENGTH} characters`
    };
  }
  if (trimmed.length > MAX_IDEA_LENGTH) {
    return {
      valid: false,
      error: `Idea must be less than ${MAX_IDEA_LENGTH} characters`
    };
  }
  const sanitized = sanitizeInput(trimmed);
  return {
    valid: true,
    sanitizedText: sanitized
  };
}
function sanitizeInput(text) {
  return text.trim().replace(/\0/g, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/\n{3,}/g, "\n\n");
}

// src/utils/logger.ts
var Logger = class _Logger {
  static app = null;
  static debugMode = true;
  static debugFileChecked = false;
  static debugFileExists = false;
  static DEBUG_FILE_NAMES = [".ideatr-debug", ".ideatr-debug.md"];
  static checkPromise = null;
  /**
   * Initialize the logger with app instance and debug mode setting
   */
  static async initialize(app, debugMode = true) {
    _Logger.app = app;
    _Logger.debugMode = debugMode;
    _Logger.debugFileChecked = false;
    _Logger.debugFileExists = false;
    if (app?.vault) {
      await _Logger.checkDebugFile(app.vault);
    }
    if (_Logger.isDebugEnabled()) {
      console.log("[Ideatr] Logger initialized in DEBUG mode");
    }
    _Logger.logDeployTimestamp().catch(() => {
    });
  }
  /**
   * Log the deploy timestamp if available
   */
  static async logDeployTimestamp() {
    try {
      if (!_Logger.app?.vault) {
        return;
      }
      const timestampPath = ".obsidian/plugins/ideatr/deploy-timestamp.json";
      const exists = await _Logger.app.vault.adapter.exists(timestampPath);
      if (!exists) {
        _Logger.debug("Deploy timestamp file not found (this is normal for first deploy)");
        return;
      }
      const content = await _Logger.app.vault.adapter.read(timestampPath);
      const timestampData = JSON.parse(content);
      const deployedAt = timestampData.deployedAtReadable || timestampData.deployedAt;
      console.log(`[Ideatr] Last deployed: ${deployedAt}`);
      _Logger.info(`Last deployed: ${deployedAt}`);
    } catch (error) {
      _Logger.debug("Could not read deploy timestamp:", error);
    }
  }
  /**
   * Force recheck of debug file (useful if file was created after plugin load)
   */
  static forceRecheckDebugFile() {
    if (_Logger.app?.vault) {
      _Logger.debugFileChecked = false;
      _Logger.debugFileExists = false;
      _Logger.checkDebugFile(_Logger.app.vault).catch(() => {
      });
    }
  }
  /**
   * Check if debug flag file exists in vault root
   * This is a simple way for developers to enable debug mode without changing settings
   * Checks for both `.ideatr-debug` and `.ideatr-debug.md`
   */
  static async checkDebugFile(vault) {
    if (_Logger.debugFileChecked && _Logger.checkPromise) {
      await _Logger.checkPromise;
      return;
    }
    if (_Logger.debugFileChecked) {
      return;
    }
    _Logger.checkPromise = (async () => {
      try {
        for (const fileName of _Logger.DEBUG_FILE_NAMES) {
          const exists = await vault.adapter.exists(fileName);
          if (exists) {
            _Logger.debugFileExists = true;
            _Logger.debugFileChecked = true;
            _Logger.checkPromise = null;
            return;
          }
        }
        _Logger.debugFileExists = false;
      } catch {
        _Logger.debugFileExists = false;
      } finally {
        _Logger.debugFileChecked = true;
        _Logger.checkPromise = null;
      }
    })();
    await _Logger.checkPromise;
  }
  /**
   * Check if debug mode is enabled
   */
  /**
   * Check if debug mode is enabled
   * Public method to allow other parts of the codebase to check debug status
   */
  static isDebugEnabled() {
    if (_Logger.debugMode) {
      return true;
    }
    return _Logger.debugFileExists;
  }
  /**
   * Log debug information (only shown in debug mode)
   */
  static debug(...args) {
    if (_Logger.isDebugEnabled()) {
      console.log("[Ideatr Debug]", ...args);
    }
  }
  /**
   * Log informational messages (only shown in debug mode)
   */
  static info(...args) {
    if (_Logger.isDebugEnabled()) {
      console.log("[Ideatr]", ...args);
    }
  }
  /**
   * Log warnings (only shown in debug mode)
   * For warnings that should always be shown, use console.warn directly
   */
  static warn(...args) {
    if (_Logger.isDebugEnabled()) {
      console.warn("[Ideatr]", ...args);
    }
  }
  /**
   * Log errors (always shown - use console.error directly for critical errors)
   * This is for non-critical errors that can be gated
   */
  static error(...args) {
    if (_Logger.isDebugEnabled()) {
      console.error("[Ideatr]", ...args);
    }
  }
  /**
   * Log with a specific tag/context (only shown in debug mode)
   */
  static log(tag, ...args) {
    if (_Logger.isDebugEnabled()) {
      console.log(`[Ideatr:${tag}]`, ...args);
    }
  }
};

// src/utils/ideaNameExtractor.ts
function extractIdeaNameRuleBased(ideaText) {
  if (!ideaText || ideaText.trim().length === 0) {
    return "";
  }
  const firstLine = ideaText.split("\n")[0].trim();
  let name = firstLine.substring(0, 50).trim();
  name = name.replace(/[^a-zA-Z0-9\s-]/g, "");
  if (name.length < 3) {
    name = ideaText.substring(0, 50).trim();
    name = name.replace(/[^a-zA-Z0-9\s-]/g, "");
  }
  return name;
}
async function extractIdeaNameWithLLM(ideaText, llmService) {
  if (!llmService?.complete) {
    return extractIdeaNameRuleBased(ideaText);
  }
  if (llmService.isAvailable && !llmService.isAvailable()) {
    return extractIdeaNameRuleBased(ideaText);
  }
  try {
    const prompt = `Extract a concise, descriptive name or title for this idea.

Idea: "${ideaText}"

CRITICAL REQUIREMENTS:
- Extract the CORE CONCEPT, not just the first words
- Focus on what makes this idea unique or identifiable
- Create a title that someone could use to quickly understand what this is about

Rules:
- Return ONLY the name/title (3-50 characters)
- No quotes, no explanation, no prefixes like "Title:" or "Name:"
- If the idea is a long description, extract the key concept (e.g., "AI puzzle game with monkeys" \u2192 "Monkey Puzzle Game" or "AI Monkey Puzzle")
- If the first line is already a good title, use it
- Make it descriptive but concise - should capture the essence in a few words

Examples:
- "AI generated puzzle full of interlinked monkeys that look similar, sort of a where's waldo of monkeys" \u2192 "Monkey Puzzle Game" or "AI Monkey Find"
- "notification app that sends alerts" \u2192 "Notification App" or "Alert System"
- "task manager for teams" \u2192 "Team Task Manager"

Name:`;
    const response = await llmService.complete(prompt, {
      temperature: 0.3,
      // Lower temperature for more consistent extraction
      n_predict: 50,
      // Limit response length
      stop: ["\n", ".", "!", "?"]
      // Stop at sentence boundaries
    });
    let extractedName = response.trim();
    extractedName = extractedName.replace(/^["']|["']$/g, "");
    extractedName = extractedName.substring(0, 50).trim();
    extractedName = extractedName.replace(/[^a-zA-Z0-9\s-]/g, "");
    if (extractedName.length < 3) {
      return extractIdeaNameRuleBased(ideaText);
    }
    return extractedName;
  } catch (error) {
    Logger.warn("LLM name extraction failed, using rule-based fallback:", error);
    return extractIdeaNameRuleBased(ideaText);
  }
}

// src/services/SearchQueryGenerator.ts
var SearchQueryGenerator = class {
  /**
   * Generate search query from idea text
   * @param text - Idea text
   * @param category - Optional category for context-aware queries
   * @param projectName - Optional project name to include in query
   */
  generateQuery(text, category, projectName) {
    if (!text || text.trim().length === 0) {
      return "";
    }
    const trimmed = text.trim();
    let keyTerms = this.extractKeyTerms(trimmed);
    const nameToUse = projectName || extractIdeaNameRuleBased(text);
    if (nameToUse && nameToUse.trim().length > 0 && nameToUse.length >= 3) {
      const cleanName = nameToUse.trim();
      if (!keyTerms.toLowerCase().includes(cleanName.toLowerCase())) {
        keyTerms = `${cleanName} ${keyTerms}`;
      }
    }
    if (!category) {
      return keyTerms;
    }
    switch (category) {
      case "saas":
      case "tool":
      case "ux":
        return `${keyTerms} app`;
      case "game":
      case "mechanic":
        return `${keyTerms} game`;
      case "hardware":
      case "brand":
        return `${keyTerms} product`;
      case "story":
      case "ip":
        return `${keyTerms} book`;
      default:
        return keyTerms;
    }
  }
  /**
   * Generate multiple query variations for better coverage
   * @param text - Idea text
   * @param category - Optional category
   * @param projectName - Optional project name to include in queries
   */
  generateQueryVariations(text, category, projectName) {
    if (!text || text.trim().length === 0) {
      return [];
    }
    const trimmed = text.trim();
    let keyTerms = this.extractKeyTerms(trimmed);
    const nameToUse = projectName || extractIdeaNameRuleBased(text);
    if (nameToUse && nameToUse.trim().length > 0 && nameToUse.length >= 3) {
      const cleanName = nameToUse.trim();
      if (!keyTerms.toLowerCase().includes(cleanName.toLowerCase())) {
        keyTerms = `${cleanName} ${keyTerms}`;
      }
    }
    const variations = [];
    if (!category) {
      variations.push(keyTerms);
      variations.push(`${keyTerms} product`);
      variations.push(`${keyTerms} service`);
      return variations;
    }
    switch (category) {
      case "saas":
      case "tool":
      case "ux":
        variations.push(`${keyTerms} app`);
        variations.push(`${keyTerms} software`);
        variations.push(`${keyTerms} tool`);
        break;
      case "game":
      case "mechanic":
        variations.push(`${keyTerms} game`);
        variations.push(`${keyTerms} gameplay`);
        variations.push(`${keyTerms} game mechanic`);
        break;
      case "hardware":
      case "brand":
        variations.push(`${keyTerms} product`);
        variations.push(`${keyTerms} hardware`);
        variations.push(`${keyTerms} device`);
        break;
      case "story":
      case "ip":
        variations.push(`${keyTerms} book`);
        variations.push(`${keyTerms} novel`);
        variations.push(`${keyTerms} story`);
        break;
      default:
        variations.push(keyTerms);
        variations.push(`${keyTerms} product`);
    }
    return variations;
  }
  /**
   * Extract key terms from idea text
   * Simple implementation: takes first meaningful words (up to 5 words)
   */
  extractKeyTerms(text) {
    const words = text.split(/\s+/).filter((word) => {
      const lower = word.toLowerCase();
      return !["a", "an", "the", "is", "are", "was", "were", "to", "of", "in", "on", "at", "for", "with"].includes(lower);
    }).slice(0, 5);
    return words.join(" ") || text.split(/\s+/).slice(0, 3).join(" ");
  }
};

// src/services/SearchResultFormatter.ts
function getTypeFromCategory(category) {
  switch (category) {
    case "game":
    case "mechanic":
      return "game";
    case "story":
    case "ip":
      return "story";
    case "saas":
    case "tool":
    case "ux":
      return "app";
    case "hardware":
    case "brand":
      return "product";
    case "personal":
    case "":
    default:
      return "similar";
  }
}
function formatSearchResultsForFrontmatter(results, maxResults, category) {
  if (results.length === 0) {
    return [];
  }
  const limit2 = maxResults || results.length;
  const limitedResults = results.slice(0, limit2);
  const type = category !== void 0 ? getTypeFromCategory(category) : "product";
  const prefix = type === "similar" ? "Found similar:" : `Found similar ${type}:`;
  return limitedResults.map((result) => {
    const parts = [];
    const title = result.title.length > 100 ? result.title.substring(0, 100) + "..." : result.title;
    parts.push(`${prefix} ${title}`);
    parts.push(`URL: ${result.url}`);
    if (result.date) {
      parts.push(`Date: ${result.date}`);
    }
    return parts.join(" | ");
  });
}

// src/views/ClassificationResultsModal.ts
var import_obsidian = require("obsidian");
var ClassificationResultsModal = class extends import_obsidian.Modal {
  results;
  onAccept;
  onEdit;
  onRetry;
  editedTags = [];
  constructor(app, results, onAccept, onEdit, onRetry) {
    super(app);
    this.results = results;
    this.onAccept = onAccept;
    this.onEdit = onEdit;
    this.onRetry = onRetry;
    this.editedTags = [...results.tags];
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-classification-results-modal");
    contentEl.createEl("h2", { text: "Classification Results" });
    const categoryContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
    categoryContainer.createEl("label", { text: "Category:", attr: { for: "ideatr-category-display" } });
    const categoryDisplay = categoryContainer.createEl("div", {
      cls: "ideatr-category",
      text: this.results.category || "(none)"
    });
    if (!this.results.category) {
      categoryDisplay.addClass("ideatr-empty");
    }
    const tagsContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
    tagsContainer.createEl("label", { text: "Tags:" });
    const tagsList = tagsContainer.createEl("div", { cls: "ideatr-tags-list" });
    this.editedTags.forEach((tag, index) => {
      const tagItem = tagsList.createEl("div", { cls: "ideatr-tag-item" });
      const tagInput = tagItem.createEl("input", {
        attr: {
          type: "text",
          value: tag,
          placeholder: "Tag name"
        },
        cls: "ideatr-tag-input"
      });
      tagInput.addEventListener("input", (e) => {
        const target = e.target;
        this.editedTags[index] = target.value.trim();
      });
      const removeButton = tagItem.createEl("button", {
        text: "\xD7",
        cls: "ideatr-remove-tag"
      });
      removeButton.addEventListener("click", () => {
        this.editedTags.splice(index, 1);
        this.renderTags(tagsList);
      });
    });
    const addTagButton = tagsList.createEl("button", {
      text: "+ Add Tag",
      cls: "ideatr-add-tag"
    });
    addTagButton.addEventListener("click", () => {
      this.editedTags.push("");
      this.renderTags(tagsList);
    });
    if (this.results.confidence !== void 0) {
      const confidenceContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
      confidenceContainer.createEl("label", { text: "Confidence:" });
      const confidenceBar = confidenceContainer.createEl("div", { cls: "ideatr-confidence-bar" });
      confidenceBar.createEl("div", {
        cls: "ideatr-confidence-fill",
        attr: {
          style: `width: ${(this.results.confidence * 100).toFixed(0)}%`
        }
      });
      confidenceContainer.createEl("span", {
        cls: "ideatr-confidence-text",
        text: `${(this.results.confidence * 100).toFixed(0)}%`
      });
    }
    const buttonContainer = contentEl.createEl("div", { cls: "ideatr-button-container" });
    const acceptButton = buttonContainer.createEl("button", {
      text: "Accept",
      cls: "mod-cta"
    });
    acceptButton.addEventListener("click", () => this.handleAccept());
    const editButton = buttonContainer.createEl("button", {
      text: "Edit in Note"
    });
    editButton.addEventListener("click", () => this.handleEdit());
    const retryButton = buttonContainer.createEl("button", {
      text: "Retry"
    });
    retryButton.addEventListener("click", () => this.handleRetry());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  renderTags(container) {
    container.empty();
    this.editedTags.forEach((tag, index) => {
      const tagItem = container.createEl("div", { cls: "ideatr-tag-item" });
      const tagInput = tagItem.createEl("input", {
        attr: {
          type: "text",
          value: tag,
          placeholder: "Tag name"
        },
        cls: "ideatr-tag-input"
      });
      tagInput.addEventListener("input", (e) => {
        const target = e.target;
        this.editedTags[index] = target.value.trim();
      });
      const removeButton = tagItem.createEl("button", {
        text: "\xD7",
        cls: "ideatr-remove-tag"
      });
      removeButton.addEventListener("click", () => {
        this.editedTags.splice(index, 1);
        this.renderTags(container);
      });
    });
    const addTagButton = container.createEl("button", {
      text: "+ Add Tag",
      cls: "ideatr-add-tag"
    });
    addTagButton.addEventListener("click", () => {
      this.editedTags.push("");
      this.renderTags(container);
    });
  }
  handleAccept() {
    const validTags = this.editedTags.filter((tag) => tag.trim().length > 0);
    const updatedResults = {
      ...this.results,
      tags: validTags
    };
    this.onAccept(updatedResults);
    this.close();
  }
  handleEdit() {
    this.close();
    this.onEdit();
  }
  handleRetry() {
    this.close();
    this.onRetry();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/capture/CaptureModal.ts
init_HelpIcon();

// src/services/ModelManager.ts
var fs = __toESM(require("fs/promises"));
var path = __toESM(require("path"));
var os = __toESM(require("os"));
var import_fs = require("fs");
var import_crypto = require("crypto");
var MODELS = {
  // Tier 1: Default (Best for most)
  "phi-3.5-mini": {
    key: "phi-3.5-mini",
    name: "Phi-3.5 Mini",
    badge: "EFFICIENT",
    fileName: "Phi-3.5-mini-instruct-Q8_0.gguf",
    url: "https://huggingface.co/bartowski/Phi-3.5-mini-instruct-GGUF/resolve/main/Phi-3.5-mini-instruct-Q8_0.gguf",
    sizeBytes: 436e7,
    // 4.06GB from bartowski repo
    sizeMB: 4060,
    ram: "6-8GB",
    quality: 4,
    speed: 5,
    description: "Fast, lightweight, and ideal for everyday tasks. Excellent at structured work like classification and tagging.",
    pros: ["Fast", "Accurate", "Small download", "Low RAM usage"],
    cons: ["Less creative than larger models"],
    bestFor: "Most users",
    chatTemplate: "phi-3.5",
    sha256: "76fbf02f6fe92af57dbd818409bc8a0240026f1f3609bb405c3be94c973fb823"
  },
  // Tier 2: Step up (More quality)
  "qwen-2.5-7b": {
    key: "qwen-2.5-7b",
    name: "Qwen 2.5 7B",
    badge: "VERSATILE",
    fileName: "Qwen2.5-7B-Instruct-Q8_0.gguf",
    url: "https://huggingface.co/bartowski/Qwen2.5-7B-Instruct-GGUF/resolve/main/Qwen2.5-7B-Instruct-Q8_0.gguf",
    sizeBytes: 78e8,
    sizeMB: 7800,
    ram: "10GB",
    quality: 4.5,
    speed: 4,
    description: "A well-rounded model with stronger reasoning. Great at handling more complex and multilingual tasks.",
    pros: ["Higher accuracy", "Better context understanding", "Multilingual"],
    cons: ["Larger download", "More RAM needed"],
    bestFor: "Users with 16GB+ RAM who want better quality",
    chatTemplate: "qwen-2.5",
    sha256: "9c6a6e61664446321d9c0dd7ee28a0d03914277609e21bc0e1fce4abe780ce1b"
  },
  // Tier 3: Premium (Best quality, reasonable size)
  "llama-3.1-8b": {
    key: "llama-3.1-8b",
    name: "Llama 3.1 8B",
    badge: "RELIABLE",
    fileName: "Meta-Llama-3.1-8B-Instruct-Q8_0.gguf",
    url: "https://huggingface.co/bartowski/Meta-Llama-3.1-8B-Instruct-GGUF/resolve/main/Meta-Llama-3.1-8B-Instruct-Q8_0.gguf",
    sizeBytes: 85e8,
    sizeMB: 8500,
    ram: "10-12GB",
    quality: 4.5,
    speed: 3,
    description: "Meta's trusted and widely documented model. Excellent accuracy with strong community support.",
    pros: ["Very accurate", "Well-tested", "Strong community"],
    cons: ["Larger download", "Slower inference"],
    bestFor: "Power users who want Meta's best",
    chatTemplate: "llama-3.1",
    sha256: "9da71c45c90a821809821244d4971e5e5dfad7eb091f0b8ff0546392393b6283"
  },
  // Tier 4: Maximum (For enthusiasts only)
  "llama-3.3-70b": {
    key: "llama-3.3-70b",
    name: "Llama 3.3 70B",
    badge: "MAXIMUM",
    fileName: "Llama-3.3-70B-Instruct-Q4_K_M.gguf",
    url: "https://huggingface.co/bartowski/Llama-3.3-70B-Instruct-GGUF/resolve/main/Llama-3.3-70B-Instruct-Q4_K_M.gguf",
    sizeBytes: 425e8,
    // Q4_K_M quantization is approximately 42.5GB
    sizeMB: 42500,
    ram: "48GB+",
    quality: 5,
    speed: 1,
    description: "Top-tier performance with near-GPT-4 quality. Requires a high-end desktop workstation or powerful laptop with substantial RAM.",
    pros: [
      "Best possible quality",
      "Near-perfect accuracy",
      "Understands complex nuance"
    ],
    cons: [
      "Huge download (~42.5GB)",
      "Requires 48GB+ RAM",
      "Very slow on most hardware"
    ],
    bestFor: "Desktop workstations with 64GB+ RAM",
    chatTemplate: "llama-3.1",
    sha256: "32df3baccb556f9840059b2528b2dee4d3d516b24afdfb9d0c56ff5f63e3a664"
  }
};
var ModelManager = class {
  modelConfig;
  modelDir;
  modelPath;
  modelInfo;
  abortController = null;
  isDownloading = false;
  downloadProgressCallback = null;
  activeHashOperations = 0;
  // Track concurrent hash operations
  hashOperationLock = Promise.resolve();
  // Serialize hash operations
  constructor(modelKey = "phi-3.5-mini") {
    if (!MODELS[modelKey]) {
      Logger.warn(`Invalid model key: ${modelKey}, falling back to phi-3.5-mini`);
      modelKey = "phi-3.5-mini";
    }
    this.modelConfig = MODELS[modelKey];
    const homeDir = os.homedir();
    this.modelDir = path.join(homeDir, ".ideatr", "models");
    this.modelPath = path.join(this.modelDir, this.modelConfig.fileName);
    this.modelInfo = {
      name: this.modelConfig.fileName,
      sizeBytes: this.modelConfig.sizeBytes,
      sizeMB: this.modelConfig.sizeMB,
      checksum: this.modelConfig.sha256 || "",
      // SHA-256 checksum from config
      downloadUrl: this.modelConfig.url
    };
  }
  getModelPath() {
    return this.modelPath;
  }
  getModelInfo() {
    return { ...this.modelInfo };
  }
  getModelConfig() {
    return { ...this.modelConfig };
  }
  getAvailableModels() {
    return MODELS;
  }
  async isModelDownloaded() {
    try {
      await fs.access(this.modelPath);
      return true;
    } catch {
      return false;
    }
  }
  async downloadModel(progressCallback, abortSignal, overwrite = false) {
    try {
      await fs.mkdir(this.modelDir, { recursive: true });
    } catch (error) {
      throw new Error(`Failed to create model directory: ${error}`);
    }
    if (await this.isModelDownloaded() && !overwrite) {
      throw new Error("Model already downloaded");
    }
    if (overwrite && await this.isModelDownloaded()) {
      try {
        await fs.unlink(this.modelPath);
      } catch (error) {
        throw new Error(`Failed to remove existing model: ${error}`);
      }
    }
    this.isDownloading = true;
    this.downloadProgressCallback = progressCallback || null;
    if (abortSignal) {
    }
    if (!abortSignal) {
      this.abortController = new AbortController();
    }
    const actualSignal = abortSignal || this.abortController.signal;
    try {
      const response = await fetch(this.modelInfo.downloadUrl, {
        signal: actualSignal,
        headers: {
          "Accept": "application/octet-stream",
          "User-Agent": "Obsidian-IdeaTr/1.0 (Model Downloader)"
        }
      });
      if (!response.ok) {
        if (response.status === 401) {
          const urlMatch = this.modelInfo.downloadUrl.match(/^https:\/\/huggingface\.co\/([^\/]+\/[^\/]+)\//);
          const modelPageUrl = urlMatch ? `https://huggingface.co/${urlMatch[1]}` : "https://huggingface.co";
          throw new Error(
            `Download failed: Authentication required (401). This model may require accepting terms on Hugging Face. Please visit ${modelPageUrl} to accept any required agreements, then try again.`
          );
        }
        throw new Error(`Download failed: ${response.status} ${response.statusText}`);
      }
      const contentLength = response.headers.get("content-length");
      const totalBytes = contentLength ? parseInt(contentLength, 10) : this.modelInfo.sizeBytes;
      const totalMB = totalBytes / (1024 * 1024);
      if (contentLength) {
        this.modelInfo.sizeBytes = totalBytes;
        this.modelInfo.sizeMB = totalMB;
      }
      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error("Response body is not readable");
      }
      const writeStream = (0, import_fs.createWriteStream)(this.modelPath);
      let downloadedBytes = 0;
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          if (actualSignal.aborted) {
            throw new Error("Download cancelled");
          }
          await new Promise((resolve4, reject) => {
            writeStream.write(Buffer.from(value), (error) => {
              if (error) {
                reject(error);
              } else {
                resolve4();
              }
            });
          });
          downloadedBytes += value.length;
          const downloadedMB = downloadedBytes / (1024 * 1024);
          const progress = downloadedBytes / totalBytes * 100;
          if (progressCallback) {
            progressCallback(progress, downloadedMB, totalMB);
          }
        }
        await new Promise((resolve4, reject) => {
          writeStream.end((error) => {
            if (error) {
              reject(error);
            } else {
              resolve4();
            }
          });
        });
        if (downloadedBytes !== totalBytes) {
          throw new Error(`Download incomplete: expected ${totalBytes} bytes, got ${downloadedBytes} bytes`);
        }
      } catch (error) {
        writeStream.destroy();
        try {
          await fs.unlink(this.modelPath);
        } catch {
        }
        throw error;
      }
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        try {
          await fs.unlink(this.modelPath);
        } catch {
        }
        throw new Error("Download cancelled");
      }
      throw error;
    } finally {
      this.isDownloading = false;
      this.downloadProgressCallback = null;
      if (!abortSignal) {
        this.abortController = null;
      }
    }
  }
  /**
   * Check if a download is currently in progress
   */
  isDownloadInProgress() {
    return this.isDownloading;
  }
  /**
   * Get current download progress callback (for background tracking)
   */
  getDownloadProgressCallback() {
    return this.downloadProgressCallback;
  }
  cancelDownload() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
  async verifyModelIntegrity() {
    try {
      if (!await this.isModelDownloaded()) {
        return false;
      }
      const stats = await fs.stat(this.modelPath);
      const actualSizeBytes = stats.size;
      const actualSizeMB = actualSizeBytes / (1024 * 1024);
      if (actualSizeBytes === 0) {
        Logger.warn("Model integrity check failed - file is empty");
        return false;
      }
      const expectedSizeBytes = this.modelInfo.sizeBytes;
      const expectedSizeMB = this.modelInfo.sizeMB;
      const minSizeBytes = expectedSizeBytes * 0.8;
      const maxSizeBytes = expectedSizeBytes * 1.2;
      const sizeInRange = actualSizeBytes >= minSizeBytes && actualSizeBytes <= maxSizeBytes;
      if (this.modelInfo.checksum && this.modelInfo.checksum.trim().length > 0) {
        await this.hashOperationLock;
        let lockResolver;
        this.hashOperationLock = new Promise((resolve4) => {
          lockResolver = resolve4;
        });
        try {
          const calculatedChecksum = await new Promise((resolve4, reject) => {
            this.activeHashOperations++;
            const beforeMemory = process.memoryUsage().rss;
            Logger.debug("HASH START", this.modelPath, "Active:", this.activeHashOperations);
            const hash = (0, import_crypto.createHash)("sha256");
            const stream = (0, import_fs.createReadStream)(this.modelPath);
            const cleanup = () => {
              if (!stream.destroyed) {
                stream.destroy();
              }
              this.activeHashOperations--;
              const afterMemory = process.memoryUsage().rss;
              Logger.debug(
                "HASH END",
                this.modelPath,
                "Active:",
                this.activeHashOperations,
                "Memory delta:",
                ((afterMemory - beforeMemory) / 1024 / 1024).toFixed(2),
                "MB"
              );
              lockResolver();
            };
            stream.on("data", (data) => hash.update(data));
            stream.on("end", () => {
              try {
                const result = hash.digest("hex").toLowerCase();
                cleanup();
                resolve4(result);
              } catch (error) {
                cleanup();
                reject(error);
              }
            });
            stream.on("error", (error) => {
              cleanup();
              reject(error);
            });
            stream.on("close", () => {
              if (this.activeHashOperations > 0) {
                this.activeHashOperations--;
              }
            });
          });
          const expectedChecksum = this.modelInfo.checksum.toLowerCase().trim();
          const checksumMatches = calculatedChecksum === expectedChecksum;
          if (!checksumMatches) {
            Logger.warn("Model integrity check failed - SHA256 checksum mismatch:", {
              expected: expectedChecksum.substring(0, 16) + "...",
              calculated: calculatedChecksum.substring(0, 16) + "...",
              sizeInRange,
              modelPath: this.modelPath
            });
            return false;
          }
          if (!sizeInRange) {
            Logger.warn("Model integrity check - checksum matches but size outside expected range:", {
              expectedSizeMB: expectedSizeMB.toFixed(2),
              actualSizeMB: actualSizeMB.toFixed(2)
            });
          }
          return true;
        } catch (error) {
          lockResolver();
          throw error;
        }
      }
      if (!sizeInRange) {
        Logger.warn("Model integrity check - size outside expected range (no checksum available):", {
          expectedSizeMB: expectedSizeMB.toFixed(2),
          actualSizeMB: actualSizeMB.toFixed(2),
          minSizeMB: (minSizeBytes / (1024 * 1024)).toFixed(2),
          maxSizeMB: (maxSizeBytes / (1024 * 1024)).toFixed(2)
        });
      }
      return sizeInRange;
    } catch (error) {
      console.error("Model integrity check error:", error);
      return false;
    }
  }
  /**
   * Calculate SHA-256 checksum of the downloaded model file
   * Useful for generating checksums to add to model configs
   * Uses streaming to handle large files efficiently
   */
  async calculateModelChecksum() {
    try {
      if (!await this.isModelDownloaded()) {
        return null;
      }
      await this.hashOperationLock;
      let lockResolver;
      this.hashOperationLock = new Promise((resolve4) => {
        lockResolver = resolve4;
      });
      try {
        return await new Promise((resolve4, reject) => {
          this.activeHashOperations++;
          const beforeMemory = process.memoryUsage().rss;
          Logger.debug("HASH START", this.modelPath, "Active:", this.activeHashOperations);
          const hash = (0, import_crypto.createHash)("sha256");
          const stream = (0, import_fs.createReadStream)(this.modelPath);
          const cleanup = () => {
            if (!stream.destroyed) {
              stream.destroy();
            }
            this.activeHashOperations--;
            const afterMemory = process.memoryUsage().rss;
            Logger.debug(
              "HASH END",
              this.modelPath,
              "Active:",
              this.activeHashOperations,
              "Memory delta:",
              ((afterMemory - beforeMemory) / 1024 / 1024).toFixed(2),
              "MB"
            );
            lockResolver();
          };
          stream.on("data", (data) => hash.update(data));
          stream.on("end", () => {
            try {
              const result = hash.digest("hex");
              cleanup();
              resolve4(result);
            } catch (error) {
              cleanup();
              reject(error);
            }
          });
          stream.on("error", (error) => {
            cleanup();
            reject(error);
          });
          stream.on("close", () => {
            if (this.activeHashOperations > 0) {
              this.activeHashOperations--;
            }
          });
        });
      } catch (error) {
        lockResolver();
        throw error;
      }
    } catch (error) {
      Logger.error("Failed to calculate model checksum:", error);
      return null;
    }
  }
};

// src/types/classification.ts
var ClassificationError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "ClassificationError";
  }
};
var APITimeoutError = class extends ClassificationError {
  constructor(message = "API request timed out") {
    super(message);
    this.name = "APITimeoutError";
  }
};
var NetworkError = class extends ClassificationError {
  constructor(message = "Network error occurred") {
    super(message);
    this.name = "NetworkError";
  }
};

// src/services/LlamaService.ts
var import_child_process = require("child_process");
var import_obsidian3 = require("obsidian");
var path2 = __toESM(require("path"));
var os3 = __toESM(require("os"));
var fs2 = __toESM(require("fs"));

// src/utils/jsonRepair.ts
function repairJSON(jsonStr) {
  let repaired = jsonStr.trim();
  repaired = fixMissingCommas(repaired);
  repaired = repaired.replace(/,\s*([}\]])/g, "$1");
  repaired = repaired.replace(/,\s*$/, "");
  let openBraces = 0;
  let openBrackets = 0;
  let inString = false;
  let escapeNext = false;
  let lastNonWhitespace = -1;
  for (let i = 0; i < repaired.length; i++) {
    const char = repaired[i];
    if (!/\s/.test(char)) {
      lastNonWhitespace = i;
    }
    if (escapeNext) {
      escapeNext = false;
      continue;
    }
    if (char === "\\") {
      escapeNext = true;
      continue;
    }
    if (char === '"' && !escapeNext) {
      inString = !inString;
      continue;
    }
    if (inString) {
      continue;
    }
    if (char === "{") {
      openBraces++;
    } else if (char === "}") {
      openBraces--;
    } else if (char === "[") {
      openBrackets++;
    } else if (char === "]") {
      openBrackets--;
    }
  }
  repaired = repaired.trimEnd();
  if (inString && lastNonWhitespace >= 0) {
    repaired += '"';
  }
  while (openBraces > 0) {
    repaired += "}";
    openBraces--;
  }
  while (openBrackets > 0) {
    repaired += "]";
    openBrackets--;
  }
  return repaired;
}
function fixMissingCommas(jsonStr) {
  let result = "";
  let i = 0;
  let inString = false;
  let escapeNext = false;
  while (i < jsonStr.length) {
    const char = jsonStr[i];
    if (escapeNext) {
      result += char;
      escapeNext = false;
      i++;
      continue;
    }
    if (char === "\\") {
      result += char;
      escapeNext = true;
      i++;
      continue;
    }
    if (char === '"' && !escapeNext) {
      inString = !inString;
      result += char;
      if (!inString) {
        let j = i + 1;
        while (j < jsonStr.length && /\s/.test(jsonStr[j])) {
          j++;
        }
        if (j < jsonStr.length) {
          const nextChar = jsonStr[j];
          const between = jsonStr.substring(i + 1, j);
          const hasComma = between.indexOf(",") !== -1;
          if (!hasComma && nextChar === '"') {
            let k = i - 1;
            while (k >= 0 && /\s/.test(jsonStr[k])) {
              k--;
            }
            if (k >= 0) {
              const beforeQuote = jsonStr[k];
              if (beforeQuote !== ":" && (beforeQuote === "," || beforeQuote === "{" || beforeQuote === "[" || beforeQuote === '"' || beforeQuote === "}" || beforeQuote === "]")) {
                result += ",";
              }
            } else {
              result += ",";
            }
          }
        }
      }
      i++;
      continue;
    }
    if (inString) {
      result += char;
      i++;
      continue;
    }
    if ((char === "}" || char === "]") && i + 1 < jsonStr.length) {
      result += char;
      let j = i + 1;
      while (j < jsonStr.length && /\s/.test(jsonStr[j])) {
        j++;
      }
      if (j < jsonStr.length) {
        const nextChar = jsonStr[j];
        const between = jsonStr.substring(i + 1, j);
        const hasComma = between.indexOf(",") !== -1;
        if (!hasComma && (nextChar === '"' || nextChar === "{" || nextChar === "[")) {
          result += ",";
        }
      }
      i++;
      continue;
    }
    result += char;
    i++;
  }
  return result;
}
function extractAndRepairJSON(content, isArray3 = false) {
  let jsonStr = content.trim();
  const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)```/;
  const codeBlockMatch = jsonStr.match(codeBlockRegex);
  if (codeBlockMatch && codeBlockMatch[1]) {
    jsonStr = codeBlockMatch[1].trim();
  }
  jsonStr = jsonStr.replace(/^(?:Here'?s?|Here is|Response:|Output:).*?:\s*\n?\s*/i, "");
  jsonStr = jsonStr.replace(/^(?:Example:|Example format:|Example response:).*?:\s*\n?\s*/i, "");
  jsonStr = jsonStr.replace(/^Here is.*?:\s*\n?\s*/i, "");
  const arrayStart = jsonStr.indexOf("[");
  const objectStart = jsonStr.indexOf("{");
  let startIndex = -1;
  if (isArray3 && arrayStart !== -1) {
    startIndex = arrayStart;
  } else if (!isArray3 && objectStart !== -1) {
    startIndex = objectStart;
  } else if (arrayStart !== -1 && objectStart !== -1) {
    startIndex = Math.min(arrayStart, objectStart);
  } else if (!isArray3 && objectStart === -1) {
    startIndex = -1;
  } else if (arrayStart !== -1) {
    startIndex = arrayStart;
  } else if (objectStart !== -1) {
    startIndex = objectStart;
  }
  if (startIndex !== -1 && startIndex > 0) {
    jsonStr = jsonStr.substring(startIndex);
  }
  jsonStr = jsonStr.trim();
  if (isArray3 && !jsonStr.startsWith("[")) {
    if (jsonStr.startsWith("{")) {
      jsonStr = `[${jsonStr}]`;
    } else {
      jsonStr = `[${jsonStr}`;
    }
  } else if (!isArray3 && !jsonStr.startsWith("{")) {
    jsonStr = `{${jsonStr}`;
  }
  if (isArray3 && jsonStr.startsWith("[")) {
    let bracketCount = 0;
    let inString = false;
    let escapeNext = false;
    let endIndex = -1;
    for (let i = 0; i < jsonStr.length; i++) {
      const char = jsonStr[i];
      if (escapeNext) {
        escapeNext = false;
        continue;
      }
      if (char === "\\") {
        escapeNext = true;
        continue;
      }
      if (char === '"' && !escapeNext) {
        inString = !inString;
        continue;
      }
      if (inString) {
        continue;
      }
      if (char === "[") {
        bracketCount++;
      } else if (char === "]") {
        bracketCount--;
        if (bracketCount === 0) {
          endIndex = i + 1;
          break;
        }
      }
    }
    if (endIndex !== -1 && bracketCount === 0) {
      jsonStr = jsonStr.substring(0, endIndex);
    }
  } else if (!isArray3 && jsonStr.startsWith("{")) {
    let braceCount = 0;
    let inString = false;
    let escapeNext = false;
    let endIndex = -1;
    for (let i = 0; i < jsonStr.length; i++) {
      const char = jsonStr[i];
      if (escapeNext) {
        escapeNext = false;
        continue;
      }
      if (char === "\\") {
        escapeNext = true;
        continue;
      }
      if (char === '"' && !escapeNext) {
        inString = !inString;
        continue;
      }
      if (inString) {
        continue;
      }
      if (char === "{") {
        braceCount++;
      } else if (char === "}") {
        braceCount--;
        if (braceCount === 0) {
          endIndex = i + 1;
          break;
        }
      }
    }
    if (endIndex !== -1 && braceCount === 0) {
      jsonStr = jsonStr.substring(0, endIndex);
    }
  }
  return repairJSON(jsonStr);
}

// src/utils/systemCapabilities.ts
var os2 = __toESM(require("os"));
function getSystemCapabilities() {
  const totalBytes = os2.totalmem();
  const freeBytes = os2.freemem();
  const totalRAMGB = totalBytes / (1024 * 1024 * 1024);
  const availableRAMGB = freeBytes / (1024 * 1024 * 1024);
  return {
    totalRAMGB,
    availableRAMGB,
    platform: os2.platform(),
    arch: os2.arch()
  };
}
function parseRAMRequirement(ramString) {
  const match = ramString.match(/(\d+)/);
  if (match) {
    return parseInt(match[1], 10);
  }
  return 0;
}
function checkModelCompatibility(modelKey, capabilities) {
  const modelConfig = MODELS[modelKey];
  if (!modelConfig) {
    Logger.warn(`Unknown model key: ${modelKey}`);
    return { isCompatible: true };
  }
  const systemInfo = capabilities || getSystemCapabilities();
  const requiredRAM = parseRAMRequirement(modelConfig.ram);
  const totalRAM = systemInfo.totalRAMGB;
  if (requiredRAM > totalRAM) {
    const warning = `This model requires ${modelConfig.ram} RAM, but your system has ${totalRAM.toFixed(1)}GB total RAM. The model may fail to load.`;
    const recommendation = `Consider using a smaller model like "Phi-3.5 Mini" (requires 6-8GB RAM) instead.`;
    return {
      isCompatible: false,
      warning,
      recommendation
    };
  }
  if (requiredRAM > totalRAM * 0.8) {
    const warning = `This model requires ${modelConfig.ram} RAM. Your system has ${totalRAM.toFixed(1)}GB total RAM. The model may struggle or fail to load if other applications are using memory.`;
    const recommendation = `Ensure you have at least ${requiredRAM}GB free RAM before loading this model.`;
    return {
      isCompatible: true,
      // Still compatible, but risky
      warning,
      recommendation
    };
  }
  return { isCompatible: true };
}
function getSystemInfoString() {
  const caps = getSystemCapabilities();
  return `System: ${caps.platform} ${caps.arch}, ${caps.totalRAMGB.toFixed(1)}GB total RAM`;
}

// src/utils/ProcessHealthMonitor.ts
var ProcessHealthMonitor = class {
  process = null;
  startTime = 0;
  /**
   * Set the process to monitor
   */
  setProcess(process2) {
    this.process = process2;
    this.startTime = process2 ? Date.now() : 0;
  }
  /**
   * Get current health status
   */
  getHealth() {
    if (!this.process || this.process.exitCode !== null) {
      return {
        isRunning: false,
        pid: null,
        memoryUsageMB: null,
        cpuUsagePercent: null,
        uptimeSeconds: null
      };
    }
    const uptimeSeconds = (Date.now() - this.startTime) / 1e3;
    return {
      isRunning: true,
      pid: this.process.pid || null,
      memoryUsageMB: this.getMemoryUsage(),
      cpuUsagePercent: null,
      // Would require external monitoring tools
      uptimeSeconds
    };
  }
  /**
   * Get memory usage of the process (platform-specific)
   */
  /**
   * Get memory usage of the process (platform-specific)
   */
  getMemoryUsage() {
    if (!this.process || !this.process.pid)
      return null;
    try {
      const output = require("child_process").execSync(`ps -o rss= -p ${this.process.pid}`, {
        encoding: "utf8",
        stdio: ["ignore", "pipe", "ignore"]
        // Ignore stdin/stderr to prevent hanging
      }).trim();
      if (output) {
        const rssKB = parseInt(output, 10);
        if (!isNaN(rssKB)) {
          return rssKB / 1024;
        }
      }
    } catch (error) {
    }
    return null;
  }
  /**
   * Check if process is still alive
   */
  isProcessAlive() {
    if (!this.process || !this.process.pid)
      return false;
    try {
      process.kill(this.process.pid, 0);
      return true;
    } catch (error) {
      return false;
    }
  }
  /**
   * Log current health status
   */
  logHealth() {
    const health = this.getHealth();
    Logger.debug("Process Health:", health);
  }
  /**
   * Get a human-readable status string
   */
  getStatusString() {
    const health = this.getHealth();
    if (!health.isRunning) {
      return "Not running";
    }
    const parts = [`PID: ${health.pid}`];
    if (health.uptimeSeconds !== null) {
      const minutes = Math.floor(health.uptimeSeconds / 60);
      const seconds = Math.floor(health.uptimeSeconds % 60);
      parts.push(`Uptime: ${minutes}m ${seconds}s`);
    }
    if (health.memoryUsageMB !== null) {
      parts.push(`Memory: ${health.memoryUsageMB.toFixed(1)} MB`);
    }
    return parts.join(", ");
  }
};

// src/services/LlamaService.ts
var LlamaService = class _LlamaService {
  static instance = null;
  static instanceLock = false;
  settings;
  serverProcess = null;
  isServerReady = false;
  idleTimeout = 15 * 60 * 1e3;
  // 15 minutes
  idleTimer = null;
  // @ts-ignore - lastUseTime is written to but not read (used for tracking)
  lastUseTime = 0;
  loadingState = "not-loaded";
  modelManager;
  pluginDir = null;
  processHealthMonitor;
  isCleaningUp = false;
  // Flag to prevent operations during cleanup
  // Event handlers for cleanup
  stdoutHandler = null;
  stderrHandler = null;
  closeHandler = null;
  errorHandler = null;
  healthCheckTimer = null;
  constructor(settings, pluginDir) {
    this.settings = settings;
    this.modelManager = new ModelManager(settings.localModel || "phi-3.5-mini");
    this.pluginDir = pluginDir || null;
    this.processHealthMonitor = new ProcessHealthMonitor();
    if (settings.keepModelLoaded) {
      this.idleTimeout = 0;
    }
  }
  /**
   * Calculate appropriate number of GPU layers based on model size
   * Larger models need fewer GPU layers to avoid memory issues
   * Returns a conservative estimate to prevent OOM errors
   */
  calculateGPULayers() {
    const modelKey = this.settings.localModel || "phi-3.5-mini";
    const modelConfig = MODELS[modelKey];
    if (!modelConfig) {
      return 35;
    }
    const modelSizeGB = modelConfig.sizeMB / 1024;
    if (modelSizeGB >= 40) {
      return 25;
    } else if (modelSizeGB >= 20) {
      return 40;
    } else if (modelSizeGB >= 10) {
      return 60;
    } else if (modelSizeGB >= 5) {
      return 75;
    } else {
      return 99;
    }
  }
  /**
   * Get recommended timeout based on model size, task type, and expected token count
   * Larger models need more time, especially for complex tasks like expansion
   * Timeout accounts for expected generation length (n_predict tokens)
   */
  getRecommendedTimeout(taskType = "completion", n_predict = 256) {
    const modelKey = this.settings.localModel || "phi-3.5-mini";
    const modelConfig = MODELS[modelKey];
    if (!modelConfig) {
      return this.settings.llmTimeout;
    }
    let tokensPerSecond;
    if (modelConfig.sizeMB < 5e3) {
      tokensPerSecond = 50;
    } else if (modelConfig.sizeMB < 1e4) {
      tokensPerSecond = 30;
    } else if (modelConfig.sizeMB < 2e4) {
      tokensPerSecond = 20;
    } else {
      tokensPerSecond = 10;
    }
    const generationTimeMs = n_predict / tokensPerSecond * 1e3;
    const overheadMs = 5e3;
    let baseTimeout = Math.round(generationTimeMs + overheadMs);
    let minTimeout;
    if (modelConfig.sizeMB < 5e3) {
      minTimeout = 15e3;
    } else if (modelConfig.sizeMB < 1e4) {
      minTimeout = 3e4;
    } else if (modelConfig.sizeMB < 2e4) {
      minTimeout = 45e3;
    } else {
      minTimeout = 9e4;
    }
    const taskMultiplier = taskType === "expansion" ? 1.5 : taskType === "completion" ? 1.2 : 1;
    const recommendedTimeout = Math.round(Math.max(baseTimeout, minTimeout) * taskMultiplier);
    return Math.max(this.settings.llmTimeout, recommendedTimeout);
  }
  /**
   * Get recommended model loading timeout based on model size
   * Large models like 70B can take 2-5 minutes to load
   */
  getModelLoadingTimeout() {
    const modelKey = this.settings.localModel || "phi-3.5-mini";
    const modelConfig = MODELS[modelKey];
    if (!modelConfig) {
      return 12e4;
    }
    const modelSizeGB = modelConfig.sizeMB / 1024;
    if (modelSizeGB >= 40) {
      return 3e5;
    } else if (modelSizeGB >= 20) {
      return 24e4;
    } else if (modelSizeGB >= 10) {
      return 18e4;
    } else {
      return 12e4;
    }
  }
  /**
   * Get or create singleton instance
   * Ensures only one LlamaService instance exists to prevent multiple server processes
   */
  static getInstance(settings, pluginDir) {
    if (!_LlamaService.instance) {
      if (_LlamaService.instanceLock) {
        throw new Error("LlamaService instance is being created");
      }
      _LlamaService.instanceLock = true;
      _LlamaService.instance = new _LlamaService(settings, pluginDir);
      _LlamaService.instanceLock = false;
      Logger.debug("LlamaService singleton instance created");
    }
    return _LlamaService.instance;
  }
  /**
   * Update settings for existing instance
   */
  updateSettings(settings) {
    this.settings = settings;
    this.modelManager = new ModelManager(settings.localModel || "phi-3.5-mini");
    if (settings.keepModelLoaded) {
      this.idleTimeout = 0;
    } else {
      this.idleTimeout = 15 * 60 * 1e3;
    }
  }
  /**
   * Destroy singleton instance (called on plugin unload)
   */
  static destroyInstance() {
    if (_LlamaService.instance) {
      Logger.debug("Destroying LlamaService singleton instance");
      _LlamaService.instance.cleanup();
      _LlamaService.instance = null;
    }
  }
  /**
   * Get the effective binary path, using bundled binary if available
   */
  getEffectiveBinaryPath() {
    if (this.settings.llamaBinaryPath) {
      return this.settings.llamaBinaryPath;
    }
    if (this.pluginDir) {
      const platformKey = `${os3.platform()}-${os3.arch()}`;
      const binaryName = os3.platform() === "win32" ? "llama-server.exe" : "llama-server";
      const bundledBinaryPath = path2.join(this.pluginDir, "binaries", platformKey, binaryName);
      try {
        if (fs2.existsSync(bundledBinaryPath)) {
          try {
            fs2.accessSync(bundledBinaryPath, fs2.constants.X_OK);
            Logger.debug("Using bundled binary:", bundledBinaryPath);
            return bundledBinaryPath;
          } catch {
            try {
              fs2.chmodSync(bundledBinaryPath, 493);
              Logger.debug("Using bundled binary (made executable):", bundledBinaryPath);
              return bundledBinaryPath;
            } catch (error) {
              Logger.warn("Bundled binary exists but cannot be made executable:", bundledBinaryPath, error);
              return bundledBinaryPath;
            }
          }
        } else {
          Logger.warn("Bundled binary not found at:", bundledBinaryPath);
          Logger.warn("Expected platform:", platformKey, "binary:", binaryName);
        }
      } catch (error) {
        console.error(`[LlamaService] Error checking bundled binary: ${error}`);
      }
    }
    const binaryNames = ["llama-server", "server"];
    for (const binName of binaryNames) {
      try {
        const whichResult = (0, import_child_process.execSync)(`which ${binName}`, { encoding: "utf8", stdio: "pipe" }).trim();
        if (whichResult && fs2.existsSync(whichResult)) {
          try {
            fs2.accessSync(whichResult, fs2.constants.X_OK);
            Logger.warn("Using fallback binary from PATH:", whichResult, "(bundled binary not found)");
            return whichResult;
          } catch {
          }
        }
      } catch {
      }
    }
    return null;
  }
  /**
   * Get the effective model path, using default if not configured
   * Tries to match the configured model, with smart fallback if exact filename doesn't match
   */
  async getEffectiveModelPath() {
    const modelKey = this.settings.localModel || "phi-3.5-mini";
    this.modelManager = new ModelManager(modelKey);
    const modelConfig = this.modelManager.getModelConfig();
    Logger.debug("Looking for model:", modelConfig.name, `(key: ${modelKey})`);
    Logger.debug("Expected filename:", modelConfig.fileName);
    if (this.settings.modelPath) {
      if (fs2.existsSync(this.settings.modelPath)) {
        if (this.settings.modelPath.endsWith(".gguf")) {
          Logger.debug("Using user-configured model path:", this.settings.modelPath);
          return this.settings.modelPath;
        }
        Logger.warn("Configured model path doesn't end with .gguf:", this.settings.modelPath);
      } else {
        Logger.warn("Configured model path does not exist:", this.settings.modelPath);
      }
    }
    const defaultPath = this.modelManager.getModelPath();
    try {
      if (fs2.existsSync(defaultPath) && defaultPath.endsWith(".gguf")) {
        Logger.debug("Using configured model at default location:", defaultPath);
        Logger.debug("Model:", modelConfig.name, `(${modelConfig.sizeMB}MB)`);
        return defaultPath;
      } else {
        Logger.debug(`Exact filename not found: ${modelConfig.fileName}`);
        Logger.debug("Searching for similar model files...");
        const modelDir = path2.dirname(defaultPath);
        if (fs2.existsSync(modelDir)) {
          const files = fs2.readdirSync(modelDir);
          const ggufFiles = files.filter((f) => f.endsWith(".gguf"));
          Logger.debug(`Found ${ggufFiles.length} GGUF files in directory:`, ggufFiles);
          const modelNameLower = modelConfig.name.toLowerCase();
          const modelKeyParts = modelKey.split("-");
          for (const file of ggufFiles) {
            const fileLower = file.toLowerCase();
            const matchesName = modelNameLower.split(" ").some(
              (part) => part.length > 2 && fileLower.includes(part)
            );
            const matchesKey = modelKeyParts.some(
              (part) => part.length > 2 && fileLower.includes(part)
            );
            if (matchesName || matchesKey) {
              const foundPath = path2.join(modelDir, file);
              Logger.debug(`Found matching model file: ${file}`);
              Logger.debug("Using:", foundPath);
              Logger.warn(`Using model file "${file}" instead of expected "${modelConfig.fileName}"`);
              Logger.warn("This may work, but the model might not match exactly. Consider renaming the file or downloading the correct model.");
              return foundPath;
            }
          }
          Logger.warn(`Configured model "${modelConfig.name}" not found at: ${defaultPath}`);
          Logger.warn(`Expected filename: ${modelConfig.fileName}`);
          Logger.warn(`Available GGUF files in directory: ${ggufFiles.join(", ")}`);
          Logger.warn("Please ensure the model filename matches, or download the model from Settings \u2192 AI Configuration \u2192 Local AI Model");
        } else {
          Logger.warn(`Model directory does not exist: ${modelDir}`);
        }
      }
    } catch (error) {
      Logger.error("Error checking model path:", error);
    }
    return null;
  }
  async startServer() {
    if (this.isCleaningUp) {
      Logger.debug("Cannot start server - cleanup in progress");
      throw new Error("Cannot start server during plugin cleanup");
    }
    if (this.serverProcess) {
      Logger.debug("Server already running");
      return;
    }
    const binaryPath = this.getEffectiveBinaryPath();
    const modelPath = await this.getEffectiveModelPath();
    if (!binaryPath) {
      throw new Error("Llama binary path not configured. Please set it in settings or ensure bundled binary is available.");
    }
    if (!modelPath) {
      throw new Error("Model path not configured. Please set it in settings or download a model.");
    }
    if (!fs2.existsSync(binaryPath)) {
      throw new Error(`Llama binary not found at: ${binaryPath}. Please check the path in settings.`);
    }
    if (!fs2.existsSync(modelPath)) {
      throw new Error(`Model file not found at: ${modelPath}. Please check the path in settings or download the model.`);
    }
    if (os3.platform() !== "win32") {
      try {
        fs2.accessSync(binaryPath, fs2.constants.X_OK);
      } catch {
        throw new Error(`Llama binary is not executable: ${binaryPath}. Please check file permissions.`);
      }
    }
    this.loadingState = "loading";
    Logger.debug("Starting Llama server...");
    Logger.debug("Binary:", binaryPath);
    Logger.debug("Model:", modelPath);
    Logger.debug("Port:", this.settings.llamaServerPort);
    const gpuLayers = this.calculateGPULayers();
    Logger.debug("Calculated GPU layers:", gpuLayers);
    if (this.loadingState === "loading") {
      const modelConfig = this.modelManager.getModelConfig();
      const modelSizeGB = modelConfig.sizeMB / 1024;
      const estimatedTime = modelSizeGB >= 40 ? "2-5 minutes" : modelSizeGB >= 20 ? "1-3 minutes" : "~30 seconds";
      new import_obsidian3.Notice(`Loading AI model... (${estimatedTime})`);
    }
    try {
      this.serverProcess = (0, import_child_process.spawn)(binaryPath, [
        "-m",
        modelPath,
        "--port",
        String(this.settings.llamaServerPort),
        "--ctx-size",
        "2048",
        "--n-gpu-layers",
        String(gpuLayers),
        // Adaptive based on model size
        "--parallel",
        String(this.settings.concurrency)
      ]);
      this.processHealthMonitor.setProcess(this.serverProcess);
      let serverStartError = null;
      let processExited = false;
      let exitCode = null;
      let errorMessage = "";
      const MAX_BUFFER_SIZE = 1e3;
      const stderrBuffer = [];
      const stdoutBuffer = [];
      const addToBuffer = (buffer, line) => {
        buffer.push(line);
        if (buffer.length > MAX_BUFFER_SIZE) {
          buffer.shift();
        }
      };
      Logger.debug("Starting server process with args:", [
        "-m",
        modelPath,
        "--port",
        String(this.settings.llamaServerPort),
        "--ctx-size",
        "2048",
        "--n-gpu-layers",
        String(gpuLayers),
        "--parallel",
        String(this.settings.concurrency)
      ]);
      this.stdoutHandler = (data) => {
        if (this.isCleaningUp) {
          return;
        }
        const output = data.toString();
        addToBuffer(stdoutBuffer, output);
        Logger.debug("[Llama Server stdout]", output.trim());
        if (output.includes("HTTP server listening") || output.includes("server is listening") || output.includes("listening on http")) {
          this.loadingState = "loading";
          Logger.debug("Server HTTP endpoint is listening (model may still be loading)");
        }
        if (output.includes("main: model loaded") || output.includes("model loaded")) {
          this.isServerReady = true;
          this.loadingState = "ready";
          Logger.debug("Server is ready! (Model fully loaded)");
          new import_obsidian3.Notice("Llama AI Server Started");
        }
      };
      this.stderrHandler = (data) => {
        if (this.isCleaningUp) {
          return;
        }
        const errorOutput = data.toString();
        addToBuffer(stderrBuffer, errorOutput);
        const outputLines = errorOutput.split("\n").filter((line) => line.trim());
        const isError = outputLines.some(
          (line) => (line.toLowerCase().includes("error") || line.toLowerCase().includes("failed") || line.toLowerCase().includes("fatal")) && !line.toLowerCase().includes("ggml_metal") && // Metal init messages are info
          !line.toLowerCase().includes("system info") && !line.toLowerCase().includes("llama_model_loader") && !line.toLowerCase().includes("print_info") && !line.toLowerCase().includes("load:") && !line.toLowerCase().includes("llama_context") && !line.toLowerCase().includes("main:")
        );
        for (const line of outputLines) {
          if (isError && (line.toLowerCase().includes("error") || line.toLowerCase().includes("failed") || line.toLowerCase().includes("fatal"))) {
            Logger.error("[Llama Server stderr]", line.trim());
          } else {
            Logger.debug("[Llama Server stderr]", line.trim());
          }
        }
        if (errorOutput.includes("HTTP server is listening") || errorOutput.includes("server is listening on http") || errorOutput.includes("main: server is listening")) {
          this.loadingState = "loading";
          Logger.debug("Server HTTP endpoint is listening (model may still be loading)");
        }
        if (errorOutput.includes("main: model loaded") || errorOutput.includes("model loaded")) {
          this.isServerReady = true;
          this.loadingState = "ready";
          Logger.debug("Server is ready! (Model fully loaded)");
          new import_obsidian3.Notice("Llama AI Server Started");
        }
        if (isError) {
          errorMessage = errorOutput.trim();
          const lowerOutput = errorOutput.toLowerCase();
          const isRAMError = lowerOutput.includes("failed to load model") || lowerOutput.includes("out of memory") || lowerOutput.includes("insufficient memory") || lowerOutput.includes("iogpucommandbuffercallbackerroroutofmemory") || lowerOutput.includes("command buffer") && lowerOutput.includes("failed") || lowerOutput.includes("ggml_metal_log_allocated_size") && lowerOutput.includes("warning") || lowerOutput.includes("recommended max working set size") || lowerOutput.includes("vram") || lowerOutput.includes("reduce") && lowerOutput.includes("gpu-layers");
          if (isRAMError) {
            const modelConfig = this.modelManager.getModelConfig();
            const compatibility = checkModelCompatibility(this.settings.localModel || "phi-3.5-mini");
            const systemInfo = getSystemInfoString();
            let enhancedError = `Model failed to load - likely insufficient RAM/VRAM.

`;
            enhancedError += `Model: ${modelConfig.name} (requires ${modelConfig.ram} RAM)
`;
            enhancedError += `${systemInfo}

`;
            if (!compatibility.isCompatible) {
              enhancedError += `This model requires more RAM than your system has. `;
            } else {
              enhancedError += `Your system may not have enough free RAM to load this model. `;
            }
            enhancedError += `Consider switching to a smaller model like "Phi-3.5 Mini" (requires 6-8GB RAM) in Settings \u2192 AI Configuration \u2192 Local AI Model.

`;
            enhancedError += `Original error: ${errorOutput.trim()}`;
            errorMessage = enhancedError;
            serverStartError = new Error(enhancedError);
          } else {
            serverStartError = new Error(`Server startup error: ${errorOutput.trim()}`);
          }
        }
      };
      this.serverProcess.stdout?.on("data", this.stdoutHandler);
      this.serverProcess.stderr?.on("data", this.stderrHandler);
      this.closeHandler = (code, signal) => {
        if (this.isCleaningUp) {
          Logger.debug("Server process closed during cleanup (expected)");
          return;
        }
        Logger.debug("Server process closed event fired", { code, signal });
        processExited = true;
        exitCode = code;
        const fullStderr = stderrBuffer.join("");
        const fullStdout = stdoutBuffer.join("");
        Logger.error("[LlamaService] Server process exited", {
          exitCode: code,
          signal,
          wasKilled: code === null,
          stderrLength: fullStderr.length,
          stdoutLength: fullStdout.length,
          binaryPath,
          modelPath
        });
        if (code === null || code !== 0 && code !== null) {
          if (fullStderr.length > 0) {
            Logger.error("[LlamaService] Full stderr output from crashed server:");
            Logger.error("--- BEGIN STDERR ---");
            const stderrLines = fullStderr.split("\n");
            for (const line of stderrLines) {
              if (line.trim()) {
                Logger.error(line.trim());
              }
            }
            Logger.error("--- END STDERR ---");
          }
          if (fullStdout.length > 0) {
            Logger.debug("[LlamaService] Full stdout output from crashed server:");
            Logger.debug("--- BEGIN STDOUT ---");
            const stdoutLines = fullStdout.split("\n");
            for (const line of stdoutLines) {
              if (line.trim()) {
                Logger.debug(line.trim());
              }
            }
            Logger.debug("--- END STDOUT ---");
          }
          if (!errorMessage && fullStderr.length > 0) {
            errorMessage = fullStderr.trim();
          }
        }
        this.serverProcess = null;
        this.isServerReady = false;
        this.loadingState = "not-loaded";
        this.lastUseTime = 0;
        if (code !== 0 && code !== null) {
          Logger.error(`[LlamaService] Server exited with error code ${code}`);
          if (!serverStartError) {
            serverStartError = new Error(`Server process exited with code ${code}`);
          }
        } else if (code === null) {
          Logger.error(`[LlamaService] Server process was killed (SIGKILL or similar)`);
          if (!serverStartError) {
            serverStartError = new Error("Server process was terminated (killed)");
          }
        }
      };
      this.serverProcess.on("close", this.closeHandler);
      this.errorHandler = (error) => {
        Logger.error("[LlamaService] Failed to spawn server process:", error);
        Logger.error("[LlamaService] Spawn error details:", {
          binaryPath,
          modelPath,
          errorName: error.name,
          errorMessage: error.message,
          errorStack: error.stack
        });
        serverStartError = error;
        this.serverProcess = null;
        this.loadingState = "not-loaded";
        new import_obsidian3.Notice("Failed to start Llama AI Server - check binary path");
      };
      this.serverProcess.on("error", this.errorHandler);
      await new Promise((resolve4) => setTimeout(resolve4, 2e3));
      if (processExited) {
        this.serverProcess = null;
        this.loadingState = "not-loaded";
        let errorMsg;
        if (exitCode === null) {
          const errorBinaryPath = binaryPath || "not configured";
          const errorModelPath = modelPath || "not configured";
          if (errorMessage && (errorMessage.includes("insufficient RAM") || errorMessage.includes("requires more RAM"))) {
            errorMsg = errorMessage;
          } else {
            const modelConfig = this.modelManager.getModelConfig();
            const compatibility = checkModelCompatibility(this.settings.localModel || "phi-3.5-mini");
            const systemInfo = getSystemInfoString();
            const errorMsgLower = errorMessage.toLowerCase();
            if (!compatibility.isCompatible || errorMsgLower.includes("failed to load model")) {
              errorMsg = `Model failed to load - likely insufficient RAM/VRAM.

Model: ${modelConfig.name} (requires ${modelConfig.ram} RAM)
${systemInfo}

This model requires more RAM than your system has or there isn't enough free RAM. Consider switching to a smaller model like "Phi-3.5 Mini" (requires 6-8GB RAM) in Settings \u2192 AI Configuration \u2192 Local AI Model.

Check the console for more details. Binary: ${errorBinaryPath}, Model: ${errorModelPath}`;
            } else {
              errorMsg = errorMessage || `Server process was terminated during startup. This may indicate:
  \u2022 Binary or model file is corrupted
  \u2022 Insufficient system resources (memory/disk)
  \u2022 Permission issues
  \u2022 Binary architecture mismatch
Check the console for more details. Binary: ${errorBinaryPath}, Model: ${errorModelPath}`;
            }
          }
        } else {
          errorMsg = errorMessage || `Server process exited during startup with code ${exitCode}`;
        }
        throw new Error(errorMsg);
      }
      if (serverStartError) {
        this.serverProcess = null;
        this.loadingState = "not-loaded";
        const errorMsg = errorMessage || "Server failed to start";
        throw new Error(errorMsg);
      }
      if (!this.serverProcess) {
        throw new Error("Server process failed to start");
      }
      this.startHealthCheck();
    } catch (error) {
      Logger.error("[LlamaService] Failed to start Llama server:", error);
      Logger.error("[LlamaService] Startup error details:", {
        binaryPath,
        modelPath,
        errorName: error instanceof Error ? error.name : "Unknown",
        errorMessage: error instanceof Error ? error.message : String(error),
        errorStack: error instanceof Error ? error.stack : void 0
      });
      this.loadingState = "not-loaded";
      this.serverProcess = null;
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("insufficient RAM") || errorMessage.includes("requires more RAM") || errorMessage.includes("failed to load model")) {
        new import_obsidian3.Notice("Model too large for system RAM. Consider switching to a smaller model in Settings.", 1e4);
      } else {
        new import_obsidian3.Notice("Failed to start Llama AI Server");
      }
      throw error;
    }
  }
  stopServer() {
    if (this.serverProcess) {
      const wasLoading = this.loadingState === "loading";
      Logger.debug("Stopping Llama server...", wasLoading ? "(model was loading)" : "");
      this.clearIdleTimer();
      this.stopHealthCheck();
      try {
        if (this.stdoutHandler && this.serverProcess.stdout) {
          this.serverProcess.stdout.removeListener("data", this.stdoutHandler);
        }
      } catch (error) {
        Logger.debug("Error removing stdout handler:", error);
      }
      try {
        if (this.stderrHandler && this.serverProcess.stderr) {
          this.serverProcess.stderr.removeListener("data", this.stderrHandler);
        }
      } catch (error) {
        Logger.debug("Error removing stderr handler:", error);
      }
      try {
        if (this.closeHandler) {
          this.serverProcess.removeListener("close", this.closeHandler);
        }
      } catch (error) {
        Logger.debug("Error removing close handler:", error);
      }
      try {
        if (this.errorHandler) {
          this.serverProcess.removeListener("error", this.errorHandler);
        }
      } catch (error) {
        Logger.debug("Error removing error handler:", error);
      }
      this.stdoutHandler = null;
      this.stderrHandler = null;
      this.closeHandler = null;
      this.errorHandler = null;
      try {
        if (this.serverProcess.killed === false) {
          this.serverProcess.kill("SIGTERM");
          setTimeout(() => {
            if (this.serverProcess && !this.serverProcess.killed) {
              Logger.debug("Force killing server process...");
              try {
                this.serverProcess.kill("SIGKILL");
              } catch (error) {
                Logger.debug("Error force killing process:", error);
              }
            }
          }, 2e3);
        }
      } catch (error) {
        Logger.debug("Error killing server process:", error);
        try {
          if (this.serverProcess && !this.serverProcess.killed) {
            this.serverProcess.kill("SIGKILL");
          }
        } catch (killError) {
          Logger.debug("Error force killing process:", killError);
        }
      }
      this.serverProcess = null;
      this.processHealthMonitor.setProcess(null);
      this.isServerReady = false;
      this.loadingState = "not-loaded";
      this.lastUseTime = 0;
      if (wasLoading) {
        Logger.debug("Server stopped while model was loading (plugin unload during startup)");
      }
    }
  }
  /**
   * Comprehensive cleanup - called on plugin unload
   * Ensures all resources are properly released
   * Handles cleanup gracefully even if model is still loading
   */
  cleanup() {
    Logger.debug("LlamaService cleanup started");
    this.isCleaningUp = true;
    this.clearIdleTimer();
    if (this.serverProcess) {
      const wasLoading = this.loadingState === "loading";
      if (wasLoading) {
        Logger.debug("Plugin unload during model loading - stopping server gracefully...");
      }
      this.stopServer();
    }
    try {
      if (this.modelManager?.isDownloadInProgress()) {
        Logger.debug("Canceling ongoing download...");
        this.modelManager.cancelDownload();
      }
    } catch (error) {
      Logger.debug("Error canceling download during cleanup:", error);
    }
    this.isServerReady = false;
    this.loadingState = "not-loaded";
    this.lastUseTime = 0;
    Logger.debug("LlamaService cleanup completed");
  }
  /**
   * Get process health information
   */
  getProcessHealth() {
    return this.processHealthMonitor.getHealth();
  }
  unloadModel() {
    if (this.serverProcess && !this.settings.keepModelLoaded) {
      Logger.debug("Unloading model due to idle timeout");
      this.stopServer();
    }
  }
  resetIdleTimer() {
    if (this.settings.keepModelLoaded) {
      return;
    }
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
    }
    this.lastUseTime = Date.now();
    this.loadingState = "ready";
    this.idleTimer = setTimeout(() => {
      this.unloadModel();
    }, this.idleTimeout);
  }
  clearIdleTimer() {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
      this.idleTimer = null;
    }
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("Llama provider is not enabled");
    }
    const isReady = await this.ensureReady();
    if (!isReady) {
      const binaryPath = this.getEffectiveBinaryPath();
      const modelPath = await this.getEffectiveModelPath();
      let errorMsg = "Llama binary or model path not found. ";
      if (!binaryPath && !modelPath) {
        errorMsg += "Please configure paths in settings or install llama-server and download the model.";
      } else if (!binaryPath) {
        errorMsg += "Please configure llama binary path in settings or install llama-server.\n";
        errorMsg += "Installation options:\n";
        errorMsg += "  \u2022 Homebrew: brew install llama.cpp\n";
        errorMsg += "  \u2022 Build from source: https://github.com/ggerganov/llama.cpp\n";
        errorMsg += "  \u2022 Or use Ollama via the Custom provider option in settings";
      } else {
        errorMsg += "Please configure model path in settings or download the model.";
      }
      throw new Error(errorMsg);
    }
    this.resetIdleTimer();
    const prompt = this.constructPrompt(text);
    const maxRetries = 2;
    let lastError = null;
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          const isServerRunning = this.serverProcess !== null && this.serverProcess.exitCode === null;
          if (!isServerRunning || this.serverProcess === null) {
            Logger.warn("Server process not running, attempting restart...");
            this.isServerReady = false;
            this.serverProcess = null;
            await this.ensureReady();
            await new Promise((resolve4) => setTimeout(resolve4, 1e3));
          } else if (!this.isServerReady) {
            Logger.warn("Server process exists but not ready, waiting...");
            let waitAttempts = 0;
            while (!this.isServerReady && waitAttempts < 20) {
              await new Promise((resolve4) => setTimeout(resolve4, 100));
              waitAttempts++;
            }
          }
        }
        const timeout = this.getRecommendedTimeout("classification", 128);
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new APITimeoutError(`API request timed out after ${timeout}ms`)), timeout);
        });
        let response;
        try {
          response = await Promise.race([
            (0, import_obsidian3.requestUrl)({
              url: `${this.settings.llamaServerUrl}/completion`,
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                prompt,
                n_predict: 128,
                temperature: 0.1,
                stop: ["}"]
                // Stop generation after JSON object closes
              })
            }),
            timeoutPromise
          ]);
        } catch (requestError) {
          if (requestError instanceof APITimeoutError) {
            throw requestError;
          }
          const errorMsg = requestError instanceof Error ? requestError.message : String(requestError);
          if (errorMsg.includes("ECONNREFUSED") || errorMsg.includes("network") || errorMsg.includes("connection")) {
            throw new NetworkError(`Connection failed: ${errorMsg}`);
          }
          throw new NetworkError(`Request failed: ${errorMsg}`);
        }
        if (response.status < 200 || response.status >= 300) {
          if (response.status === 503) {
            const isServerRunning = this.serverProcess !== null && this.serverProcess.exitCode === null;
            if (!isServerRunning || this.serverProcess === null) {
              Logger.warn("Server returned 503 and process is not running, will restart and retry");
              this.isServerReady = false;
              this.serverProcess = null;
              if (attempt < maxRetries) {
                await new Promise((resolve4) => setTimeout(resolve4, 500));
                continue;
              }
            } else {
              Logger.warn(`Server returned 503 (attempt ${attempt + 1}/${maxRetries + 1})`);
              if (attempt < maxRetries) {
                await new Promise((resolve4) => setTimeout(resolve4, 1e3));
                continue;
              }
            }
            const modelConfig = this.modelManager.getModelConfig();
            const compatibility = checkModelCompatibility(this.settings.localModel || "phi-3.5-mini");
            const systemInfo = getSystemInfoString();
            let errorMsg = `Model failed to load (503 Service Unavailable after ${maxRetries + 1} attempts).

`;
            errorMsg += `Model: ${modelConfig.name} (requires ${modelConfig.ram} RAM)
`;
            errorMsg += `${systemInfo}

`;
            if (!compatibility.isCompatible) {
              errorMsg += `This model requires more RAM than your system has. `;
            } else {
              errorMsg += `Your system may not have enough free RAM to load this model. `;
            }
            errorMsg += `Consider switching to a smaller model like "Phi-3.5 Mini" (requires 6-8GB RAM) in Settings \u2192 AI Configuration \u2192 Local AI Model.`;
            throw new NetworkError(errorMsg);
          }
          throw new NetworkError(`Llama.cpp server error: ${response.status}`);
        }
        const data = typeof response.json === "function" ? await response.json() : response.json;
        if (!data || typeof data !== "object") {
          throw new ClassificationError("Invalid response format from server");
        }
        return this.parseResponse(data.content);
      } catch (error) {
        if (error instanceof Error) {
          if (error instanceof APITimeoutError || error.message.includes("timed out")) {
            throw error;
          }
          if (error instanceof NetworkError) {
            lastError = error;
            if (attempt < maxRetries && error.message.includes("503")) {
              Logger.warn(`Network error on attempt ${attempt + 1}, will retry...`);
              continue;
            }
            throw error;
          }
          lastError = error;
          if (attempt < maxRetries && (error.message.includes("ECONNREFUSED") || error.message.includes("network") || error.message.includes("connection") || error.message.includes("failed to fetch"))) {
            Logger.warn(`Connection error on attempt ${attempt + 1}, will retry...`);
            await new Promise((resolve4) => setTimeout(resolve4, 1e3));
            continue;
          }
          throw new ClassificationError("Failed to classify idea", error);
        }
        lastError = new Error("Unknown error occurred");
      }
    }
    throw lastError || new ClassificationError("Failed to classify idea after retries");
  }
  isAvailable() {
    return this.settings.llmProvider === "llama";
  }
  /**
   * Get the current loading state
   */
  getLoadingState() {
    return this.loadingState;
  }
  /**
   * Check if the server is ready
   */
  getIsServerReady() {
    return this.isServerReady;
  }
  /**
   * Check if server process exists
   */
  hasServerProcess() {
    return this.serverProcess !== null;
  }
  /**
   * Ensure the LLM service is ready - start server if not already running
   * @returns true if ready, false if not configured (but available)
   */
  async ensureReady() {
    if (!this.isAvailable()) {
      return false;
    }
    const binaryPath = this.getEffectiveBinaryPath();
    const modelPath = await this.getEffectiveModelPath();
    if (!binaryPath || !modelPath) {
      if (!binaryPath && !modelPath) {
        Logger.debug("Binary and model paths not found (checked defaults)");
      } else if (!binaryPath) {
        Logger.debug("Binary path not found (checked common locations)");
        Logger.debug("To install llama-server on macOS:");
        Logger.debug("  1. Install via Homebrew: brew install llama.cpp");
        Logger.debug("  2. Or build from source: https://github.com/ggerganov/llama.cpp");
        Logger.debug("  3. Or configure the binary path manually in settings");
        Logger.debug("  4. Alternatively, use Ollama via the Custom provider option");
      } else {
        Logger.debug("Model path not found (checked default location)");
      }
      return false;
    }
    if (this.serverProcess && this.isServerReady) {
      return true;
    }
    if (this.serverProcess && !this.isServerReady) {
      Logger.debug("Server process exists but not ready, waiting for model to load...");
      const timeoutMs = this.getModelLoadingTimeout();
      const maxAttempts = timeoutMs / 100;
      let attempts = 0;
      while (!this.isServerReady && attempts < maxAttempts) {
        await new Promise((resolve4) => setTimeout(resolve4, 100));
        attempts++;
        if (attempts % 100 === 0) {
          Logger.debug(`Still waiting for model to load... (${attempts / 10}s)`);
        }
      }
      if (this.isServerReady) {
        return true;
      }
      Logger.warn("Server process exists but never became ready, restarting...");
      this.stopServer();
    }
    if (!this.serverProcess) {
      Logger.debug("Ensuring server is ready...");
      await this.startServer();
      const timeoutMs = this.getModelLoadingTimeout();
      const maxAttempts = timeoutMs / 100;
      let attempts = 0;
      while (!this.isServerReady && attempts < maxAttempts) {
        await new Promise((resolve4) => setTimeout(resolve4, 100));
        attempts++;
        if (attempts % 100 === 0) {
          Logger.debug(`Waiting for model to load... (${attempts / 10}s)`);
        }
      }
      if (!this.isServerReady) {
        const timeoutMinutes = Math.round(timeoutMs / 6e4);
        throw new Error(`Server started but model did not load in time (${timeoutMinutes} minutes). The model may be too large for your system, or there may be insufficient memory.`);
      }
    }
    return true;
  }
  /**
   * Generic completion method for non-classification tasks
   * @param prompt - The prompt to send to the LLM
   * @param options - Optional configuration (temperature, max tokens, stop tokens)
   * @returns The raw completion text
   */
  async complete(prompt, options) {
    if (!this.isAvailable()) {
      throw new Error("Llama provider is not enabled");
    }
    const isReady = await this.ensureReady();
    if (!isReady) {
      const binaryPath = this.getEffectiveBinaryPath();
      const modelPath = await this.getEffectiveModelPath();
      let errorMsg = "Llama binary or model path not found. ";
      if (!binaryPath && !modelPath) {
        errorMsg += "Please configure paths in settings or install llama-server and download the model.";
      } else if (!binaryPath) {
        errorMsg += "Please configure llama binary path in settings or install llama-server.\n";
        errorMsg += "Installation options:\n";
        errorMsg += "  \u2022 Homebrew: brew install llama.cpp\n";
        errorMsg += "  \u2022 Build from source: https://github.com/ggerganov/llama.cpp\n";
        errorMsg += "  \u2022 Or use Ollama via the Custom provider option in settings";
      } else {
        errorMsg += "Please configure model path in settings or download the model.";
      }
      throw new Error(errorMsg);
    }
    this.resetIdleTimer();
    const maxRetries = 2;
    let lastError = null;
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          const isServerRunning = this.serverProcess !== null && this.serverProcess.exitCode === null;
          if (!isServerRunning || this.serverProcess === null) {
            Logger.warn("Server process not running, attempting restart...");
            this.isServerReady = false;
            this.serverProcess = null;
            await this.ensureReady();
            await new Promise((resolve4) => setTimeout(resolve4, 1e3));
          } else if (!this.isServerReady) {
            Logger.warn("Server process exists but not ready, waiting...");
            let waitAttempts = 0;
            while (!this.isServerReady && waitAttempts < 20) {
              await new Promise((resolve4) => setTimeout(resolve4, 100));
              waitAttempts++;
            }
          }
        }
        const n_predict = options?.n_predict || 256;
        const isExpansion = n_predict > 1e3;
        const timeout = this.getRecommendedTimeout(isExpansion ? "expansion" : "completion", n_predict);
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new APITimeoutError(`API request timed out after ${timeout}ms`)), timeout);
        });
        let response;
        try {
          response = await Promise.race([
            (0, import_obsidian3.requestUrl)({
              url: `${this.settings.llamaServerUrl}/completion`,
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                prompt,
                n_predict: options?.n_predict || 256,
                temperature: options?.temperature ?? 0.7,
                stop: options?.stop || ["}"]
              })
            }),
            timeoutPromise
          ]);
        } catch (requestError) {
          if (requestError instanceof APITimeoutError) {
            throw requestError;
          }
          const errorMsg = requestError instanceof Error ? requestError.message : String(requestError);
          if (errorMsg.includes("ECONNREFUSED") || errorMsg.includes("network") || errorMsg.includes("connection")) {
            throw new NetworkError(`Connection failed: ${errorMsg}`);
          }
          throw new NetworkError(`Request failed: ${errorMsg}`);
        }
        if (response.status < 200 || response.status >= 300) {
          if (response.status === 503) {
            const isServerRunning = this.serverProcess !== null && this.serverProcess.exitCode === null;
            if (!isServerRunning || this.serverProcess === null) {
              Logger.warn("Server returned 503 and process is not running, will restart and retry");
              this.isServerReady = false;
              this.serverProcess = null;
              if (attempt < maxRetries) {
                await new Promise((resolve4) => setTimeout(resolve4, 500));
                continue;
              }
            } else {
              Logger.warn(`Server returned 503 (attempt ${attempt + 1}/${maxRetries + 1})`);
              if (attempt < maxRetries) {
                await new Promise((resolve4) => setTimeout(resolve4, 1e3));
                continue;
              }
            }
            const modelConfig = this.modelManager.getModelConfig();
            const compatibility = checkModelCompatibility(this.settings.localModel || "phi-3.5-mini");
            const systemInfo = getSystemInfoString();
            let errorMsg = `Model failed to load (503 Service Unavailable after ${maxRetries + 1} attempts).

`;
            errorMsg += `Model: ${modelConfig.name} (requires ${modelConfig.ram} RAM)
`;
            errorMsg += `${systemInfo}

`;
            if (!compatibility.isCompatible) {
              errorMsg += `This model requires more RAM than your system has. `;
            } else {
              errorMsg += `Your system may not have enough free RAM to load this model. `;
            }
            errorMsg += `Consider switching to a smaller model like "Phi-3.5 Mini" (requires 6-8GB RAM) in Settings \u2192 AI Configuration \u2192 Local AI Model.`;
            throw new NetworkError(errorMsg);
          }
          throw new NetworkError(`Llama.cpp server error: ${response.status}`);
        }
        const data = typeof response.json === "function" ? await response.json() : response.json;
        if (!data || typeof data !== "object") {
          throw new ClassificationError("Invalid response format from server");
        }
        return data.content || "";
      } catch (error) {
        if (error instanceof Error) {
          if (error instanceof APITimeoutError || error.message.includes("timed out")) {
            throw error;
          }
          if (error instanceof NetworkError) {
            lastError = error;
            if (attempt < maxRetries && error.message.includes("503")) {
              Logger.warn(`Network error on attempt ${attempt + 1}, will retry...`);
              continue;
            }
            throw error;
          }
          lastError = error;
          if (attempt < maxRetries && (error.message.includes("ECONNREFUSED") || error.message.includes("network") || error.message.includes("connection") || error.message.includes("failed to fetch"))) {
            Logger.warn(`Connection error on attempt ${attempt + 1}, will retry...`);
            await new Promise((resolve4) => setTimeout(resolve4, 1e3));
            continue;
          }
          throw new ClassificationError("Failed to complete request", error);
        }
        lastError = new Error("Unknown error occurred");
      }
    }
    throw lastError || new ClassificationError("Failed to complete request after retries");
  }
  constructPrompt(text) {
    return `Classify ideas into ONE category and generate 3-5 relevant tags.

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Format: JSON only, no markdown

Examples:

Input: "A game about baristas stuck in a time loop where you optimize workflow"
Output: {"category": "game", "tags": ["time-loop", "service-industry", "roguelike", "optimization"]}

Input: "SaaS tool for managing restaurant inventory with AI predictions"
Output: {"category": "saas", "tags": ["restaurant", "inventory", "ai", "b2b", "operations"]}

Input: "Story about a sentient spaceship that falls in love with an asteroid"
Output: {"category": "story", "tags": ["sci-fi", "romance", "ai", "space"]}

Input: "Hardware device that translates dog barks into English"
Output: {"category": "hardware", "tags": ["pets", "translation", "iot", "consumer"]}

Input: "${text}"
Output: {`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: 0.8
        // Placeholder confidence
      };
    } catch (error) {
      Logger.warn("Failed to parse Llama response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
  calculateMemoryLimit() {
    const modelConfig = this.modelManager.getModelConfig();
    return modelConfig.sizeMB + 4096;
  }
  startHealthCheck() {
    if (this.healthCheckTimer)
      return;
    this.healthCheckTimer = setInterval(() => {
      const health = this.processHealthMonitor.getHealth();
      if (health.memoryUsageMB) {
        const limit2 = this.calculateMemoryLimit();
        if (health.memoryUsageMB > limit2) {
          Logger.warn(`Llama server memory usage (${health.memoryUsageMB.toFixed(0)}MB) exceeded limit (${limit2.toFixed(0)}MB). Restarting...`);
          new import_obsidian3.Notice("Restarting AI Server (Memory Limit Exceeded)");
          this.restartServer();
        }
      }
    }, 3e4);
  }
  stopHealthCheck() {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = null;
    }
  }
  async restartServer() {
    Logger.info("Restarting server...");
    this.stopServer();
    await new Promise((resolve4) => setTimeout(resolve4, 2e3));
    try {
      await this.startServer();
    } catch (error) {
      Logger.error("Failed to restart server:", error);
      new import_obsidian3.Notice("Failed to auto-restart AI Server");
    }
  }
};

// src/services/prompts.ts
var PROMPTS = {
  /**
   * Generate mutation prompt for idea variations
   */
  mutations: (params) => {
    const count = params.count || 8;
    const category = params.category || "general";
    const tags = params.tags && params.tags.length > 0 ? params.tags.join(", ") : "none";
    const focus = params.focus ? `

Focus: ${params.focus}` : "";
    return `Generate ${count} creative, distinct variations of this idea.

Original Idea:
${params.ideaText}

Category: ${category}
Tags: ${tags}${focus}

CRITICAL REQUIREMENTS:
- Each variation should be meaningfully different, not just minor tweaks
- Explore diverse angles: different audiences, use cases, business models, technologies, or problem-solving approaches
- Variations should be interesting and potentially viable on their own
- Avoid variations that are too similar to each other

For each variation, provide:
- title: Brief, descriptive name (2-5 words) that captures the variation's unique angle
- description: Clear explanation of how this variation differs from the original (1-2 sentences). Be specific about what changed and why it matters.
- differences: 2-3 concrete, specific differences that make this variation distinct. Focus on meaningful changes, not trivial details.

Variation strategies to consider:
- Different target audience (e.g., B2B vs B2C, professionals vs consumers)
- Different problem focus (e.g., different pain point, different use case)
- Different business model (e.g., subscription vs one-time, freemium vs premium)
- Different technology approach (e.g., mobile-first vs web-first, AI-powered vs manual)
- Different scope (e.g., enterprise vs personal, comprehensive vs focused)
- Different angle (e.g., productivity vs entertainment, serious vs playful)

IMPORTANT: 
- Respond with ONLY a valid JSON array
- Do not include any explanatory text, markdown formatting, or code blocks
- Do not include prefixes like "Example response:" or "Here is:"
- Start your response with [ and end with ]
- Ensure the JSON is complete and properly closed
- Generate all ${count} variations
- Make each variation distinct and interesting

Output format (JSON array):
[
  {
    "title": "Variation Name",
    "description": "How this differs from original...",
    "differences": ["Difference 1", "Difference 2", "Difference 3"]
  }
]`;
  },
  /**
   * Generate expansion prompt for idea development
   */
  expansion: (params) => {
    const category = params.category || "general";
    const tags = params.tags && params.tags.length > 0 ? params.tags.join(", ") : "none";
    const detailLevel = params.detailLevel || "detailed";
    return `Expand this idea into a comprehensive, structured description.

Original Idea:
${params.ideaText}

Category: ${category}
Tags: ${tags}

CRITICAL REQUIREMENTS:
- Preserve the original meaning and core concept completely
- Add meaningful detail that enhances understanding without changing the fundamental idea
- Use clear markdown formatting with proper headings
- Detail level: ${detailLevel} (brief = concise, detailed = thorough, comprehensive = extensive)

Structure your expansion as follows:

## Overview
A clear, concise summary (2-4 sentences) that captures:
- What this idea is
- The core problem it solves or value it provides
- Why it matters or what makes it interesting

## Key Features / Mechanics
Main features, mechanics, or core components. For ${detailLevel === "comprehensive" ? "each feature, explain how it works and why it matters" : detailLevel === "detailed" ? "each feature, provide a brief explanation" : "each feature, list it concisely"}:
- What are the essential components or features?
- How do they work together?
- What makes them unique or effective?

## Goals / Objectives
What this idea aims to achieve:
- Primary goals (what problem does it solve?)
- Secondary benefits (what additional value does it provide?)
- Success criteria (how would you know it's working?)

## Potential Challenges
Realistic obstacles or challenges to consider:
- Technical challenges
- Market or adoption challenges
- Resource or implementation challenges
- Competitive or strategic challenges

## Next Steps
Concrete, actionable initial steps to explore or develop:
- Research or validation steps
- Prototyping or development steps
- Market or user research steps
- Partnership or resource acquisition steps

Response:`;
  },
  /**
   * Generate reorganization prompt for idea structuring
   */
  reorganization: (params) => {
    const category = params.category || "general";
    const tags = params.tags && params.tags.length > 0 ? params.tags.join(", ") : "none";
    const targetStructure = params.targetStructure && params.targetStructure.length > 0 ? params.targetStructure.join("\n- ") : "Logical sections with clear headings";
    const preserveSections = params.preserveSections && params.preserveSections.length > 0 ? params.preserveSections.join("\n- ") : "None";
    return `Reorganize this idea into a clear, well-structured format.

Original Idea:
${params.ideaText}

Category: ${category}
Tags: ${tags}

CRITICAL REQUIREMENTS:
- Preserve ALL information - do not remove or lose any content
- Maintain the original meaning and intent completely
- Organize content logically so it flows naturally
- Remove only true redundancy (duplicate information), keep all unique points
- Use proper markdown formatting (headings, lists, emphasis, code blocks if needed)

Reorganization Guidelines:
1. Group related information together
2. Create clear hierarchical structure with appropriate heading levels
3. Use lists for multiple related items
4. Place most important information first
5. Ensure smooth flow from section to section
6. Use consistent formatting throughout

Target structure:
- ${targetStructure}

Preserve exactly (if any):
- ${preserveSections}

Output: Reorganized content with clear markdown formatting. Ensure all original information is present, just better organized.`;
  },
  /**
   * Generate cluster analysis prompt for understanding cluster relationships
   */
  clusterAnalysis: (params) => {
    const ideaSummaries = params.clusterIdeas.map(
      (idea, i) => `${i + 1}. ${idea.title}
   Category: ${idea.category || "none"}
   Tags: ${idea.tags?.join(", ") || "none"}
   Text: ${idea.text.substring(0, 200)}...`
    ).join("\n\n");
    const otherClusterInfo = params.otherClusterIdeas ? `

Other Cluster:
${params.otherClusterIdeas.map(
      (idea, i) => `${i + 1}. ${idea.title} (${idea.category || "none"})`
    ).join("\n")}` : "";
    const similarityInfo = params.similarity !== void 0 ? `
Similarity: ${(params.similarity * 100).toFixed(1)}%` : "";
    return `Analyze this cluster of ideas to understand their relationships and potential.

Cluster Ideas:
${ideaSummaries}${otherClusterInfo}${similarityInfo}

CRITICAL REQUIREMENTS:
- Look for meaningful connections, not just surface-level similarities
- Identify both explicit and implicit relationships
- Consider how ideas could complement or enhance each other
- Think about practical applications and combinations

Analyze and identify:

1. Common Themes
   - What underlying concepts or topics connect these ideas?
   - What shared values, goals, or problems do they address?
   - Look for both obvious and subtle thematic connections

2. Common Patterns or Structures
   - Do these ideas share similar approaches, formats, or methodologies?
   - Are there recurring elements, features, or design patterns?
   - What structural similarities exist?

3. Relationship Explanation
   - Why do these ideas belong together in this cluster?
   - What makes them cohesive as a group?
   - What is the unifying thread that connects them?

4. Potential Synergies or Combinations
   - How could these ideas be combined to create something greater?
   - What new possibilities emerge when these ideas are considered together?
   - Are there complementary strengths that could be leveraged?
   - What would a merged or combined version look like?${params.otherClusterIdeas ? "\n\n5. Relationship to Other Cluster\n   - How does this cluster relate to the other cluster?\n   - What are the key differences or similarities?\n   - Could ideas from different clusters be combined?" : ""}

Output format (JSON only, no markdown, no code blocks):
{
  "commonThemes": ["Theme 1", "Theme 2", "Theme 3"],
  "commonPatterns": ["Pattern 1", "Pattern 2"],
  "relationshipExplanation": "Clear explanation of why these ideas belong together and what connects them...",
  "synergies": ["Specific synergy 1", "Specific synergy 2", "Specific synergy 3"],${params.otherClusterIdeas ? '\n  "relationshipToOtherCluster": "How this cluster relates to the other cluster...",' : ""}
  "relevance": 0.0-1.0
}

Response:`;
  }
};

// src/services/HybridLLM.ts
var HybridLLM = class {
  localLLM;
  cloudLLM;
  preferCloud;
  lastProvider = null;
  constructor(localLLM, cloudLLM, preferCloud) {
    this.localLLM = localLLM;
    this.cloudLLM = cloudLLM;
    this.preferCloud = preferCloud;
  }
  async classify(text) {
    if (this.preferCloud && this.cloudLLM?.isAvailable()) {
      try {
        const result2 = await this.cloudLLM.classify(text);
        this.lastProvider = "cloud";
        Logger.debug("Used cloud provider:", this.cloudLLM.name || "cloud");
        return result2;
      } catch (error) {
        Logger.warn("Cloud provider failed, falling back to local:", error);
      }
    }
    const result = await this.localLLM.classify(text);
    this.lastProvider = "local";
    Logger.debug("Used local provider");
    return result;
  }
  isAvailable() {
    return this.localLLM.isAvailable() || (this.cloudLLM?.isAvailable() ?? false);
  }
  /**
   * Ensure the LLM service is ready - delegates to the appropriate provider
   */
  async ensureReady() {
    if (this.preferCloud && this.cloudLLM?.isAvailable() && this.cloudLLM.ensureReady) {
      try {
        const ready = await this.cloudLLM.ensureReady();
        if (ready) {
          return true;
        }
      } catch (error) {
        Logger.warn("Cloud provider ensureReady failed, falling back to local:", error);
      }
    }
    if (this.localLLM.isAvailable() && this.localLLM.ensureReady) {
      return await this.localLLM.ensureReady();
    }
    return false;
  }
  /**
   * Get the last provider that was used for classification
   */
  getLastProvider() {
    return this.lastProvider;
  }
  /**
   * Get the underlying local LLM service (for status checking)
   */
  getLocalLLM() {
    return this.localLLM;
  }
  /**
   * Get the underlying cloud LLM service (for status checking)
   */
  getCloudLLM() {
    return this.cloudLLM;
  }
  /**
   * Update cloud LLM provider (for runtime switching)
   */
  setCloudLLM(cloudLLM) {
    this.cloudLLM = cloudLLM;
    this.lastProvider = null;
  }
  /**
   * Update preference for cloud vs local
   */
  setPreferCloud(preferCloud) {
    this.preferCloud = preferCloud;
  }
  /**
   * Generic completion method - delegates to available LLM
   */
  async complete(prompt, options) {
    if (this.preferCloud && this.cloudLLM?.isAvailable() && this.cloudLLM.complete) {
      try {
        const result = await this.cloudLLM.complete(prompt, options);
        this.lastProvider = "cloud";
        return result;
      } catch (error) {
        Logger.warn("Cloud provider failed, falling back to local:", error);
      }
    }
    if (this.localLLM.complete) {
      const result = await this.localLLM.complete(prompt, options);
      this.lastProvider = "local";
      return result;
    }
    throw new Error("No LLM service available with complete() method");
  }
  /**
   * Generate idea mutations
   */
  async generateMutations(text, options) {
    const prompt = PROMPTS.mutations({
      ideaText: text,
      category: options?.category,
      tags: options?.tags,
      count: options?.count,
      focus: options?.focus
    });
    const response = await this.complete(prompt, {
      temperature: 0.8,
      // Higher creativity for mutations
      n_predict: 4e3,
      // Increased to handle longer JSON responses
      stop: ["\n]", "]"]
      // Stop at end of JSON array (prefer newline before bracket for cleaner output)
    });
    if (!response || response.trim().length === 0) {
      throw new Error("LLM returned an empty response. The model may have stopped generating or encountered an error. Please try again.");
    }
    let parseError = null;
    try {
      const repaired = extractAndRepairJSON(response, true);
      const mutations = JSON.parse(repaired);
      if (!Array.isArray(mutations)) {
        throw new Error("Response is not an array");
      }
      const validMutations = mutations.filter((m) => m && typeof m === "object" && (m.text || m.title || m.description)).map((m) => ({
        title: m.title || m.text || "",
        description: m.description || "",
        differences: Array.isArray(m.differences) ? m.differences : []
      }));
      if (validMutations.length > 0) {
        return validMutations;
      }
      throw new Error("No valid mutations found in response");
    } catch (error2) {
      parseError = error2 instanceof Error ? error2 : new Error(String(error2));
      Logger.warn("Strategy 1 failed, trying alternative approaches:", parseError.message);
    }
    try {
      const arrayMatch = response.match(/\[[\s\S]*\]/);
      if (arrayMatch) {
        const mutations = JSON.parse(arrayMatch[0]);
        if (Array.isArray(mutations) && mutations.length > 0) {
          const validMutations = mutations.filter((m) => m && typeof m === "object" && (m.text || m.title || m.description)).map((m) => ({
            title: m.title || m.text || "",
            description: m.description || "",
            differences: Array.isArray(m.differences) ? m.differences : []
          }));
          if (validMutations.length > 0) {
            Logger.debug("Strategy 2 succeeded: extracted valid JSON array");
            return validMutations;
          }
        }
      }
    } catch (error2) {
      Logger.warn("Strategy 2 failed:", error2 instanceof Error ? error2.message : String(error2));
    }
    try {
      Logger.debug("Raw response (first 500 chars):", response.substring(0, 500));
      try {
        const mutationObjects = [];
        let i = 0;
        while (i < response.length) {
          if (response[i] === "{") {
            let braceCount = 0;
            let inString = false;
            let escapeNext = false;
            let start = i;
            let end = i;
            for (let j = i; j < response.length; j++) {
              const char = response[j];
              if (escapeNext) {
                escapeNext = false;
                continue;
              }
              if (char === "\\") {
                escapeNext = true;
                continue;
              }
              if (char === '"' && !escapeNext) {
                inString = !inString;
                continue;
              }
              if (inString) {
                continue;
              }
              if (char === "{") {
                braceCount++;
              } else if (char === "}") {
                braceCount--;
                if (braceCount === 0) {
                  end = j + 1;
                  break;
                }
              }
            }
            if (braceCount === 0 && end > start) {
              const objStr = response.substring(start, end);
              try {
                const repaired = extractAndRepairJSON(objStr, false);
                const obj = JSON.parse(repaired);
                if (obj && typeof obj === "object" && (obj.text || obj.title || obj.description)) {
                  mutationObjects.push({
                    title: obj.title || obj.text || "",
                    description: obj.description || "",
                    differences: Array.isArray(obj.differences) ? obj.differences : []
                  });
                }
              } catch (e) {
              }
              i = end;
            } else if (braceCount > 0 && end === start) {
              const objStr = response.substring(start);
              try {
                const repaired = extractAndRepairJSON(objStr, false);
                const obj = JSON.parse(repaired);
                if (obj && typeof obj === "object" && (obj.text || obj.title || obj.description)) {
                  mutationObjects.push({
                    title: obj.title || obj.text || "",
                    description: obj.description || "",
                    differences: Array.isArray(obj.differences) ? obj.differences : []
                  });
                }
              } catch (e) {
              }
              break;
            } else {
              i++;
            }
          } else {
            i++;
          }
        }
        if (mutationObjects.length > 0) {
          Logger.debug(`Extracted ${mutationObjects.length} mutations from malformed JSON`);
          return mutationObjects;
        }
      } catch (fallbackError) {
        Logger.warn("Strategy 3 (fallback extraction) also failed:", fallbackError);
      }
    } catch (error2) {
      Logger.warn("Strategy 3 failed:", error2 instanceof Error ? error2.message : String(error2));
    }
    try {
      const objectPattern = /\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g;
      const matches = response.match(objectPattern);
      if (matches && matches.length > 0) {
        const mutationObjects = [];
        for (const match of matches) {
          try {
            const repaired = extractAndRepairJSON(match, false);
            const obj = JSON.parse(repaired);
            if (obj && typeof obj === "object" && (obj.text || obj.title || obj.description)) {
              mutationObjects.push({
                title: obj.title || obj.text || "",
                description: obj.description || "",
                differences: Array.isArray(obj.differences) ? obj.differences : []
              });
            }
          } catch (e) {
          }
        }
        if (mutationObjects.length > 0) {
          Logger.debug(`Strategy 4 succeeded: extracted ${mutationObjects.length} mutations from individual objects`);
          return mutationObjects;
        }
      }
    } catch (error2) {
      Logger.warn("Strategy 4 failed:", error2 instanceof Error ? error2.message : String(error2));
    }
    console.error("All parsing strategies failed. Response length:", response.length);
    const responsePreview = response.substring(0, 1e3);
    console.error("Response preview (first 1000 chars):", responsePreview);
    try {
      const repaired = extractAndRepairJSON(response, true);
      console.error("Repaired JSON attempt (first 500 chars):", repaired.substring(0, 500));
    } catch (repairError) {
      console.error("Could not repair JSON:", repairError);
    }
    const errorMessage = response.length === 0 ? "LLM returned an empty response. The model may have stopped generating or encountered an error." : `Failed to parse mutations from LLM response: ${parseError?.message || "Unknown error"}. The response may be malformed or incomplete.`;
    const error = new Error(errorMessage);
    error.responseLength = response.length;
    error.responsePreview = responsePreview;
    throw error;
  }
  /**
   * Expand an idea
   */
  async expandIdea(text, options) {
    const prompt = PROMPTS.expansion({
      ideaText: text,
      category: options?.category,
      tags: options?.tags,
      detailLevel: options?.detailLevel
    });
    const expandedText = await this.complete(prompt, {
      temperature: 0.7,
      n_predict: 3e3
    });
    const structure = this.parseExpansionStructure(expandedText);
    return {
      expandedText,
      structure
    };
  }
  /**
   * Reorganize an idea
   */
  async reorganizeIdea(text, options) {
    const prompt = PROMPTS.reorganization({
      ideaText: text,
      category: options?.category,
      tags: options?.tags,
      preserveSections: options?.preserveSections,
      targetStructure: options?.targetStructure
    });
    const reorganizedText = await this.complete(prompt, {
      temperature: 0.5,
      // Lower temperature for more consistent reorganization
      n_predict: 4e3
    });
    const changes = this.analyzeReorganizationChanges(text, reorganizedText);
    return {
      reorganizedText,
      changes,
      originalLength: text.length,
      reorganizedLength: reorganizedText.length
    };
  }
  /**
   * Parse expansion structure from markdown text
   */
  parseExpansionStructure(text) {
    const structure = {};
    const overviewMatch = text.match(/## Overview\s*\n([\s\S]*?)(?=\n## |$)/);
    if (overviewMatch) {
      structure.overview = overviewMatch[1].trim();
    }
    const featuresMatch = text.match(/## (?:Key Features|Mechanics)\s*\n([\s\S]*?)(?=\n## |$)/);
    if (featuresMatch) {
      structure.features = featuresMatch[1].trim();
    }
    const goalsMatch = text.match(/## (?:Goals|Objectives)\s*\n([\s\S]*?)(?=\n## |$)/);
    if (goalsMatch) {
      structure.goals = goalsMatch[1].trim();
    }
    const challengesMatch = text.match(/## (?:Potential )?Challenges\s*\n([\s\S]*?)(?=\n## |$)/);
    if (challengesMatch) {
      structure.challenges = challengesMatch[1].trim();
    }
    const nextStepsMatch = text.match(/## Next Steps\s*\n([\s\S]*?)(?=\n## |$)/);
    if (nextStepsMatch) {
      structure.nextSteps = nextStepsMatch[1].trim();
    }
    return structure;
  }
  /**
   * Analyze reorganization changes (simplified version)
   */
  analyzeReorganizationChanges(original, reorganized) {
    const originalSections = this.extractSections(original);
    const reorganizedSections = this.extractSections(reorganized);
    const sectionsAdded = reorganizedSections.filter(
      (s) => !originalSections.includes(s)
    );
    const sectionsRemoved = originalSections.filter(
      (s) => !reorganizedSections.includes(s)
    );
    const sectionsReorganized = originalSections.filter(
      (s) => reorganizedSections.includes(s) && reorganizedSections.indexOf(s) !== originalSections.indexOf(s)
    );
    return {
      sectionsAdded,
      sectionsRemoved,
      sectionsReorganized
    };
  }
  /**
   * Extract section headers from markdown text
   */
  extractSections(text) {
    const sectionRegex = /^## (.+)$/gm;
    const sections = [];
    let match;
    while ((match = sectionRegex.exec(text)) !== null) {
      sections.push(match[1].trim());
    }
    return sections;
  }
  /**
   * Cleanup both local and cloud providers
   * Called on plugin unload
   */
  cleanup() {
    Logger.debug("HybridLLM cleanup started");
    if (this.cloudLLM) {
      this.cloudLLM.cleanup?.();
    }
    Logger.debug("HybridLLM cleanup completed");
  }
};

// src/utils/iconUtils.ts
var import_obsidian4 = require("obsidian");
var IDEATR_ICON_ID = "ideatr-icon-purple";
var IDEATR_ICON_GREEN = "ideatr-icon-green";
var IDEATR_ICON_YELLOW = "ideatr-icon-yellow";
var IDEATR_ICON_RED = "ideatr-icon-red";
function createPNGIconSVG(imageDataUri) {
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <image href="${imageDataUri}" width="24" height="24"/>
    </svg>`;
}
function getStatusIconId(status) {
  switch (status) {
    case "connected":
      return IDEATR_ICON_GREEN;
    case "loading":
      return IDEATR_ICON_YELLOW;
    case "not-connected":
    case "error":
      return IDEATR_ICON_RED;
    default:
      return IDEATR_ICON_ID;
  }
}
function createLightbulbIcon(className) {
  const icon = document.createElement("span");
  if (className) {
    icon.className = className;
  }
  (0, import_obsidian4.setIcon)(icon, IDEATR_ICON_ID);
  return icon;
}
function createStatusIcon(status, className) {
  const icon = document.createElement("span");
  if (className) {
    icon.className = className;
  }
  (0, import_obsidian4.setIcon)(icon, getStatusIconId(status));
  return icon;
}

// src/utils/ModelStatusIndicator.ts
function getModelStatus(llmService, settings) {
  if (!llmService) {
    return {
      status: "not-connected",
      modelName: "No AI configured",
      provider: "none",
      details: "Please configure AI in settings"
    };
  }
  if (!llmService.isAvailable()) {
    return {
      status: "not-connected",
      modelName: "AI not available",
      provider: "none",
      details: "AI service is not configured or enabled"
    };
  }
  if (llmService instanceof HybridLLM) {
    const hybridLLM = llmService;
    const preferCloud = settings.preferCloud;
    if (preferCloud && settings.cloudProvider !== "none") {
      const hasApiKey = settings.cloudProvider === "custom" ? settings.customEndpointUrl && settings.customEndpointUrl.trim().length > 0 : settings.cloudProvider === "custom-model" ? settings.customModelProvider && settings.cloudApiKeys && settings.customModelProvider in settings.cloudApiKeys && (settings.cloudApiKeys[settings.customModelProvider] || "").trim().length > 0 : settings.cloudApiKeys && settings.cloudProvider in settings.cloudApiKeys && (settings.cloudApiKeys[settings.cloudProvider] || "").trim().length > 0;
      if (hasApiKey) {
        const cloudStatus = getCloudProviderStatus(settings);
        if (cloudStatus.status === "connected") {
          return cloudStatus;
        }
      }
    }
    const localService = hybridLLM.getLocalLLM();
    if (localService instanceof LlamaService) {
      return getLocalModelStatus(localService, settings);
    }
    const modelKey = settings.localModel || "phi-3.5-mini";
    const modelConfig = MODELS[modelKey];
    const modelName = modelConfig ? modelConfig.name : "Unknown Model";
    return {
      status: "loading",
      modelName,
      provider: "hybrid",
      details: "Checking status..."
    };
  }
  if (llmService instanceof LlamaService) {
    return getLocalModelStatus(llmService, settings);
  }
  return getCloudProviderStatus(settings);
}
function getLocalModelStatus(llmService, settings) {
  const llamaService = llmService;
  const modelKey = settings.localModel || "phi-3.5-mini";
  const modelConfig = MODELS[modelKey];
  const modelName = modelConfig ? modelConfig.name : "Unknown Model";
  const loadingState = llamaService.getLoadingState();
  const isServerReady = llamaService.getIsServerReady();
  const hasServerProcess = llamaService.hasServerProcess();
  let status;
  let details;
  if (loadingState === "ready" && isServerReady) {
    status = "connected";
    details = "Model loaded and ready";
  } else if (loadingState === "loading" || hasServerProcess && !isServerReady) {
    status = "loading";
    details = "Loading model...";
  } else if (loadingState === "not-loaded" && !hasServerProcess) {
    status = "not-connected";
    details = "Model not loaded";
  } else {
    status = "error";
    details = "Connection issue";
  }
  return {
    status,
    modelName,
    provider: "local",
    details
  };
}
function getCloudProviderStatus(settings) {
  if (settings.cloudProvider === "none") {
    return {
      status: "not-connected",
      modelName: "Cloud AI not configured",
      provider: "cloud",
      details: "Please configure cloud AI in settings"
    };
  }
  const hasApiKey = settings.cloudProvider === "custom" ? settings.customEndpointUrl && settings.customEndpointUrl.trim().length > 0 : settings.cloudProvider === "custom-model" ? settings.customModelProvider && settings.cloudApiKeys && settings.customModelProvider in settings.cloudApiKeys && (settings.cloudApiKeys[settings.customModelProvider] || "").trim().length > 0 : settings.cloudApiKeys && settings.cloudProvider in settings.cloudApiKeys && (settings.cloudApiKeys[settings.cloudProvider] || "").trim().length > 0;
  if (!hasApiKey) {
    return {
      status: "not-connected",
      modelName: "Cloud AI not configured",
      provider: "cloud",
      details: "Please configure cloud AI in settings"
    };
  }
  let providerName = settings.cloudProvider;
  if (settings.cloudProvider === "openrouter" && settings.openRouterModel) {
    providerName = `OpenRouter: ${settings.openRouterModel}`;
  } else if (settings.cloudProvider === "custom" && settings.customEndpointUrl) {
    providerName = `Custom: ${settings.customEndpointUrl}`;
  } else if (settings.cloudProvider === "custom-model" && settings.customModelProvider && settings.customModel) {
    providerName = `${settings.customModelProvider}: ${settings.customModel}`;
  }
  return {
    status: "connected",
    modelName: providerName.charAt(0).toUpperCase() + providerName.slice(1),
    provider: "cloud",
    details: "Cloud AI ready"
  };
}
function createModelStatusIndicator(llmService, settings, _app) {
  const status = getModelStatus(llmService, settings);
  const container = document.createElement("div");
  container.className = "ideatr-model-status-indicator";
  const iconEl = createStatusIcon(status.status, `ideatr-model-status-icon ideatr-model-status-${status.status}`);
  container.appendChild(iconEl);
  const tooltip = document.createElement("div");
  tooltip.className = "ideatr-model-status-tooltip";
  tooltip.textContent = `${status.modelName}${status.details ? ` - ${status.details}` : ""}`;
  container.appendChild(tooltip);
  container.setAttribute("title", `${status.modelName}${status.details ? ` - ${status.details}` : ""}`);
  return container;
}

// src/capture/CaptureModal.ts
function formatShortcut(shortcut) {
  return shortcut.split("+").map((part) => {
    const trimmed = part.trim().toLowerCase();
    if (trimmed === "cmd" || trimmed === "meta")
      return "\u2318";
    if (trimmed === "ctrl")
      return "\u2303";
    if (trimmed === "alt")
      return "\u2325";
    if (trimmed === "shift")
      return "\u21E7";
    return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
  }).join(" ");
}
function matchesShortcut(e, shortcut) {
  const parts = shortcut.toLowerCase().split("+").map((p) => p.trim());
  const key = e.key.toLowerCase();
  const hasCmd = parts.includes("cmd") || parts.includes("meta");
  const hasCtrl = parts.includes("ctrl");
  const hasAlt = parts.includes("alt");
  const hasShift = parts.includes("shift");
  if (hasCmd && !e.metaKey)
    return false;
  if (hasCtrl && !e.ctrlKey)
    return false;
  if (hasAlt && !e.altKey)
    return false;
  if (hasShift && !e.shiftKey)
    return false;
  if (!hasCmd && e.metaKey)
    return false;
  if (!hasCtrl && e.ctrlKey)
    return false;
  if (!hasAlt && e.altKey)
    return false;
  if (!hasShift && e.shiftKey)
    return false;
  const keyPart = parts.find((p) => !["cmd", "meta", "ctrl", "alt", "shift"].includes(p));
  if (keyPart) {
    if (keyPart === "enter" && key !== "enter")
      return false;
    if (keyPart === "space" && key !== " ")
      return false;
    if (keyPart === "escape" && key !== "escape")
      return false;
    if (keyPart !== "enter" && keyPart !== "space" && keyPart !== "escape") {
      const normalizedKey = key.toLowerCase();
      const normalizedKeyPart = keyPart.toLowerCase();
      if (normalizedKey !== normalizedKeyPart)
        return false;
    }
  } else {
    return false;
  }
  return true;
}
var CaptureModal = class extends import_obsidian5.Modal {
  inputEl;
  errorEl;
  classificationEl;
  saveButton;
  ideateButton;
  fileManager;
  classificationService;
  duplicateDetector;
  // Domain checking removed - functionality hidden
  // private domainService: DomainService;
  webSearchService;
  searchQueryGenerator;
  nameVariantService;
  llmService;
  settings;
  onSuccess;
  isWarningShown = false;
  duplicatePaths = [];
  classificationAbortController = null;
  isFirstClassification = true;
  constructor(app, fileManager, classificationService, duplicateDetector, settings, _domainService, webSearchService, nameVariantService, llmService, onSuccess) {
    super(app);
    this.fileManager = fileManager;
    this.classificationService = classificationService;
    this.duplicateDetector = duplicateDetector;
    this.webSearchService = webSearchService;
    this.searchQueryGenerator = new SearchQueryGenerator();
    this.nameVariantService = nameVariantService;
    this.llmService = llmService;
    this.settings = settings;
    this.onSuccess = onSuccess;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-capture-modal");
    const titleContainer = contentEl.createDiv({ cls: "ideatr-capture-title-container" });
    titleContainer.createEl("h2", { text: "Capture Idea" });
    const statusIndicator = createModelStatusIndicator(this.llmService, this.settings, this.app);
    titleContainer.appendChild(statusIndicator);
    this.inputEl = contentEl.createEl("textarea", {
      attr: {
        placeholder: "Type your idea here...",
        rows: "6"
      }
    });
    this.inputEl.addClass("ideatr-input");
    this.errorEl = contentEl.createEl("div", {
      cls: "ideatr-error",
      attr: {
        style: "display: none;"
      }
    });
    this.classificationEl = contentEl.createEl("div", {
      cls: "ideatr-classification",
      attr: {
        style: "display: none;"
      }
    });
    const buttonContainer = contentEl.createEl("div", {
      cls: "ideatr-button-container"
    });
    const helpText = buttonContainer.createEl("div", {
      cls: "ideatr-help-text"
    });
    const helpParagraph = helpText.createEl("p", {
      attr: {
        style: "font-size: 0.85em; color: var(--text-muted); margin: 0; display: flex; align-items: center; gap: 0.4em;"
      }
    });
    const lightbulbIcon = createLightbulbIcon();
    lightbulbIcon.style.color = "var(--text-muted)";
    helpParagraph.appendChild(lightbulbIcon);
    helpParagraph.appendText(' Tip: Access other Ideatr features via Command Palette (search "Ideatr")');
    const buttonGroup = buttonContainer.createEl("div", {
      cls: "ideatr-button-group"
    });
    if (!this.settings.setupCompleted && !this.classificationService.isAvailable()) {
      const classifyButton = buttonGroup.createEl("button", {
        text: "Classify Now",
        cls: "mod-cta"
      });
      classifyButton.addEventListener("click", () => this.handleClassifyNow());
    }
    const ideateContainer = buttonGroup.createDiv({ cls: "ideatr-button-with-help" });
    const isLLMAvailable = this.llmService?.isAvailable() ?? false;
    this.ideateButton = ideateContainer.createEl("button", {
      text: "Ideate",
      cls: "mod-cta ideatr-ideate-button"
    });
    if (!isLLMAvailable) {
      this.ideateButton.disabled = true;
      this.ideateButton.addClass("ideatr-ideate-button-disabled");
      this.ideateButton.setAttribute("title", "Ideate (AI service not available. Please configure AI in settings.)");
    } else {
      const ideateShortcut = formatShortcut(this.settings.captureIdeateShortcut || "cmd+enter");
      this.ideateButton.setAttribute("title", `Ideate (${ideateShortcut})`);
      this.ideateButton.addEventListener("click", () => this.handleIdeate());
    }
    const ideateHelpIcon = createHelpIcon(this.app, "ideate-button", "Learn about the Ideate button");
    ideateContainer.appendChild(ideateHelpIcon);
    const saveContainer = buttonGroup.createDiv({ cls: "ideatr-button-with-help" });
    this.saveButton = saveContainer.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    const saveShortcut = formatShortcut(this.settings.captureSaveShortcut || "alt+enter");
    this.saveButton.setAttribute("title", `Save (${saveShortcut})`);
    this.saveButton.addEventListener("click", () => this.handleSubmit());
    const saveHelpIcon = createHelpIcon(this.app, "save-button", "Learn about the Save button");
    saveContainer.appendChild(saveHelpIcon);
    this.inputEl.focus();
    this.inputEl.addEventListener("keydown", (e) => {
      const ideateShortcut = this.settings.captureIdeateShortcut || "cmd+enter";
      if (matchesShortcut(e, ideateShortcut)) {
        e.preventDefault();
        if (this.llmService?.isAvailable() && this.ideateButton && !this.ideateButton.disabled) {
          this.handleIdeate();
        }
        return;
      }
      const saveShortcut2 = this.settings.captureSaveShortcut || "alt+enter";
      if (matchesShortcut(e, saveShortcut2)) {
        e.preventDefault();
        this.handleSubmit();
        return;
      }
      if (this.isWarningShown) {
        this.hideError();
        this.isWarningShown = false;
        this.saveButton.setText("Save");
        if (this.ideateButton) {
          this.ideateButton.textContent = "Ideate";
        }
      }
    });
  }
  async handleClassifyNow() {
    const text = this.inputEl.value;
    const validation = validateIdeaText(text);
    if (!validation.valid) {
      this.showError(validation.error || "Invalid input");
      return;
    }
    this.classificationAbortController = new AbortController();
    this.showClassificationInProgress(this.isFirstClassification);
    this.isFirstClassification = false;
    try {
      const classification = await this.classificationService.classifyIdea(validation.sanitizedText || text);
      if (this.classificationAbortController?.signal.aborted) {
        return;
      }
      this.showClassificationResults(classification, null);
    } catch (error) {
      if (this.classificationAbortController?.signal.aborted) {
        return;
      }
      console.error("Classification failed:", error);
      this.classificationEl.empty();
      this.classificationEl.style.display = "block";
      let errorMessage = "Classification unavailable. Please configure AI in settings.";
      if (error instanceof Error) {
        const errorMsg = error.message.toLowerCase();
        if (errorMsg.includes("invalid api key") || errorMsg.includes("unauthorized")) {
          errorMessage = "Invalid API key. Please check your AI settings.";
        } else if (errorMsg.includes("rate limit")) {
          errorMessage = "Rate limit exceeded. Please try again later.";
        } else if (errorMsg.includes("connection_refused") || errorMsg.includes("server not available")) {
          errorMessage = "AI server not available. Please configure AI in settings.";
        }
      }
      this.classificationEl.createEl("p", {
        text: errorMessage,
        cls: "ideatr-classification-error"
      });
      const retryButton = this.classificationEl.createEl("button", {
        text: "Retry",
        cls: "mod-cta"
      });
      retryButton.addEventListener("click", () => {
        this.handleClassifyNow();
      });
    }
  }
  async handleSubmit() {
    const text = this.inputEl.value;
    const validation = validateIdeaText(text);
    if (!validation.valid) {
      this.showError(validation.error || "Invalid input");
      return;
    }
    if (!this.isWarningShown) {
      try {
        const duplicateResult = await this.duplicateDetector.checkDuplicate(text);
        if (duplicateResult.isDuplicate) {
          const count = duplicateResult.duplicates.length;
          const msg = `Found ${count} similar idea${count > 1 ? "s" : ""}. Press Save again to confirm.`;
          this.showError(msg, true);
          this.isWarningShown = true;
          this.duplicatePaths = duplicateResult.duplicates.map((d) => d.path);
          this.saveButton.textContent = "Save Anyway";
          return;
        }
      } catch (error) {
        Logger.warn("Duplicate check failed:", error);
      }
    }
    try {
      const idea = {
        text: validation.sanitizedText || text,
        timestamp: /* @__PURE__ */ new Date()
      };
      const file = await this.fileManager.createIdeaFile(idea);
      new import_obsidian5.Notice("Idea captured!");
      this.close();
      if (this.onSuccess) {
        this.onSuccess();
      }
      this.processBackgroundTasks(file, idea.text).catch((error) => {
        Logger.warn("Background processing failed:", error);
      });
    } catch (error) {
      this.showError("Failed to save idea. Please try again.");
      console.error("Error creating idea file:", error);
    }
  }
  async handleIdeate() {
    const text = this.inputEl.value;
    const validation = validateIdeaText(text);
    if (!validation.valid) {
      this.showError(validation.error || "Invalid input");
      return;
    }
    if (!this.llmService?.isAvailable()) {
      this.showError("AI service is not available. Please configure AI in settings.");
      return;
    }
    if (!this.isWarningShown) {
      try {
        const duplicateResult = await this.duplicateDetector.checkDuplicate(text);
        if (duplicateResult.isDuplicate) {
          const count = duplicateResult.duplicates.length;
          const msg = `Found ${count} similar idea${count > 1 ? "s" : ""}. Press Ideate again to confirm.`;
          this.showError(msg, true);
          this.isWarningShown = true;
          this.duplicatePaths = duplicateResult.duplicates.map((d) => d.path);
          if (this.ideateButton) {
            this.ideateButton.textContent = "Ideate Anyway";
          }
          return;
        }
      } catch (error) {
        Logger.warn("Duplicate check failed:", error);
      }
    }
    try {
      this.showClassificationInProgress(true);
      this.classificationAbortController = new AbortController();
      const idea = {
        text: validation.sanitizedText || text,
        timestamp: /* @__PURE__ */ new Date()
      };
      const file = await this.fileManager.createIdeaFile(idea);
      const classification = await this.classificationService.classifyIdea(idea.text);
      if (this.classificationAbortController?.signal.aborted) {
        return;
      }
      let title = "";
      if (this.llmService.complete) {
        try {
          const titlePrompt = `Generate a concise, descriptive title for this idea.

Idea: "${idea.text}"

Requirements:
- 2-8 words maximum
- Descriptive and clear (captures the core concept)
- Not overly creative or abstract
- Should help someone quickly understand what this idea is about
- Extract the key concept, not just use the first words

Examples:
- "AI generated puzzle full of interlinked monkeys" \u2192 "AI Monkey Puzzle Game"
- "notification app that sends alerts" \u2192 "Notification App"
- "task manager for remote teams" \u2192 "Team Task Manager"

Title:`;
          const titleResponse = await this.llmService.complete(titlePrompt, {
            temperature: 0.3,
            n_predict: 50,
            stop: ["\n", ".", "!", "?"]
          });
          title = titleResponse.trim().replace(/^["']|["']$/g, "").substring(0, 100);
        } catch (error) {
          Logger.warn("Title generation failed, using fallback:", error);
          title = extractIdeaNameRuleBased(idea.text);
        }
      } else {
        title = extractIdeaNameRuleBased(idea.text);
      }
      let expansionText = "";
      if (this.llmService.expandIdea) {
        try {
          const expansionPrompt = `Expand this idea with related concepts, questions, and next steps.

Original Idea:
${idea.text}

Category: ${classification.category || "general"}
Tags: ${classification.tags.join(", ") || "none"}

Generate a structured expansion with:

## Related Ideas
2-3 variations or related concepts that explore different angles or implementations. Each should be:
- Distinct from the original but clearly related
- Brief (1-2 sentences each)
- Practical and actionable

## Key Questions
3-4 important questions to explore. Focus on:
- Validation questions (who needs this? what problem does it solve?)
- Implementation questions (how would this work? what's needed?)
- Strategic questions (what are the risks? what's the market?)

## Next Steps
1-2 concrete, actionable next steps to move forward. Be specific and practical.

Format as markdown with the sections above. Keep it concise and actionable - each item should be brief but meaningful.

Response:`;
          if (this.llmService.complete) {
            expansionText = await this.llmService.complete(expansionPrompt, {
              temperature: 0.7,
              n_predict: 800
            });
          }
        } catch (error) {
          Logger.warn("Expansion generation failed:", error);
          expansionText = "";
        }
      }
      if (this.classificationAbortController?.signal.aborted) {
        return;
      }
      const allRelated = [.../* @__PURE__ */ new Set([...classification.related, ...this.duplicatePaths])];
      await this.fileManager.updateIdeaFrontmatter(file, {
        category: classification.category,
        tags: classification.tags,
        related: allRelated
      });
      await this.app.vault.process(file, (content) => {
        const frontmatterRegex = /^---\n[\s\S]*?\n---(\n\n?|\n?)/;
        const bodyMatch = content.match(frontmatterRegex);
        const body = bodyMatch ? content.substring(bodyMatch[0].length) : content;
        let newBody = "";
        if (title) {
          newBody += `# ${title}

`;
        }
        newBody += body.trim();
        if (expansionText) {
          newBody += "\n\n---\n\n## Ideas & Questions\n\n" + expansionText.trim();
        }
        const frontmatter = bodyMatch ? content.substring(0, bodyMatch[0].length) : "";
        return frontmatter + newBody;
      });
      this.triggerValidation(file, idea.text, classification.category);
      new import_obsidian5.Notice("Idea processed with AI!");
      this.close();
      if (this.onSuccess) {
        this.onSuccess();
      }
    } catch (error) {
      if (this.classificationAbortController?.signal.aborted) {
        return;
      }
      this.showError("Failed to process idea. Please try again.");
      console.error("Error processing idea:", error);
      this.classificationEl.empty();
      this.classificationEl.style.display = "block";
      this.classificationEl.createEl("p", {
        text: "Processing failed. Idea may have been saved without AI processing.",
        cls: "ideatr-classification-error"
      });
      const continueButton = this.classificationEl.createEl("button", {
        text: "Continue",
        cls: "mod-cta"
      });
      continueButton.addEventListener("click", () => {
        this.close();
        if (this.onSuccess) {
          this.onSuccess();
        }
      });
    }
  }
  showError(message, isWarning = false) {
    this.errorEl.empty();
    this.errorEl.setText(message);
    this.errorEl.style.display = "block";
    this.errorEl.style.visibility = "visible";
    if (isWarning) {
      this.errorEl.addClass("ideatr-warning");
      this.errorEl.removeClass("ideatr-error");
    } else {
      this.errorEl.addClass("ideatr-error");
      this.errorEl.removeClass("ideatr-warning");
    }
  }
  hideError() {
    this.errorEl.style.display = "none";
    this.errorEl.style.visibility = "hidden";
    this.errorEl.removeClass("ideatr-warning");
    this.errorEl.removeClass("ideatr-error");
  }
  showClassificationInProgress(isFirstTime = false) {
    this.inputEl.style.display = "none";
    const buttonContainer = this.contentEl.querySelector(".ideatr-button-container");
    if (buttonContainer) {
      buttonContainer.style.display = "none";
    }
    this.classificationEl.empty();
    this.classificationEl.style.display = "block";
    const message = isFirstTime ? "Loading AI model (first use)... ~10 seconds" : "Classifying idea... ~2-3 seconds";
    const statusEl = this.classificationEl.createEl("p", { text: message });
    statusEl.addClass("ideatr-classification-status");
    const cancelButton = this.classificationEl.createEl("button", {
      text: "Cancel",
      cls: "ideatr-cancel-classification"
    });
    cancelButton.addEventListener("click", () => {
      this.cancelClassification();
    });
  }
  cancelClassification() {
    if (this.classificationAbortController) {
      this.classificationAbortController.abort();
      this.classificationAbortController = null;
    }
    this.classificationEl.empty();
    this.classificationEl.style.display = "block";
    this.classificationEl.createEl("p", {
      text: "Classification cancelled. Idea saved without classification.",
      cls: "ideatr-classification-status"
    });
    const manualButton = this.classificationEl.createEl("button", {
      text: "Continue",
      cls: "mod-cta"
    });
    manualButton.addEventListener("click", () => {
      this.close();
      if (this.onSuccess) {
        this.onSuccess();
      }
    });
  }
  handleClassificationError(error, file, ideaText) {
    let errorMessage = "Classification unavailable. Idea saved without classification.";
    let showManualMode = true;
    if (error instanceof Error) {
      const errorMsg = error.message.toLowerCase();
      if (errorMsg.includes("connection_refused") || errorMsg.includes("server not available")) {
        errorMessage = "AI server not available. Idea saved without classification.";
      } else if (errorMsg.includes("invalid api key") || errorMsg.includes("unauthorized")) {
        errorMessage = "Invalid API key. Please check your AI settings. Idea saved without classification.";
        showManualMode = true;
      } else if (errorMsg.includes("rate limit")) {
        errorMessage = "Rate limit exceeded. Please try again later. Idea saved without classification.";
      } else if (errorMsg.includes("timeout")) {
        errorMessage = "Classification timed out. Idea saved without classification.";
      } else if (errorMsg.includes("network") || errorMsg.includes("fetch")) {
        errorMessage = "Network error. Idea saved without classification.";
      }
    }
    this.classificationEl.empty();
    this.classificationEl.style.display = "block";
    this.classificationEl.createEl("p", {
      text: errorMessage,
      cls: "ideatr-classification-error"
    });
    if (showManualMode) {
      const manualButton = this.classificationEl.createEl("button", {
        text: "Continue",
        cls: "mod-cta"
      });
      manualButton.addEventListener("click", () => {
        this.triggerValidation(file, ideaText, "");
        this.close();
        if (this.onSuccess) {
          this.onSuccess();
        }
      });
    } else {
      setTimeout(() => {
        this.triggerValidation(file, ideaText, "");
        this.close();
        if (this.onSuccess) {
          this.onSuccess();
        }
      }, 2e3);
    }
  }
  showClassificationResults(classification, file) {
    const classificationResult = {
      category: classification.category,
      tags: classification.tags
    };
    const relatedNotes = [...classification.related];
    const duplicatePaths = [...this.duplicatePaths];
    const resultsModal = new ClassificationResultsModal(
      this.app,
      classificationResult,
      (editedResults) => {
        const finalClassification = {
          category: editedResults.category,
          tags: editedResults.tags,
          related: [.../* @__PURE__ */ new Set([...relatedNotes, ...duplicatePaths])]
        };
        if (file) {
          this.acceptClassification(finalClassification, file);
        } else {
          new import_obsidian5.Notice("Classification complete. Save the idea to apply results.");
          resultsModal.close();
        }
      },
      () => {
        const finalClassification = {
          category: classificationResult.category,
          tags: classificationResult.tags,
          related: [.../* @__PURE__ */ new Set([...relatedNotes, ...duplicatePaths])]
        };
        if (file) {
          this.acceptClassification(finalClassification, file);
        } else {
          new import_obsidian5.Notice("Classification complete. Save the idea to apply results.");
          resultsModal.close();
        }
      },
      async () => {
        try {
          const ideaText = this.inputEl.value;
          const retryClassification = await this.classificationService.classifyIdea(ideaText);
          resultsModal.close();
          this.showClassificationResults(retryClassification, file);
        } catch (error) {
          console.error("Retry classification failed:", error);
          new import_obsidian5.Notice("Failed to retry classification. Please try again.");
        }
      }
    );
    resultsModal.open();
  }
  acceptClassification(classification, file) {
    if (!file) {
      return;
    }
    const allRelated = [.../* @__PURE__ */ new Set([...classification.related, ...this.duplicatePaths])];
    this.fileManager.updateIdeaFrontmatter(file, {
      category: classification.category,
      tags: classification.tags,
      related: allRelated
    });
    new import_obsidian5.Notice("Classification applied");
    this.close();
    if (this.onSuccess) {
      this.onSuccess();
    }
  }
  rejectClassification() {
    this.close();
    if (this.onSuccess) {
      this.onSuccess();
    }
  }
  /**
   * Process AI tasks in the background after file is saved
   * This includes classification (if autoClassify is enabled) and validation
   */
  async processBackgroundTasks(file, ideaText) {
    let ideaCategory = "";
    if (this.settings.autoClassify && this.classificationService.isAvailable()) {
      try {
        const classification = await this.classificationService.classifyIdea(ideaText);
        ideaCategory = classification.category;
        const allRelated = [.../* @__PURE__ */ new Set([...classification.related, ...this.duplicatePaths])];
        await this.fileManager.updateIdeaFrontmatter(file, {
          category: classification.category,
          tags: classification.tags,
          related: allRelated
        });
      } catch (error) {
        Logger.warn("Background classification failed:", error);
      }
    }
    await this.triggerValidation(file, ideaText, ideaCategory);
  }
  /**
   * Trigger validation (web search and name variant generation) in background (non-blocking)
   */
  async triggerValidation(file, ideaText, category) {
    const projectName = extractIdeaNameRuleBased(ideaText);
    const shouldSearchWeb = this.settings.enableWebSearch && this.settings.autoSearchExistence;
    const shouldGenerateVariants = this.settings.enableNameVariants && this.settings.autoGenerateVariants && this.nameVariantService?.isAvailable();
    if (!shouldSearchWeb && !shouldGenerateVariants) {
      return;
    }
    const searchPromise = shouldSearchWeb ? this.performWebSearch(ideaText, category, projectName).catch((error) => {
      Logger.warn("Web search failed:", error);
      return null;
    }) : Promise.resolve(null);
    const variantPromise = shouldGenerateVariants && this.nameVariantService ? this.nameVariantService.generateVariants(ideaText).then((variants) => {
      if (variants.length > 0) {
        const formatted = this.nameVariantService.formatVariantsForMarkdown(variants);
        return this.fileManager.appendToFileBody(file, "Name Variants", formatted);
      }
      return Promise.resolve();
    }).catch((error) => {
      Logger.warn("Name variant generation failed:", error);
    }) : Promise.resolve(null);
    Promise.all([searchPromise, variantPromise]).then(([searchResults, _variantResult]) => {
      const updates = {};
      if (shouldSearchWeb) {
        if (searchResults === null) {
          updates["existence-check"] = ["Search error: Validation failed"];
        } else if (searchResults.length > 0) {
          updates["existence-check"] = formatSearchResultsForFrontmatter(
            searchResults,
            this.settings.maxSearchResults,
            category
          );
        }
      }
      if (Object.keys(updates).length > 0) {
        return this.fileManager.updateIdeaFrontmatter(file, updates);
      }
      return Promise.resolve();
    }).catch((error) => {
      Logger.warn("Validation orchestration failed:", error);
      const errorUpdates = {};
      if (shouldSearchWeb) {
        errorUpdates["existence-check"] = ["Search error: Validation failed"];
      }
      if (Object.keys(errorUpdates).length > 0) {
        this.fileManager.updateIdeaFrontmatter(file, errorUpdates).catch((err) => {
          console.error("Failed to store validation error state:", err);
        });
      }
    });
  }
  /**
   * Perform web search using query generator
   */
  async performWebSearch(ideaText, category, projectName) {
    if (!this.webSearchService.isAvailable()) {
      return [];
    }
    try {
      const query = this.searchQueryGenerator.generateQuery(ideaText, category, projectName);
      if (!query || query.trim().length === 0) {
        return [];
      }
      const results = await this.webSearchService.search(
        query,
        category,
        this.settings.maxSearchResults
      );
      return results;
    } catch (error) {
      Logger.warn("Web search failed:", error);
      return [];
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/DashboardView.ts
var import_obsidian6 = require("obsidian");

// src/types/management.ts
var ManagementError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "ManagementError";
  }
};
function getManagementErrorMessage(code) {
  switch (code) {
    case "FILE_READ_ERROR" /* FILE_READ_ERROR */:
      return "Failed to load ideas: some files could not be read. Please check your vault permissions.";
    case "FRONTMATTER_PARSE_ERROR" /* FRONTMATTER_PARSE_ERROR */:
    case "INVALID_FRONTMATTER" /* INVALID_FRONTMATTER */:
      return "Some ideas have invalid frontmatter and were skipped. Check your idea metadata and try again.";
    case "VAULT_ACCESS_ERROR" /* VAULT_ACCESS_ERROR */:
      return "Could not access the vault to load ideas. Please try again or restart Obsidian.";
    case "EMBEDDING_GENERATION_ERROR" /* EMBEDDING_GENERATION_ERROR */:
    case "EMBEDDING_TIMEOUT" /* EMBEDDING_TIMEOUT */:
    case "EMBEDDING_UNAVAILABLE" /* EMBEDDING_UNAVAILABLE */:
      return "Clustering is temporarily unavailable due to embedding errors. You can still use the dashboard table.";
    case "CLUSTERING_INSUFFICIENT_DATA" /* CLUSTERING_INSUFFICIENT_DATA */:
      return "Not enough ideas to generate clusters yet. Capture a few more ideas and try again.";
    case "CLUSTERING_ALGORITHM_ERROR" /* CLUSTERING_ALGORITHM_ERROR */:
      return "Clustering failed due to an internal error. Try narrowing your idea set or disabling clustering in settings.";
    case "CLUSTERING_TOO_MANY_IDEAS" /* CLUSTERING_TOO_MANY_IDEAS */:
      return "Too many ideas to cluster efficiently. Please filter to fewer ideas and try again.";
    case "VIEW_RENDERING_ERROR" /* VIEW_RENDERING_ERROR */:
    case "GRAPH_RENDERING_ERROR" /* GRAPH_RENDERING_ERROR */:
      return "Failed to render the management view. Try closing and reopening the view.";
    case "VIEW_MEMORY_ERROR" /* VIEW_MEMORY_ERROR */:
      return "Rendering the graph used too much memory. Try filtering to fewer ideas.";
    case "DIGEST_GENERATION_ERROR" /* DIGEST_GENERATION_ERROR */:
      return "Digest generation failed. Please try again or check your resurfacing settings.";
    case "DATE_PARSE_ERROR" /* DATE_PARSE_ERROR */:
      return "Some ideas have invalid or missing created dates and were skipped. Check your idea frontmatter.";
    case "ELEVATION_VALIDATION_ERROR" /* ELEVATION_VALIDATION_ERROR */:
      return "Idea cannot be elevated. Please check that the idea is valid and not already elevated.";
    case "ELEVATION_FILE_MOVE_ERROR" /* ELEVATION_FILE_MOVE_ERROR */:
      return "Failed to move idea file to project folder. Please check vault permissions.";
    case "ELEVATION_FOLDER_CREATION_ERROR" /* ELEVATION_FOLDER_CREATION_ERROR */:
      return "Failed to create project folder structure. Please check vault permissions.";
    case "ELEVATION_FRONTMATTER_UPDATE_ERROR" /* ELEVATION_FRONTMATTER_UPDATE_ERROR */:
      return "Failed to update idea frontmatter during elevation. The project may have been created but metadata may be incomplete.";
    case "ELEVATION_PROJECT_NAME_COLLISION" /* ELEVATION_PROJECT_NAME_COLLISION */:
      return "A project with this name already exists. Please choose a different name.";
    default:
      return "An unexpected management error occurred. Please check the console for details.";
  }
}

// src/views/dashboardUtils.ts
function parseTagsInput(value) {
  return value.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
}
function parseDateRange(start, end) {
  if (!start || !end) {
    return void 0;
  }
  const startDate = new Date(start);
  const endDate = new Date(end);
  if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
    return void 0;
  }
  return { start: startDate, end: endDate };
}
function paginate(items, page, perPage) {
  const safePerPage = perPage > 0 ? perPage : items.length || 1;
  const totalPages = Math.max(1, Math.ceil(items.length / safePerPage));
  const currentPage = Math.min(Math.max(1, page), totalPages);
  const start = (currentPage - 1) * safePerPage;
  const end = start + safePerPage;
  return {
    pageItems: items.slice(start, end),
    totalPages
  };
}

// src/views/graphRendererUtils.ts
function getClusterColor(clusterId) {
  let hash = 0;
  for (let i = 0; i < clusterId.length; i++) {
    hash = hash * 31 + clusterId.charCodeAt(i) >>> 0;
  }
  const hue = hash % 360;
  const saturation = 60;
  const lightness = 55;
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
function toRenderableGraph(layout) {
  const nodes = layout.nodes.map((node) => ({
    id: node.id,
    x: node.x,
    y: node.y,
    clusterId: node.clusterId,
    color: getClusterColor(node.clusterId),
    title: getNodeTitle(node),
    idea: node.idea
    // Include full idea data for tooltips
  }));
  const edges = layout.edges.map((edge) => ({
    from: edge.from,
    to: edge.to,
    weight: edge.weight
  }));
  return { nodes, edges, width: layout.width, height: layout.height };
}
function getNodeTitle(node) {
  const filename = node.idea.filename.replace(/\.md$/, "");
  const category = node.idea.frontmatter.category || "Uncategorized";
  return `${filename} [${category}]`;
}

// src/views/GraphRenderer.ts
function renderGraphLayout(container, layout, options = {}) {
  const { nodes, edges, width, height } = toRenderableGraph(layout);
  const originalLayout = layout;
  container.empty();
  const wrapper = container.createDiv({ cls: "ideatr-graph-wrapper" });
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.setAttribute("width", options.mini ? "220" : String(width));
  svg.setAttribute("height", options.mini ? "180" : String(height));
  svg.classList.add("ideatr-graph-svg");
  wrapper.appendChild(svg);
  for (const edge of edges) {
    const from = nodes.find((n) => n.id === edge.from);
    const to = nodes.find((n) => n.id === edge.to);
    if (!from || !to)
      continue;
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", String(from.x));
    line.setAttribute("y1", String(from.y));
    line.setAttribute("x2", String(to.x));
    line.setAttribute("y2", String(to.y));
    line.setAttribute("stroke", "var(--text-muted)");
    line.setAttribute("stroke-width", String(1 + edge.weight));
    line.setAttribute("stroke-opacity", "0.4");
    svg.appendChild(line);
  }
  const tooltip = document.createElement("div");
  tooltip.classList.add("ideatr-graph-tooltip");
  tooltip.style.display = "none";
  tooltip.style.position = "absolute";
  tooltip.style.pointerEvents = "none";
  tooltip.style.zIndex = "1000";
  wrapper.appendChild(tooltip);
  let hoveredNodeId = null;
  for (const node of nodes) {
    const group = document.createElementNS(svgNS, "g");
    group.setAttribute("transform", `translate(${node.x}, ${node.y})`);
    group.classList.add("ideatr-graph-node");
    const circle = document.createElementNS(svgNS, "circle");
    circle.setAttribute("r", options.mini ? "8" : "10");
    circle.setAttribute("fill", node.color);
    circle.setAttribute("stroke", "var(--background-primary-alt)");
    circle.setAttribute("stroke-width", "1");
    group.appendChild(circle);
    if (!options.mini) {
      const label = document.createElementNS(svgNS, "text");
      label.textContent = node.title;
      label.setAttribute("x", "12");
      label.setAttribute("y", "4");
      label.classList.add("ideatr-graph-label");
      group.appendChild(label);
    }
    if (options.onNodeClick) {
      group.style.cursor = "pointer";
      group.addEventListener("click", () => {
        options.onNodeClick?.(node.id);
      });
    }
    if (options.onNodeContextMenu) {
      group.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        options.onNodeContextMenu?.(node.id, e);
      });
    }
    if (options.onNodeHover && node.idea) {
      const originalNode = originalLayout.nodes.find((n) => n.id === node.id);
      group.addEventListener("mouseenter", (e) => {
        hoveredNodeId = node.id;
        if (originalNode) {
          options.onNodeHover?.(originalNode);
        }
        tooltip.style.display = "block";
        updateTooltipContent(tooltip, node.idea);
        positionTooltip(tooltip, e, wrapper);
      });
      group.addEventListener("mousemove", (e) => {
        if (hoveredNodeId === node.id) {
          positionTooltip(tooltip, e, wrapper);
        }
      });
      group.addEventListener("mouseleave", () => {
        hoveredNodeId = null;
        tooltip.style.display = "none";
        options.onNodeHover?.(null);
      });
    }
    svg.appendChild(group);
  }
}
function updateTooltipContent(tooltip, idea) {
  const filename = idea.filename.replace(/\.md$/, "");
  const category = idea.frontmatter.category || "Uncategorized";
  const tags = idea.frontmatter.tags.length > 0 ? idea.frontmatter.tags.join(", ") : "No tags";
  const preview = idea.body.length > 150 ? idea.body.substring(0, 150) + "..." : idea.body;
  const created = idea.frontmatter.created;
  tooltip.innerHTML = `
        <div class="ideatr-tooltip-header">
            <strong>${filename}</strong>
        </div>
        <div class="ideatr-tooltip-meta">
            <span>Category: ${category}</span>
            <span>Created: ${created}</span>
        </div>
        <div class="ideatr-tooltip-tags">
            Tags: ${tags}
        </div>
        <div class="ideatr-tooltip-preview">
            ${preview || "(No content)"}
        </div>
    `;
}
function positionTooltip(tooltip, event, container) {
  const rect = container.getBoundingClientRect();
  const tooltipRect = tooltip.getBoundingClientRect();
  const x = event.clientX - rect.left + 15;
  const y = event.clientY - rect.top - 10;
  const maxX = rect.width - tooltipRect.width - 10;
  const maxY = rect.height - tooltipRect.height - 10;
  tooltip.style.left = `${Math.min(x, maxX)}px`;
  tooltip.style.top = `${Math.max(10, Math.min(y, maxY))}px`;
}

// src/views/DashboardView.ts
init_HelpIcon();
var DashboardView = class extends import_obsidian6.ItemView {
  ideaRepository;
  clusteringService;
  resurfacingService;
  projectElevationService;
  ideas = [];
  filteredIdeas = [];
  filters = {};
  sortColumn = null;
  sortDirection = "asc";
  isLoading = false;
  currentPage = 1;
  itemsPerPage;
  persistFilters;
  constructor(leaf, ideaRepository, clusteringService, resurfacingService, projectElevationService, itemsPerPage = 50, persistFilters = false) {
    super(leaf);
    this.ideaRepository = ideaRepository;
    this.clusteringService = clusteringService;
    this.resurfacingService = resurfacingService;
    this.projectElevationService = projectElevationService;
    this.itemsPerPage = itemsPerPage;
    this.persistFilters = persistFilters;
  }
  getViewType() {
    return "ideatr-dashboard";
  }
  getDisplayText() {
    return "Ideatr Dashboard";
  }
  getIcon() {
    return "lightbulb";
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    if (this.persistFilters) {
      await this.loadFilterState();
    }
    const header = container.createDiv("dashboard-header");
    const headerTitle = header.createDiv({ cls: "dashboard-title-container" });
    headerTitle.createEl("h2", { text: "Ideatr Dashboard" });
    const dashboardHelpIcon = createHelpIcon(this.app, "dashboard", "Learn about the Dashboard");
    headerTitle.appendChild(dashboardHelpIcon);
    const toolbar = header.createDiv("dashboard-toolbar");
    const refreshBtn = toolbar.createEl("button", { text: "Refresh" });
    refreshBtn.addEventListener("click", () => this.refresh());
    const filterPanel = container.createDiv("dashboard-filters");
    const filterTitle = filterPanel.createDiv({ cls: "dashboard-filters-title" });
    filterTitle.createEl("h3", { text: "Filters" });
    const filterHelpIcon = createHelpIcon(this.app, "filters", "Learn about Dashboard Filters");
    filterTitle.appendChild(filterHelpIcon);
    this.createFilterUI(filterPanel);
    const sidePanels = container.createDiv("dashboard-side-panels");
    if (this.clusteringService) {
      const clustersPanel = sidePanels.createDiv("dashboard-panel clusters-panel");
      const clustersTitle = clustersPanel.createDiv({ cls: "dashboard-panel-title" });
      clustersTitle.createEl("h3", { text: "Clusters" });
      const clustersHelpIcon = createHelpIcon(this.app, "clusters", "Learn about Clusters");
      clustersTitle.appendChild(clustersHelpIcon);
      this.renderClustersMiniGraph(clustersPanel);
    }
    if (this.resurfacingService) {
      const resurfacingPanel = sidePanels.createDiv("dashboard-panel resurfacing-panel");
      const resurfacingTitle = resurfacingPanel.createDiv({ cls: "dashboard-panel-title" });
      resurfacingTitle.createEl("h3", { text: "Old Ideas" });
      const resurfacingHelpIcon = createHelpIcon(this.app, "resurfacing", "Learn about Resurfacing");
      resurfacingTitle.appendChild(resurfacingHelpIcon);
      this.renderResurfacingPanel(resurfacingPanel);
    }
    const triagePanel = sidePanels.createDiv("dashboard-panel triage-panel");
    const triageTitle = triagePanel.createDiv({ cls: "dashboard-panel-title" });
    triageTitle.createEl("h3", { text: "Triage Inbox" });
    const triageHelpIcon = createHelpIcon(this.app, "triage-inbox", "Learn about Triage Inbox");
    triageTitle.appendChild(triageHelpIcon);
    this.renderTriageInbox(triagePanel);
    const tableContainer = container.createDiv("dashboard-table-container");
    this.renderTable(tableContainer);
    await this.loadIdeas();
  }
  async onClose() {
  }
  /**
   * Create filter UI components
   */
  createFilterUI(container) {
    const searchContainer = container.createDiv("filter-item");
    searchContainer.createEl("label", { text: "Search:", attr: { for: "dashboard-search" } });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      attr: { id: "dashboard-search" },
      placeholder: "Search ideas..."
    });
    searchInput.addEventListener("input", (e) => {
      const value = e.target.value;
      this.filters.searchText = value || void 0;
      this.applyFilters();
    });
    const categoryContainer = container.createDiv("filter-item");
    categoryContainer.createEl("label", { text: "Category:" });
    const categoryInput = categoryContainer.createEl("input", {
      type: "text",
      placeholder: "Filter by category (comma-separated)..."
    });
    categoryInput.addEventListener("input", (e) => {
      const value = e.target.value;
      const parts = value.split(",").map((v) => v.trim()).filter((v) => v.length > 0);
      this.filters.categories = parts.length > 0 ? parts : void 0;
      this.applyFilters();
    });
    const tagsContainer = container.createDiv("filter-item");
    tagsContainer.createEl("label", { text: "Tags:" });
    const tagsInput = tagsContainer.createEl("input", {
      type: "text",
      placeholder: "Filter by tags (comma-separated)..."
    });
    tagsInput.addEventListener("input", (e) => {
      const value = e.target.value;
      const tags = parseTagsInput(value);
      this.filters.tags = tags.length > 0 ? tags : void 0;
      this.applyFilters();
    });
    const statusContainer = container.createDiv("filter-item");
    statusContainer.createEl("label", { text: "Status:" });
    const statusInput = statusContainer.createEl("input", {
      type: "text",
      placeholder: "Filter by status..."
    });
    statusInput.addEventListener("input", (e) => {
      const value = e.target.value.trim();
      this.filters.status = value || void 0;
      this.applyFilters();
    });
    const dateContainer = container.createDiv("filter-item date-range");
    dateContainer.createEl("label", { text: "Created between:" });
    const startInput = dateContainer.createEl("input", {
      type: "date"
    });
    const endInput = dateContainer.createEl("input", {
      type: "date"
    });
    const onDateChange = () => {
      this.filters.dateRange = parseDateRange(startInput.value || void 0, endInput.value || void 0);
      this.applyFilters();
    };
    startInput.addEventListener("change", onDateChange);
    endInput.addEventListener("change", onDateChange);
    const uncategorizedContainer = container.createDiv("filter-item");
    const uncategorizedLabel = uncategorizedContainer.createEl("label");
    const uncategorizedCheckbox = uncategorizedLabel.createEl("input", {
      type: "checkbox"
    });
    uncategorizedLabel.appendText(" Show only uncategorized ideas");
    uncategorizedCheckbox.addEventListener("change", (e) => {
      const checked = e.target.checked;
      this.filters.uncategorized = checked || void 0;
      this.applyFilters();
    });
    const clearBtn = container.createEl("button", { text: "Clear Filters" });
    clearBtn.addEventListener("click", () => {
      this.filters = {};
      searchInput.value = "";
      categoryInput.value = "";
      tagsInput.value = "";
      statusInput.value = "";
      startInput.value = "";
      endInput.value = "";
      uncategorizedCheckbox.checked = false;
      this.applyFilters();
    });
    if (this.persistFilters) {
      this.restoreFilterUIValues(searchInput, categoryInput, tagsInput, statusInput, startInput, endInput, uncategorizedCheckbox);
    }
  }
  /**
   * Restore filter UI input values from saved filter state (QA 4.1)
   */
  restoreFilterUIValues(searchInput, categoryInput, tagsInput, statusInput, startInput, endInput, uncategorizedCheckbox) {
    if (this.filters.searchText) {
      searchInput.value = this.filters.searchText;
    }
    if (this.filters.categories && this.filters.categories.length > 0) {
      categoryInput.value = this.filters.categories.join(", ");
    }
    if (this.filters.tags && this.filters.tags.length > 0) {
      tagsInput.value = this.filters.tags.join(", ");
    }
    if (this.filters.status) {
      statusInput.value = this.filters.status;
    }
    if (this.filters.dateRange) {
      startInput.value = this.filters.dateRange.start.toISOString().split("T")[0];
      endInput.value = this.filters.dateRange.end.toISOString().split("T")[0];
    }
    if (this.filters.uncategorized) {
      uncategorizedCheckbox.checked = true;
    }
  }
  /**
   * Render data table
   */
  renderTable(container) {
    container.empty();
    if (this.isLoading) {
      container.createEl("div", { text: "Loading ideas..." });
      return;
    }
    if (this.filteredIdeas.length === 0) {
      container.createEl("div", { text: "No ideas found." });
      return;
    }
    const table = container.createEl("table", { cls: "dashboard-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    this.createTableHeader(headerRow, "Date", "created");
    this.createTableHeader(headerRow, "Category", "category");
    this.createTableHeader(headerRow, "Tags", "tags");
    this.createTableHeader(headerRow, "Status", "status");
    this.createTableHeader(headerRow, "Title", "title");
    if (this.projectElevationService) {
      headerRow.createEl("th", { text: "Actions" });
    }
    const tbody = table.createEl("tbody");
    const { pageItems, totalPages } = paginate(this.filteredIdeas, this.currentPage, this.itemsPerPage);
    for (const idea of pageItems) {
      const row = tbody.createEl("tr");
      row.addEventListener("click", () => this.openIdea(idea));
      const dateCell = row.createEl("td");
      dateCell.textContent = idea.frontmatter.created;
      const categoryCell = row.createEl("td");
      categoryCell.textContent = idea.frontmatter.category || "Uncategorized";
      const tagsCell = row.createEl("td");
      tagsCell.textContent = idea.frontmatter.tags.join(", ") || "";
      const statusCell = row.createEl("td");
      statusCell.textContent = idea.frontmatter.status;
      const titleCell = row.createEl("td");
      const bodyPreview = idea.body.substring(0, 50);
      titleCell.textContent = bodyPreview || idea.filename;
      if (idea.body.length > 50) {
        titleCell.textContent += "...";
      }
      if (this.projectElevationService) {
        const actionsCell = row.createEl("td", { cls: "actions-cell" });
        if (this.projectElevationService.canElevate(idea)) {
          const elevateBtn = actionsCell.createEl("button", {
            text: "Elevate",
            cls: "elevate-btn"
          });
          elevateBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.elevateIdea(idea);
          });
        } else {
          actionsCell.textContent = "-";
        }
      }
    }
    const footer = container.createDiv("dashboard-pagination");
    footer.createSpan({ text: `Page ${this.currentPage} of ${totalPages}` });
    const that = this;
    const makePageButton = (label, delta) => {
      const btn = footer.createEl("button", { text: label });
      btn.addEventListener("click", () => {
        const nextPage = that.currentPage + delta;
        const safeNext = Math.min(Math.max(1, nextPage), totalPages);
        if (safeNext !== that.currentPage) {
          that.currentPage = safeNext;
          that.renderTable(container);
        }
      });
      return btn;
    };
    makePageButton("Prev", -1);
    makePageButton("Next", 1);
  }
  /**
   * Create sortable table header
   */
  createTableHeader(row, text, column) {
    const th = row.createEl("th");
    th.textContent = text;
    th.style.cursor = "pointer";
    th.addEventListener("click", () => this.sortBy(column));
    if (this.sortColumn === column) {
      th.textContent += this.sortDirection === "asc" ? " \u2191" : " \u2193";
    }
  }
  /**
   * Sort ideas by column
   */
  sortBy(column) {
    if (this.sortColumn === column) {
      this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
    } else {
      this.sortColumn = column;
      this.sortDirection = "asc";
    }
    this.filteredIdeas.sort((a, b) => {
      let aVal;
      let bVal;
      switch (column) {
        case "created":
          aVal = new Date(a.frontmatter.created).getTime();
          bVal = new Date(b.frontmatter.created).getTime();
          break;
        case "category":
          aVal = a.frontmatter.category || "";
          bVal = b.frontmatter.category || "";
          break;
        case "status":
          aVal = a.frontmatter.status;
          bVal = b.frontmatter.status;
          break;
        case "title":
          aVal = a.body || a.filename;
          bVal = b.body || b.filename;
          break;
        default:
          return 0;
      }
      if (aVal < bVal)
        return this.sortDirection === "asc" ? -1 : 1;
      if (aVal > bVal)
        return this.sortDirection === "asc" ? 1 : -1;
      return 0;
    });
    this.renderTable(this.contentEl.querySelector(".dashboard-table-container"));
  }
  /**
   * Load ideas from repository
   */
  async loadIdeas() {
    this.isLoading = true;
    this.renderTable(this.contentEl.querySelector(".dashboard-table-container"));
    try {
      this.ideas = await this.ideaRepository.getAllIdeas();
      this.applyFilters();
      if (this.clusteringService) {
        const clustersPanel = this.contentEl.querySelector(".clusters-panel");
        if (clustersPanel) {
          this.renderClustersMiniGraph(clustersPanel);
        }
      }
      if (this.resurfacingService) {
        const resurfacingPanel = this.contentEl.querySelector(".resurfacing-panel");
        if (resurfacingPanel) {
          this.renderResurfacingPanel(resurfacingPanel);
        }
      }
      const triagePanel = this.contentEl.querySelector(".triage-panel");
      if (triagePanel) {
        this.renderTriageInbox(triagePanel);
      }
    } catch (error) {
      console.error("Failed to load ideas:", error);
      const container = this.contentEl.querySelector(".dashboard-table-container");
      container.empty();
      let message = "Failed to load ideas. Please try again.";
      if (error instanceof ManagementError) {
        message = getManagementErrorMessage(error.code);
        new import_obsidian6.Notice(message);
      }
      container.createEl("div", { text: message });
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Apply filters to ideas
   */
  async applyFilters() {
    try {
      this.filteredIdeas = await this.ideaRepository.getIdeasByFilter(this.filters);
      this.currentPage = 1;
      this.renderTable(this.contentEl.querySelector(".dashboard-table-container"));
      if (this.persistFilters) {
        await this.saveFilterState();
      }
    } catch (error) {
      console.error("Failed to apply filters:", error);
      const container = this.contentEl.querySelector(".dashboard-table-container");
      container.empty();
      let message = "Failed to apply dashboard filters.";
      if (error instanceof ManagementError) {
        message = getManagementErrorMessage(error.code);
        new import_obsidian6.Notice(message);
      }
      container.createEl("div", { text: message });
    }
  }
  /**
   * Load persisted filter state from leaf view state (QA 4.1)
   */
  async loadFilterState() {
    try {
      const viewState = this.leaf.getViewState();
      if (viewState.state && viewState.state.filters) {
        this.filters = viewState.state.filters;
      }
    } catch (error) {
      Logger.warn("Failed to load persisted filter state:", error);
    }
  }
  /**
   * Save current filter state to leaf view state (QA 4.1)
   */
  async saveFilterState() {
    try {
      await this.leaf.setViewState({
        type: "ideatr-dashboard",
        state: {
          filters: this.filters
        }
      });
    } catch (error) {
      Logger.warn("Failed to save filter state:", error);
    }
  }
  /**
   * Refresh ideas
   */
  async refresh() {
    await this.ideaRepository.refresh();
    await this.loadIdeas();
  }
  /**
   * Open idea file
   */
  openIdea(idea) {
    const file = this.app.vault.getAbstractFileByPath(`Ideas/${idea.filename}`);
    if (file) {
      this.app.workspace.openLinkText(`Ideas/${idea.filename}`, "", false);
    }
  }
  /**
   * Render clusters mini-graph
   */
  async renderClustersMiniGraph(container) {
    container.empty();
    container.createEl("div", { text: "Loading clusters...", cls: "loading" });
    try {
      if (this.ideas.length < 2) {
        container.empty();
        container.createEl("div", { text: "Need at least 2 ideas for clustering." });
        return;
      }
      const clusters = await this.clusteringService.clusterIdeas(this.ideas);
      const previewLayout = this.app.plugins ? this.app.plugins?.getPlugin("ideatr")?.graphLayoutService?.layoutGraph(clusters, 220, 180) : null;
      container.empty();
      container.createEl("div", {
        text: `${clusters.length} clusters found`,
        cls: "cluster-summary"
      });
      if (previewLayout) {
        const graphContainer = container.createDiv("clusters-mini-graph");
        renderGraphLayout(graphContainer, previewLayout, {
          mini: true,
          onNodeClick: (nodeId) => {
            const node = previewLayout.nodes.find((n) => n.id === nodeId);
            if (node) {
              this.openIdea(node.idea);
            }
          },
          onNodeHover: (_node) => {
          }
        });
      }
      const openGraphBtn = container.createEl("button", { text: "Open Full Graph" });
      openGraphBtn.addEventListener("click", () => {
        this.app.workspace.getLeaf(false).setViewState({
          type: "ideatr-graph",
          active: true
        });
      });
    } catch (error) {
      console.error("Failed to load clusters:", error);
      container.empty();
      container.createEl("div", { text: "Failed to load clusters." });
    }
  }
  /**
   * Render resurfacing panel
   */
  async renderResurfacingPanel(container) {
    container.empty();
    container.createEl("div", { text: "Loading old ideas...", cls: "loading" });
    try {
      const oldIdeas = await this.resurfacingService.identifyOldIdeas();
      container.empty();
      if (oldIdeas.length === 0) {
        container.createEl("div", { text: "No old ideas found." });
        return;
      }
      container.createEl("div", {
        text: `${oldIdeas.length} old ideas need attention`,
        cls: "resurfacing-summary"
      });
      const ideasList = container.createEl("ul", { cls: "resurfacing-list" });
      for (const idea of oldIdeas.slice(0, 5)) {
        const li = ideasList.createEl("li");
        const age = this.calculateAge(idea.frontmatter.created);
        li.textContent = `${idea.filename.replace(".md", "")} (${age} days old)`;
        li.style.cursor = "pointer";
        li.addEventListener("click", () => this.openIdea(idea));
      }
      if (oldIdeas.length > 5) {
        ideasList.createEl("li", { text: `... and ${oldIdeas.length - 5} more` });
      }
      const generateDigestBtn = container.createEl("button", { text: "Generate Digest" });
      generateDigestBtn.addEventListener("click", async () => {
        try {
          const digest = await this.resurfacingService.generateDigest();
          const digestPath = `Ideas/.ideatr-digest-${Date.now()}.md`;
          await this.app.vault.create(digestPath, digest.summary);
          const file = this.app.vault.getAbstractFileByPath(digestPath);
          if (file) {
            await this.app.workspace.openLinkText(digestPath, "", false);
          }
        } catch (error) {
          console.error("Failed to generate digest:", error);
        }
      });
    } catch (error) {
      console.error("Failed to load resurfacing panel:", error);
      container.empty();
      container.createEl("div", { text: "Failed to load old ideas." });
    }
  }
  /**
   * Render triage inbox
   */
  renderTriageInbox(container) {
    container.empty();
    const uncategorizedIdeas = this.filteredIdeas.filter(
      (idea) => !idea.frontmatter.category || idea.frontmatter.category === ""
    );
    if (uncategorizedIdeas.length === 0) {
      container.createEl("div", { text: "All ideas are categorized!" });
      return;
    }
    container.createEl("div", {
      text: `${uncategorizedIdeas.length} uncategorized ideas`,
      cls: "triage-summary"
    });
    const ideasList = container.createEl("ul", { cls: "triage-list" });
    for (const idea of uncategorizedIdeas.slice(0, 10)) {
      const li = ideasList.createEl("li");
      li.textContent = idea.filename.replace(".md", "");
      li.style.cursor = "pointer";
      li.addEventListener("click", () => this.openIdea(idea));
    }
    if (uncategorizedIdeas.length > 10) {
      ideasList.createEl("li", { text: `... and ${uncategorizedIdeas.length - 10} more` });
    }
  }
  /**
   * Calculate age in days
   */
  calculateAge(createdDate) {
    try {
      const created = new Date(createdDate);
      const now = /* @__PURE__ */ new Date();
      const diffTime = Math.abs(now.getTime() - created.getTime());
      return Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
    } catch {
      return 0;
    }
  }
  /**
   * Elevate idea to project
   */
  async elevateIdea(idea) {
    if (!this.projectElevationService) {
      new import_obsidian6.Notice("Elevation service not available.");
      return;
    }
    if (!this.projectElevationService.canElevate(idea)) {
      new import_obsidian6.Notice("This idea cannot be elevated. It may already be elevated or have invalid frontmatter.");
      return;
    }
    const projectName = this.projectElevationService.generateProjectName(idea);
    const confirmed = confirm(
      `Elevate idea to project?

Project name: ${projectName}

The idea file will be moved to Projects/${projectName}/README.md
Original file will be deleted.`
    );
    if (!confirmed) {
      return;
    }
    try {
      new import_obsidian6.Notice("Elevating idea to project...");
      const result = await this.projectElevationService.elevateIdea(idea);
      if (result.success) {
        new import_obsidian6.Notice(`Idea elevated to project: ${result.projectPath}`);
        await this.ideaRepository.refresh();
        await this.loadIdeas();
        if (result.warnings && result.warnings.length > 0) {
          Logger.warn("Elevation warnings:", result.warnings);
        }
      } else {
        new import_obsidian6.Notice(`Failed to elevate idea: ${result.error || "Unknown error"}`);
        if (result.warnings && result.warnings.length > 0) {
          Logger.warn("Elevation warnings:", result.warnings);
        }
      }
    } catch (error) {
      console.error("Failed to elevate idea:", error);
      new import_obsidian6.Notice("Failed to elevate idea. Please try again.");
    }
  }
};

// src/views/GraphView.ts
var import_obsidian7 = require("obsidian");
init_HelpIcon();
var GraphView = class extends import_obsidian7.ItemView {
  clusteringService;
  graphLayoutService;
  ideaRepository;
  projectElevationService;
  ideas = [];
  isLoading = false;
  currentLayout = null;
  // Store current layout for node lookups
  constructor(leaf, clusteringService, graphLayoutService, ideaRepository, projectElevationService) {
    super(leaf);
    this.clusteringService = clusteringService;
    this.graphLayoutService = graphLayoutService;
    this.ideaRepository = ideaRepository;
    this.projectElevationService = projectElevationService;
  }
  getViewType() {
    return "ideatr-graph";
  }
  getDisplayText() {
    return "Ideatr Graph";
  }
  getIcon() {
    return "git-branch";
  }
  async onOpen() {
    const container = this.contentEl;
    container.empty();
    const header = container.createDiv("graph-header");
    const headerTitle = header.createDiv({ cls: "graph-title-container" });
    headerTitle.createEl("h2", { text: "Idea Clusters" });
    const graphHelpIcon = createHelpIcon(this.app, "graph-view", "Learn about Graph View");
    headerTitle.appendChild(graphHelpIcon);
    const toolbar = header.createDiv("graph-toolbar");
    const refreshBtn = toolbar.createEl("button", { text: "Refresh" });
    refreshBtn.addEventListener("click", () => this.refresh());
    const graphContainer = container.createDiv("graph-container");
    this.renderGraph(graphContainer);
    await this.loadGraph();
  }
  async onClose() {
  }
  /**
   * Render graph visualization
   */
  renderGraph(container) {
    container.empty();
    if (this.isLoading) {
      container.createEl("div", { text: "Generating clusters..." });
      return;
    }
    if (this.ideas.length === 0) {
      container.createEl("div", { text: "No ideas found." });
      return;
    }
    if (this.ideas.length < 2) {
      container.createEl("div", { text: "Need at least 2 ideas to create clusters." });
      return;
    }
  }
  /**
   * Load and generate graph
   */
  async loadGraph() {
    this.isLoading = true;
    const container = this.contentEl.querySelector(".graph-container");
    this.renderGraph(container);
    try {
      this.ideas = await this.ideaRepository.getAllIdeas();
      if (this.ideas.length >= 2) {
        const clusters = await this.clusteringService.clusterIdeas(this.ideas);
        const layout = this.graphLayoutService.layoutGraph(clusters, 800, 600);
        this.currentLayout = layout;
        renderGraphLayout(container, layout, {
          onNodeClick: (nodeId) => {
            const node = layout.nodes.find((n) => n.id === nodeId);
            if (node) {
              this.openIdea(node.idea);
            }
          },
          onNodeHover: (_node) => {
          },
          onNodeContextMenu: (nodeId, event) => {
            this.showNodeContextMenu(nodeId, event);
          },
          mini: false
        });
      } else {
        this.renderGraph(container);
      }
    } catch (error) {
      console.error("Failed to load graph:", error);
      container.empty();
      let message = "Failed to load graph. Please try again.";
      if (error instanceof ManagementError) {
        message = getManagementErrorMessage(error.code);
        new import_obsidian7.Notice(message);
      }
      container.createEl("div", { text: message });
    } finally {
      this.isLoading = false;
    }
  }
  /**
   * Refresh graph
   */
  async refresh() {
    await this.ideaRepository.refresh();
    await this.loadGraph();
  }
  /**
   * Open idea file
   */
  openIdea(idea) {
    const file = this.app.vault.getAbstractFileByPath(`Ideas/${idea.filename}`);
    if (file) {
      this.app.workspace.openLinkText(`Ideas/${idea.filename}`, "", false);
    }
  }
  /**
   * Show context menu for a node
   */
  showNodeContextMenu(nodeId, event) {
    if (!this.currentLayout)
      return;
    const node = this.currentLayout.nodes.find((n) => n.id === nodeId);
    if (!node)
      return;
    const existingMenu = document.querySelector(".ideatr-graph-context-menu");
    if (existingMenu) {
      existingMenu.remove();
    }
    const menu = document.createElement("div");
    menu.classList.add("ideatr-graph-context-menu");
    menu.style.position = "fixed";
    menu.style.left = `${event.clientX}px`;
    menu.style.top = `${event.clientY}px`;
    menu.style.zIndex = "10000";
    menu.style.backgroundColor = "var(--background-primary)";
    menu.style.border = "1px solid var(--background-modifier-border)";
    menu.style.borderRadius = "4px";
    menu.style.padding = "4px";
    menu.style.boxShadow = "0 2px 8px rgba(0,0,0,0.2)";
    const openBtn = menu.createEl("button", {
      text: "Open Idea",
      cls: "context-menu-item"
    });
    openBtn.style.display = "block";
    openBtn.style.width = "100%";
    openBtn.style.textAlign = "left";
    openBtn.style.padding = "6px 12px";
    openBtn.style.border = "none";
    openBtn.style.background = "transparent";
    openBtn.style.cursor = "pointer";
    openBtn.addEventListener("click", () => {
      this.openIdea(node.idea);
      menu.remove();
    });
    if (this.projectElevationService && this.projectElevationService.canElevate(node.idea)) {
      const elevateBtn = menu.createEl("button", {
        text: "Elevate to Project",
        cls: "context-menu-item"
      });
      elevateBtn.style.display = "block";
      elevateBtn.style.width = "100%";
      elevateBtn.style.textAlign = "left";
      elevateBtn.style.padding = "6px 12px";
      elevateBtn.style.border = "none";
      elevateBtn.style.background = "transparent";
      elevateBtn.style.cursor = "pointer";
      elevateBtn.style.borderTop = "1px solid var(--background-modifier-border)";
      elevateBtn.addEventListener("click", () => {
        this.elevateIdea(node.idea);
        menu.remove();
      });
    }
    document.body.appendChild(menu);
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", closeMenu);
    }, 0);
  }
  /**
   * Elevate idea to project
   */
  async elevateIdea(idea) {
    if (!this.projectElevationService) {
      new import_obsidian7.Notice("Elevation service not available.");
      return;
    }
    if (!this.projectElevationService.canElevate(idea)) {
      new import_obsidian7.Notice("This idea cannot be elevated. It may already be elevated or have invalid frontmatter.");
      return;
    }
    const projectName = this.projectElevationService.generateProjectName(idea);
    const confirmed = confirm(
      `Elevate idea to project?

Project name: ${projectName}

The idea file will be moved to Projects/${projectName}/README.md
Original file will be deleted.`
    );
    if (!confirmed) {
      return;
    }
    try {
      new import_obsidian7.Notice("Elevating idea to project...");
      const result = await this.projectElevationService.elevateIdea(idea);
      if (result.success) {
        new import_obsidian7.Notice(`Idea elevated to project: ${result.projectPath}`);
        await this.ideaRepository.refresh();
        await this.loadGraph();
        if (result.warnings && result.warnings.length > 0) {
          Logger.warn("Elevation warnings:", result.warnings);
        }
      } else {
        new import_obsidian7.Notice(`Failed to elevate idea: ${result.error || "Unknown error"}`);
        if (result.warnings && result.warnings.length > 0) {
          Logger.warn("Elevation warnings:", result.warnings);
        }
      }
    } catch (error) {
      console.error("Failed to elevate idea:", error);
      new import_obsidian7.Notice("Failed to elevate idea. Please try again.");
    }
  }
};

// src/settings.ts
var import_obsidian23 = require("obsidian");

// src/settings/sections/LLMSettingsSection.ts
var import_obsidian10 = require("obsidian");

// src/settings/components/SettingsSection.ts
var BaseSettingsSection = class {
  constructor(app, plugin, settingsTab) {
    this.app = app;
    this.plugin = plugin;
    this.settingsTab = settingsTab;
  }
  settingsTab;
  async saveSettings() {
    await this.plugin.saveSettings();
  }
  refresh() {
    if (this.settingsTab && this.settingsTab.display) {
      this.settingsTab.display();
    }
  }
};

// src/views/FirstLaunchSetupModal.ts
var import_obsidian9 = require("obsidian");

// src/views/ModelDownloadModal.ts
var import_obsidian8 = require("obsidian");
var ModelDownloadModal = class extends import_obsidian8.Modal {
  modelManager;
  progressBar;
  progressText;
  cancelButton;
  errorMessage;
  modelInfo;
  retryButton = null;
  isDownloading = false;
  downloadStartTime = 0;
  isWarning = false;
  allowBackgroundDownload = false;
  constructor(app, modelManager) {
    super(app);
    this.modelManager = modelManager;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-download-modal");
    contentEl.createEl("h2", { text: "Download AI Model" });
    const info = this.modelManager.getModelInfo();
    this.modelInfo = contentEl.createEl("div", { cls: "ideatr-model-info" });
    this.modelInfo.createEl("p", {
      text: `Model: ${info.name}`
    });
    this.modelInfo.createEl("p", {
      text: `Size: ${info.sizeMB.toFixed(1)} MB (${(info.sizeMB / 1024).toFixed(2)} GB)`
    });
    this.modelInfo.createEl("p", {
      text: `Storage: ${this.modelManager.getModelPath()}`
    });
    const progressContainer = contentEl.createEl("div", { cls: "ideatr-progress-container" });
    this.progressBar = progressContainer.createEl("div", { cls: "ideatr-progress-bar" });
    const progressBarFill = this.progressBar.createEl("div", { cls: "ideatr-progress-bar-fill" });
    progressBarFill.style.width = "0%";
    this.progressText = progressContainer.createEl("div", { cls: "ideatr-progress-text" });
    this.progressText.textContent = "Preparing download...";
    this.errorMessage = contentEl.createEl("div", {
      cls: "ideatr-error",
      attr: {
        style: "display: none; margin-top: 10px;"
      }
    });
    const buttonContainer = contentEl.createEl("div", { cls: "ideatr-button-container" });
    const backgroundButton = buttonContainer.createEl("button", {
      text: "Download in Background",
      cls: "mod-cta"
    });
    backgroundButton.style.marginRight = "10px";
    backgroundButton.addEventListener("click", () => {
      this.allowBackgroundDownload = true;
      new import_obsidian8.Notice("Download will continue in background. You'll be notified when it completes.");
      this.close();
    });
    this.cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-cancel"
    });
    this.cancelButton.addEventListener("click", () => this.handleCancel());
    this.startDownload();
  }
  async startDownload(overwrite = false) {
    if (this.isDownloading) {
      return;
    }
    this.isDownloading = true;
    this.downloadStartTime = Date.now();
    this.cancelButton.textContent = "Cancel";
    this.errorMessage.style.display = "none";
    this.isWarning = false;
    this.progressText.textContent = overwrite ? "Re-downloading model..." : "Starting download...";
    try {
      await this.modelManager.downloadModel(
        (progress, downloadedMB, totalMB) => {
          if (this.isDownloading) {
            this.updateProgress(progress, downloadedMB, totalMB);
          }
        },
        void 0,
        overwrite
      );
      new import_obsidian8.Notice("Model download complete! Verifying...");
      const isValid = await this.modelManager.verifyModelIntegrity();
      if (isValid) {
        if (this.isDownloading) {
          this.progressText.textContent = "Download complete and verified!";
          this.cancelButton.textContent = "Close";
          this.cancelButton.removeClass("mod-cancel");
          this.cancelButton.addClass("mod-cta");
        }
        new import_obsidian8.Notice("Model downloaded and verified successfully!");
        if (this.isDownloading) {
          setTimeout(() => {
            this.close();
          }, 2e3);
        }
      } else {
        if (this.isDownloading) {
          this.showError("Downloaded file failed integrity check. Please try again.");
          this.showRetryButton();
        } else {
          new import_obsidian8.Notice("Model download failed integrity check. Please try again.", 5e3);
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Download failed";
      if (errorMessage === "Model already downloaded") {
        this.showWarning("Model is already downloaded. You can download again to replace it.");
        this.showRetryButton("Download again anyway");
      } else {
        this.showError(errorMessage);
        this.showRetryButton();
      }
    } finally {
      this.isDownloading = false;
    }
  }
  updateProgress(progress, downloadedMB, totalMB) {
    const progressBarFill = this.progressBar.querySelector(".ideatr-progress-bar-fill");
    if (progressBarFill) {
      progressBarFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
    }
    const progressPercent = Math.round(progress);
    const downloadedGB = (downloadedMB / 1024).toFixed(2);
    const totalGB = (totalMB / 1024).toFixed(2);
    const remainingMB = totalMB - downloadedMB;
    const elapsedSeconds = this.downloadStartTime > 0 ? (Date.now() - this.downloadStartTime) / 1e3 : 0;
    const speedMBps = downloadedMB > 0 && elapsedSeconds > 0 ? downloadedMB / elapsedSeconds : 0;
    const etaSeconds = speedMBps > 0 ? remainingMB / speedMBps : 0;
    const etaMinutes = Math.ceil(etaSeconds / 60);
    let etaText = "";
    if (etaMinutes > 0 && progress > 0 && progress < 100 && etaMinutes < 1e5) {
      if (etaMinutes < 60) {
        etaText = ` \u2022 ETA: ~${etaMinutes} minute${etaMinutes !== 1 ? "s" : ""}`;
      } else {
        const etaHours = Math.floor(etaMinutes / 60);
        const remainingMins = etaMinutes % 60;
        etaText = ` \u2022 ETA: ~${etaHours} hour${etaHours !== 1 ? "s" : ""}${remainingMins > 0 ? ` ${remainingMins} minute${remainingMins !== 1 ? "s" : ""}` : ""}`;
      }
    }
    this.progressText.textContent = `Downloading: ${progressPercent}% (${downloadedGB} GB / ${totalGB} GB)${etaText}`;
  }
  showError(message) {
    this.isWarning = false;
    this.errorMessage.empty();
    this.errorMessage.style.display = "block";
    this.errorMessage.style.color = "var(--text-error)";
    this.progressText.textContent = "Download failed";
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    const parts = message.split(urlRegex);
    parts.forEach((part) => {
      if (part.match(/^https?:\/\//)) {
        const link = this.errorMessage.createEl("a", {
          text: part,
          href: part,
          attr: {
            target: "_blank",
            rel: "noopener noreferrer"
          }
        });
        link.style.color = "var(--text-accent)";
        link.style.textDecoration = "underline";
      } else if (part.trim()) {
        this.errorMessage.createEl("span", { text: part });
      }
    });
    const progressBarFill = this.progressBar.querySelector(".ideatr-progress-bar-fill");
    if (progressBarFill) {
      progressBarFill.style.width = "0%";
    }
  }
  showWarning(message) {
    this.isWarning = true;
    this.errorMessage.empty();
    this.errorMessage.style.display = "block";
    this.errorMessage.style.color = "var(--text-warning, var(--text-warning-color, #d19a66))";
    this.progressText.textContent = "Model already exists";
    this.errorMessage.createEl("span", { text: message });
    const progressBarFill = this.progressBar.querySelector(".ideatr-progress-bar-fill");
    if (progressBarFill) {
      progressBarFill.style.width = "0%";
    }
  }
  showRetryButton(buttonText = "Retry") {
    if (this.retryButton) {
      return;
    }
    const buttonContainer = this.contentEl.querySelector(".ideatr-button-container");
    if (buttonContainer) {
      this.retryButton = buttonContainer.createEl("button", {
        text: buttonText,
        cls: "mod-cta"
      });
      this.retryButton.addEventListener("click", () => {
        if (this.retryButton) {
          this.retryButton.remove();
          this.retryButton = null;
        }
        this.startDownload(this.isWarning);
      });
    }
  }
  handleCancel() {
    if (this.isDownloading) {
      this.modelManager.cancelDownload();
      this.isDownloading = false;
      this.progressText.textContent = "Download cancelled";
      this.cancelButton.textContent = "Close";
    } else {
      this.close();
    }
  }
  onClose() {
    const { contentEl } = this;
    if (this.isDownloading && !this.allowBackgroundDownload) {
      this.modelManager.cancelDownload();
    }
    contentEl.empty();
    this.isDownloading = false;
    this.retryButton = null;
    this.allowBackgroundDownload = false;
  }
};

// src/utils/modelComparisonRenderer.ts
function localModelToDisplayInfo(model) {
  return {
    name: model.name,
    badge: model.badge,
    description: model.description,
    quality: model.quality,
    speed: model.speed,
    pros: model.pros,
    cons: model.cons,
    bestFor: model.bestFor,
    sizeMB: model.sizeMB,
    ram: model.ram
  };
}
function cloudModelToDisplayInfo(model) {
  return {
    name: model.name,
    badge: model.badge,
    description: model.description,
    quality: model.quality,
    speed: model.speed,
    pros: model.pros,
    cons: model.cons,
    bestFor: model.bestFor,
    cost: model.cost,
    costEstimate: model.costEstimate
  };
}
function renderCompactModelCard(container, model, isLocal = false) {
  const card = container.createDiv({ cls: "model-comparison-card" });
  card.style.cssText = "border: 1px solid var(--background-modifier-border); border-radius: 6px; padding: 0.75em; margin-bottom: 0.75em;";
  const header = card.createDiv({ cls: "model-comparison-header" });
  header.style.cssText = "display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5em;";
  const nameEl = header.createEl("strong", { text: model.name });
  nameEl.style.cssText = "font-size: 0.95em;";
  const badge = header.createEl("span", { text: model.badge, cls: "model-comparison-badge" });
  badge.style.cssText = "background: var(--text-accent); color: var(--text-on-accent); padding: 0.15em 0.4em; border-radius: 3px; font-size: 0.7em; font-weight: bold;";
  const stats = card.createDiv({ cls: "model-comparison-stats" });
  stats.style.cssText = "display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.4em 1em; margin-bottom: 0.5em; font-size: 0.85em;";
  stats.createEl("div", { text: `\u2B50 ${model.quality}/5` });
  stats.createEl("div", { text: `\u26A1 ${model.speed}/5` });
  if (isLocal && model.sizeMB) {
    stats.createEl("div", { text: `\u{1F4E6} ${(model.sizeMB / 1e3).toFixed(1)}GB` });
    if (model.ram) {
      stats.createEl("div", { text: `\u{1F4BE} ${model.ram}` });
    }
  } else if (!isLocal && model.costEstimate) {
    stats.createEl("div", { text: `\u{1F4B0} ${model.costEstimate}` });
    if (model.cost) {
      const costLabel = model.cost.charAt(0).toUpperCase() + model.cost.slice(1);
      stats.createEl("div", { text: `\u{1F4B5} ${costLabel}` });
    }
  }
  const desc = card.createEl("p", { text: model.description, cls: "model-comparison-description" });
  desc.style.cssText = "margin: 0.4em 0; color: var(--text-muted); font-size: 0.85em; line-height: 1.4;";
  const details = card.createDiv({ cls: "model-comparison-details" });
  details.style.cssText = "display: flex; gap: 1em; margin-top: 0.4em; font-size: 0.8em;";
  if (model.pros.length > 0) {
    const prosEl = details.createDiv({ cls: "model-comparison-pros" });
    prosEl.style.cssText = "flex: 1;";
    prosEl.createEl("strong", { text: "\u2713 " });
    prosEl.appendText(model.pros.join(", "));
  }
  if (model.cons.length > 0) {
    const consEl = details.createDiv({ cls: "model-comparison-cons" });
    consEl.style.cssText = "flex: 1; color: var(--text-muted);";
    consEl.createEl("strong", { text: "\u2717 " });
    consEl.appendText(model.cons.join(", "));
  }
  const bestFor = card.createDiv({ cls: "model-comparison-best-for" });
  bestFor.style.cssText = "margin-top: 0.4em; padding-top: 0.4em; border-top: 1px solid var(--background-modifier-border); font-size: 0.8em; color: var(--text-muted);";
  bestFor.createEl("strong", { text: "Best for: " });
  bestFor.appendText(model.bestFor);
  return card;
}
function renderModelGroup(container, groupName, models, isLocal = false) {
  if (models.length === 0)
    return;
  const groupSection = container.createDiv({ cls: "model-comparison-group" });
  groupSection.style.cssText = "margin-bottom: 1.5em;";
  const groupHeader = groupSection.createEl("h5", { text: groupName });
  groupHeader.style.cssText = "margin: 0 0 0.75em 0; font-size: 0.95em; font-weight: 600;";
  for (const model of models) {
    renderCompactModelCard(groupSection, model, isLocal);
  }
}

// src/views/FirstLaunchSetupModal.ts
var FirstLaunchSetupModal = class extends import_obsidian9.Modal {
  settings;
  onComplete;
  constructor(app, _modelManager, settings, onComplete) {
    super(app);
    this.settings = settings;
    this.onComplete = onComplete;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-setup-modal");
    contentEl.createEl("h2", { text: "Manage AI Models" });
    contentEl.createEl("p", {
      text: "Choose how you want to use AI for idea enhancement:",
      cls: "ideatr-setup-description"
    });
    const downloadOption = contentEl.createEl("div", { cls: "ideatr-setup-option" });
    downloadOption.createEl("h3", { text: "Download AI Model" });
    const defaultModelManager = new ModelManager("phi-3.5-mini");
    const modelConfig = defaultModelManager.getModelConfig();
    const modelSizeGB = (modelConfig.sizeMB / 1024).toFixed(1);
    downloadOption.createEl("p", {
      text: `Download a local AI model (${modelSizeGB} GB for default model) for offline, free AI idea enhancement including classification, expansion, and more. Choose from multiple models optimized for different needs.`
    });
    downloadOption.createEl("ul", {
      cls: "ideatr-setup-features"
    }).innerHTML = `
            <li>\u2705 Works offline</li>
            <li>\u2705 Free to use</li>
            <li>\u2705 No API keys needed</li>
            <li>\u26A0\uFE0F Requires ${modelSizeGB} GB download (varies by model)</li>
        `;
    const downloadButton = downloadOption.createEl("button", {
      text: "Choose & Download Model",
      cls: "mod-cta"
    });
    downloadButton.addEventListener("click", () => this.handleDownloadOption());
    const apiKeyOption = contentEl.createEl("div", { cls: "ideatr-setup-option" });
    apiKeyOption.createEl("h3", { text: "Use My API Key" });
    apiKeyOption.createEl("p", {
      text: "Use a cloud AI provider (Anthropic, OpenAI, etc.) for better quality and faster responses."
    });
    apiKeyOption.createEl("ul", {
      cls: "ideatr-setup-features"
    }).innerHTML = `
            <li>\u2705 Better quality results</li>
            <li>\u2705 Faster responses</li>
            <li>\u2705 No local storage needed</li>
            <li>\u26A0\uFE0F Requires API key (paid)</li>
        `;
    const apiKeyButton = apiKeyOption.createEl("button", {
      text: "Enter API Key",
      cls: "mod-cta"
    });
    apiKeyButton.addEventListener("click", () => this.handleApiKeyOption());
    const skipOption = contentEl.createEl("div", { cls: "ideatr-setup-option" });
    skipOption.createEl("h3", { text: "Skip for Now" });
    skipOption.createEl("p", {
      text: "Continue without AI. You can set up AI later in settings."
    });
    const skipButton = skipOption.createEl("button", {
      text: "Skip Setup",
      cls: "mod-cancel"
    });
    skipButton.addEventListener("click", () => this.handleSkipOption());
  }
  async handleDownloadOption() {
    this.contentEl.empty();
    this.contentEl.createEl("h2", { text: "Choose AI Model" });
    this.contentEl.createEl("p", {
      text: "Select which model to download. You can change this later in settings.",
      cls: "model-selection-intro"
    });
    const modelManager = new ModelManager();
    const availableModels = modelManager.getAvailableModels();
    for (const modelKey of Object.keys(availableModels)) {
      const config = availableModels[modelKey];
      const container = this.contentEl.createDiv({ cls: "model-option-card" });
      const modelDisplay = localModelToDisplayInfo(config);
      renderCompactModelCard(container, modelDisplay, true);
      const selectButtonSetting = new import_obsidian9.Setting(container);
      selectButtonSetting.addButton((btn) => {
        btn.setButtonText(`Select ${config.name}`).setCta().onClick(async () => {
          const modelKeyTyped = modelKey;
          const compatibility = checkModelCompatibility(modelKey);
          if (!compatibility.isCompatible) {
            const systemInfo = getSystemInfoString();
            const message = `${compatibility.warning}

${compatibility.recommendation || ""}

${systemInfo}

Do you want to proceed anyway?`;
            const proceed = confirm(message);
            if (!proceed) {
              return;
            }
          } else if (compatibility.warning) {
            const systemInfo = getSystemInfoString();
            const proceed = confirm(`${compatibility.warning}

${compatibility.recommendation || ""}

${systemInfo}

Do you want to proceed?`);
            if (!proceed) {
              return;
            }
          }
          this.settings.localModel = modelKeyTyped;
          await this.startDownload(modelKey);
        });
        const controlEl = selectButtonSetting.controlEl;
        if (controlEl) {
          const statusIndicator = document.createElement("div");
          statusIndicator.className = "model-status-indicator";
          const checkingText = document.createElement("span");
          checkingText.className = "model-status-text";
          checkingText.textContent = "Checking...";
          statusIndicator.appendChild(checkingText);
          controlEl.insertBefore(statusIndicator, controlEl.firstChild);
          (async () => {
            try {
              const modelManager2 = new ModelManager(modelKey);
              const isDownloaded = await modelManager2.isModelDownloaded();
              if (isDownloaded) {
                const isValid = await modelManager2.verifyModelIntegrity();
                statusIndicator.innerHTML = "";
                const statusIcon = document.createElement("span");
                statusIcon.className = `model-status-icon ${isValid ? "model-status-valid" : "model-status-invalid"}`;
                statusIcon.title = isValid ? "File verified" : "File verification failed";
                statusIcon.innerHTML = isValid ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>';
                statusIndicator.appendChild(statusIcon);
              } else {
                statusIndicator.innerHTML = "";
              }
            } catch (error) {
              console.error("Error verifying model integrity:", error);
              statusIndicator.innerHTML = "";
              const statusIcon = document.createElement("span");
              statusIcon.className = "model-status-icon model-status-invalid";
              statusIcon.title = "Verification error";
              statusIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>';
              statusIndicator.appendChild(statusIcon);
            }
          })();
        }
      });
    }
  }
  async startDownload(modelKey) {
    const modelManager = new ModelManager(modelKey);
    const modal = new ModelDownloadModal(
      this.app,
      modelManager
    );
    const originalClose = modal.close.bind(modal);
    modal.close = () => {
      originalClose();
      modelManager.isModelDownloaded().then((downloaded) => {
        if (downloaded) {
          this.settings.setupCompleted = true;
          this.settings.modelDownloaded = true;
          this.settings.llmProvider = "llama";
          this.settings.modelPath = modelManager.getModelPath();
          this.onComplete();
          this.close();
        }
      });
    };
    modal.open();
  }
  handleApiKeyOption() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-setup-modal");
    contentEl.createEl("h2", { text: "Enter API Key" });
    contentEl.createEl("p", {
      text: "Enter your API key for a cloud AI provider. You can configure this later in settings.",
      cls: "ideatr-setup-description"
    });
    const providerContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
    providerContainer.createEl("label", { text: "Provider:", attr: { for: "ideatr-provider-select" } });
    const providerSelect = providerContainer.createEl("select", {
      attr: { id: "ideatr-provider-select" }
    });
    providerSelect.createEl("option", { text: "Anthropic (Claude)", attr: { value: "anthropic" } });
    providerSelect.createEl("option", { text: "OpenAI (GPT)", attr: { value: "openai" } });
    providerSelect.createEl("option", { text: "Skip for now", attr: { value: "none" } });
    const keyContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
    keyContainer.createEl("label", { text: "API Key:", attr: { for: "ideatr-api-key-input" } });
    const apiKeyInput = keyContainer.createEl("input", {
      attr: {
        id: "ideatr-api-key-input",
        type: "password",
        placeholder: "Enter your API key"
      }
    });
    contentEl.createEl("p", {
      text: "Note: API keys are stored in plain text in Obsidian settings. Keep your vault secure.",
      cls: "ideatr-help-text"
    });
    const buttonContainer = contentEl.createEl("div", { cls: "ideatr-button-container" });
    const saveButton = buttonContainer.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    saveButton.addEventListener("click", () => {
      const provider = providerSelect.value;
      const apiKey = apiKeyInput.value;
      if (provider === "none") {
        this.handleSkipOption();
        return;
      }
      if (!apiKey.trim()) {
        new import_obsidian9.Notice("Please enter an API key");
        return;
      }
      this.handleApiKeySubmit(apiKey, provider);
    });
    const backButton = buttonContainer.createEl("button", {
      text: "Back"
    });
    backButton.addEventListener("click", () => {
      this.onOpen();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.handleSkipOption();
    });
  }
  async handleApiKeySubmit(apiKey, provider) {
    if (!this.settings.cloudApiKeys) {
      this.settings.cloudApiKeys = {
        anthropic: "",
        openai: "",
        gemini: "",
        groq: "",
        openrouter: ""
      };
    }
    this.settings.cloudApiKeys[provider] = apiKey;
    this.settings.cloudProvider = provider;
    this.settings.preferCloud = true;
    this.settings.llmProvider = provider;
    this.settings.setupCompleted = true;
    new import_obsidian9.Notice("API key saved. Cloud AI setup complete!");
    this.onComplete();
    this.close();
  }
  handleSkipOption() {
    this.settings.setupCompleted = true;
    this.settings.llmProvider = "none";
    this.onComplete();
    this.close();
    new import_obsidian9.Notice("Setup skipped. You can configure AI later in settings.");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function isFirstLaunch(settings) {
  const hasAnyApiKey = settings.cloudApiKeys && Object.values(settings.cloudApiKeys).some((key) => key && key.length > 0);
  const hasLegacyApiKey = settings.cloudApiKey && settings.cloudApiKey.length > 0;
  return !settings.setupCompleted && !settings.modelDownloaded && !hasAnyApiKey && !hasLegacyApiKey;
}

// src/settings/sections/LLMSettingsSection.ts
init_HelpIcon();
var LLMSettingsSection = class extends BaseSettingsSection {
  /**
   * Get list of downloaded model keys
   */
  async getDownloadedModels() {
    const downloadedModels = [];
    for (const modelKey of Object.keys(MODELS)) {
      const modelManager = new ModelManager(modelKey);
      const isDownloaded = await modelManager.isModelDownloaded();
      if (isDownloaded) {
        downloadedModels.push(modelKey);
      }
    }
    return downloadedModels;
  }
  display(containerEl) {
    const titleContainer = containerEl.createDiv({ cls: "settings-section-title" });
    titleContainer.createEl("h2", { text: "AI Configuration" });
    const helpIcon = createHelpIcon(this.app, "getting-started", "Learn about AI Configuration");
    titleContainer.appendChild(helpIcon);
    new import_obsidian10.Setting(containerEl).setName("Local AI").setDesc("Use local AI model for idea enhancement (offline, free)").addToggle((toggle) => toggle.setValue(this.plugin.settings.llmProvider === "llama").onChange(async (value) => {
      this.plugin.settings.llmProvider = value ? "llama" : "none";
      await this.saveSettings();
      this.refresh();
    }));
    if (this.plugin.settings.llmProvider === "llama") {
      new import_obsidian10.Setting(containerEl).setName("Local AI Model").setDesc('Select which downloaded model to use. Use "Manage AI Models" to download new models or see all available options.').addDropdown((dropdown) => {
        dropdown.addOption("loading", "Loading...");
        dropdown.setValue("loading");
        dropdown.setDisabled(true);
        (async () => {
          const downloadedModels = await this.getDownloadedModels();
          const selectEl = dropdown.selectEl;
          selectEl.innerHTML = "";
          if (downloadedModels.length === 0) {
            dropdown.addOption("none", "No models downloaded");
            dropdown.setValue("none");
            dropdown.setDisabled(true);
            new import_obsidian10.Notice('No models downloaded. Use "Manage AI Models" to download a model.', 5e3);
          } else {
            for (const modelKey of downloadedModels) {
              const modelConfig2 = MODELS[modelKey];
              const displayText = `${modelConfig2.name} [${modelConfig2.badge}] (~${(modelConfig2.sizeMB / 1e3).toFixed(1)}GB, ${modelConfig2.ram} RAM)`;
              dropdown.addOption(modelKey, displayText);
            }
            const currentModel = this.plugin.settings.localModel || "phi-3.5-mini";
            const selectedModel = downloadedModels.includes(currentModel) ? currentModel : downloadedModels[0];
            dropdown.setValue(selectedModel);
            dropdown.setDisabled(false);
            if (selectedModel !== currentModel) {
              this.plugin.settings.localModel = selectedModel;
              this.saveSettings();
            }
          }
        })();
        dropdown.onChange(async (value) => {
          if (value === "none" || value === "loading")
            return;
          const modelKey = value;
          const compatibility = checkModelCompatibility(modelKey);
          if (!compatibility.isCompatible) {
            const systemInfo = getSystemInfoString();
            const message = `${compatibility.warning}

${compatibility.recommendation || ""}

${systemInfo}

Do you want to proceed anyway?`;
            const proceed = confirm(message);
            if (!proceed) {
              const downloadedModels = await this.getDownloadedModels();
              const previousModel = downloadedModels.includes(this.plugin.settings.localModel || "phi-3.5-mini") ? this.plugin.settings.localModel || "phi-3.5-mini" : downloadedModels[0];
              dropdown.setValue(previousModel);
              return;
            }
          } else if (compatibility.warning) {
            const systemInfo = getSystemInfoString();
            new import_obsidian10.Notice(`${compatibility.warning} ${systemInfo}`, 8e3);
          }
          this.plugin.settings.localModel = modelKey;
          await this.saveSettings();
          this.refresh();
        });
      });
      const modelManager = new ModelManager(this.plugin.settings.localModel || "phi-3.5-mini");
      const modelConfig = modelManager.getModelConfig();
      new import_obsidian10.Setting(containerEl).setName("Model Information").setDesc(`${modelConfig.description}
Size: ${(modelConfig.sizeMB / 1e3).toFixed(1)}GB | RAM: ${modelConfig.ram} | Quality: ${modelConfig.quality}/5 | Speed: ${modelConfig.speed}/5`).setDisabled(true);
      const modelStatusSetting = new import_obsidian10.Setting(containerEl).setName("Model Status").setDisabled(true);
      (async () => {
        const isDownloaded = await modelManager.isModelDownloaded();
        let statusText = isDownloaded ? `Model downloaded: ${modelConfig.name}` : "Model not downloaded";
        if (isDownloaded) {
          const isValid = await modelManager.verifyModelIntegrity();
          const statusDesc = modelStatusSetting.descEl;
          if (statusDesc) {
            statusDesc.empty();
            statusDesc.createSpan({ text: statusText + " " });
            const statusIcon = statusDesc.createSpan({
              cls: `model-status-icon ${isValid ? "model-status-valid" : "model-status-invalid"}`,
              attr: { title: isValid ? "File verified" : "File verification failed" }
            });
            statusIcon.innerHTML = isValid ? '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>';
          }
        } else {
          modelStatusSetting.setDesc(statusText);
        }
      })();
      new import_obsidian10.Setting(containerEl).setName("Manage AI Models").setDesc("Download a new model, switch between models, or configure cloud AI providers").addButton((button) => button.setButtonText("Manage AI Models").setCta().onClick(async () => {
        const modal = new FirstLaunchSetupModal(
          this.app,
          modelManager,
          this.plugin.settings,
          async () => {
            await this.saveSettings();
            this.refresh();
          }
        );
        modal.open();
      }));
      new import_obsidian10.Setting(containerEl).setName("Keep model loaded").setDesc("Keep the AI model loaded in memory (uses ~4GB RAM, but faster responses)").addToggle((toggle) => toggle.setValue(this.plugin.settings.keepModelLoaded).onChange(async (value) => {
        this.plugin.settings.keepModelLoaded = value;
        await this.saveSettings();
      }));
      new import_obsidian10.Setting(containerEl).setName("Preload on startup").setDesc("Automatically load the AI model when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.preloadOnStartup).onChange(async (value) => {
        this.plugin.settings.preloadOnStartup = value;
        await this.saveSettings();
      }));
      new import_obsidian10.Setting(containerEl).setName("Ensure LLM Ready").setDesc("Manually ensure the AI model is ready now. Not needed in most cases (model auto-starts when you use AI features), but helpful if: the model stopped unexpectedly, you want to test your configuration, or you prefer to preload before using features.").addButton((button) => button.setButtonText("Ensure Ready").setCta().onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Preparing...");
        try {
          await this.plugin.ensureLLMReady();
          new import_obsidian10.Notice("AI model is ready");
          setTimeout(() => {
            button.setDisabled(false);
            button.setButtonText("Ensure Ready");
          }, 2e3);
        } catch (error) {
          new import_obsidian10.Notice("Failed to prepare model. Check console for details.");
          button.setDisabled(false);
          button.setButtonText("Ensure Ready");
        }
      }));
    }
  }
};

// src/settings/sections/CloudAISettingsSection.ts
var import_obsidian11 = require("obsidian");

// node_modules/@anthropic-ai/sdk/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs
var uuid4 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2?.randomUUID) {
    uuid4 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/@anthropic-ai/sdk/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};

// node_modules/@anthropic-ai/sdk/core/error.mjs
var AnthropicError = class extends Error {
};
var APIError = class _APIError extends AnthropicError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("request-id");
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};

// node_modules/@anthropic-ai/sdk/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var isArray = (val) => (isArray = Array.isArray, isArray(val));
var isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new AnthropicError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new AnthropicError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs
var sleep = (ms) => new Promise((resolve4) => setTimeout(resolve4, ms));

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION = "0.71.0";

// node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch3) => {
  if (arch3 === "x32")
    return "x32";
  if (arch3 === "x86_64" || arch3 === "x64")
    return "x64";
  if (arch3 === "arm")
    return "arm";
  if (arch3 === "aarch64" || arch3 === "arm64")
    return "arm64";
  if (arch3)
    return `other:${arch3}`;
  return "unknown";
};
var normalizePlatform = (platform3) => {
  platform3 = platform3.toLowerCase();
  if (platform3.includes("ios"))
    return "iOS";
  if (platform3 === "android")
    return "Android";
  if (platform3 === "darwin")
    return "MacOS";
  if (platform3 === "win32")
    return "Windows";
  if (platform3 === "freebsd")
    return "FreeBSD";
  if (platform3 === "openbsd")
    return "OpenBSD";
  if (platform3 === "linux")
    return "Linux";
  if (platform3)
    return `Other:${platform3}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};

// node_modules/@anthropic-ai/sdk/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream3 = globalThis.ReadableStream;
  if (typeof ReadableStream3 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream3(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/@anthropic-ai/sdk/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_;
function encodeUTF8(str2) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/@anthropic-ai/sdk/internal/utils/log.mjs
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
};
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "x-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/@anthropic-ai/sdk/core/streaming.mjs
var _Stream_client;
var Stream = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (sse.event === "completion") {
            try {
              yield JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
          }
          if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
            try {
              yield JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
          }
          if (sse.event === "ping") {
            continue;
          }
          if (sse.event === "error") {
            throw new APIError(void 0, safeJSON(sse.data) ?? sse.data, void 0, response.headers);
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/@anthropic-ai/sdk/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}

// node_modules/@anthropic-ai/sdk/core/api-promise.mjs
var _APIPromise_client;
var APIPromise = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve4) => {
      resolve4(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet(this, _APIPromise_client, client, "f");
  }
  _thenUnwrap(transform) {
    return new _APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => addRequestID(transform(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client = /* @__PURE__ */ new WeakMap();

// node_modules/@anthropic-ai/sdk/core/pagination.mjs
var _AbstractPage_client;
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page3) {
    super(client, request, async (client2, props) => new Page3(client2, props.response, await defaultParseResponse(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.first_id = body.first_id || null;
    this.last_id = body.last_id || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    if (this.options.query?.["before_id"]) {
      const first_id = this.first_id;
      if (!first_id) {
        return null;
      }
      return {
        ...this.options,
        query: {
          ...maybeObj(this.options.query),
          before_id: first_id
        }
      };
    }
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after_id: cursor
      }
    };
  }
};
var PageCursor = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.next_page = body.next_page || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.next_page;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        page: cursor
      }
    };
  }
};

// node_modules/@anthropic-ai/sdk/internal/uploads.mjs
var checkFileSupport = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var multipartFormRequestOptions = async (opts, fetch3) => {
  return { ...opts, body: await createForm(opts.body, fetch3) };
};
var supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch3 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch3);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch3 ? fetch3.Response : (await fetch3("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch3, promise);
  return promise;
}
var createForm = async (body, fetch3) => {
  if (!await supportsFormData(fetch3)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var isNamedBlob = (value) => value instanceof Blob && "name" in value;
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    let options = {};
    const contentType = value.headers.get("Content-Type");
    if (contentType) {
      options = { type: contentType };
    }
    form.append(key, makeFile([await value.blob()], getName(value), options));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, makeFile([value], getName(value), { type: value.type }));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/@anthropic-ai/sdk/internal/to-file.mjs
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  name || (name = getName(value));
  if (isFileLike(value)) {
    if (value instanceof File && name == null && options == null) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], name ?? value.name, {
      type: value.type,
      lastModified: value.lastModified,
      ...options
    });
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}

// node_modules/@anthropic-ai/sdk/core/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/@anthropic-ai/sdk/internal/headers.mjs
var brand_privateNullableHeaders = Symbol.for("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/@anthropic-ai/sdk/internal/utils/path.mjs
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path9(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path10 = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path10.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new AnthropicError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path10}
${underline}`);
  }
  return path10;
};
var path3 = /* @__PURE__ */ createPathTagFunction(encodeURIPath);

// node_modules/@anthropic-ai/sdk/resources/beta/files.mjs
var Files = class extends APIResource {
  /**
   * List Files
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fileMetadata of client.beta.files.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/files", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete File
   *
   * @example
   * ```ts
   * const deletedFile = await client.beta.files.delete(
   *   'file_id',
   * );
   * ```
   */
  delete(fileID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.delete(path3`/v1/files/${fileID}`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Download File
   *
   * @example
   * ```ts
   * const response = await client.beta.files.download(
   *   'file_id',
   * );
   *
   * const content = await response.blob();
   * console.log(content);
   * ```
   */
  download(fileID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path3`/v1/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([
        {
          "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString(),
          Accept: "application/binary"
        },
        options?.headers
      ]),
      __binaryResponse: true
    });
  }
  /**
   * Get File Metadata
   *
   * @example
   * ```ts
   * const fileMetadata =
   *   await client.beta.files.retrieveMetadata('file_id');
   * ```
   */
  retrieveMetadata(fileID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path3`/v1/files/${fileID}`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Upload File
   *
   * @example
   * ```ts
   * const fileMetadata = await client.beta.files.upload({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  upload(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/files", multipartFormRequestOptions({
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    }, this._client));
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   *
   * @example
   * ```ts
   * const betaModelInfo = await client.beta.models.retrieve(
   *   'model_id',
   * );
   * ```
   */
  retrieve(modelID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path3`/v1/models/${modelID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaModelInfo of client.beta.models.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/models?beta=true", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/internal/constants.mjs
var MODEL_NONSTREAMING_TOKENS = {
  "claude-opus-4-20250514": 8192,
  "claude-opus-4-0": 8192,
  "claude-4-opus-20250514": 8192,
  "anthropic.claude-opus-4-20250514-v1:0": 8192,
  "claude-opus-4@20250514": 8192,
  "claude-opus-4-1-20250805": 8192,
  "anthropic.claude-opus-4-1-20250805-v1:0": 8192,
  "claude-opus-4-1@20250805": 8192
};

// node_modules/@anthropic-ai/sdk/lib/beta-parser.mjs
function maybeParseBetaMessage(message, params) {
  if (!params || !("parse" in (params.output_format ?? {}))) {
    return {
      ...message,
      content: message.content.map((block) => {
        if (block.type === "text") {
          return {
            ...block,
            parsed: null
          };
        }
        return block;
      }),
      parsed_output: null
    };
  }
  return parseBetaMessage(message, params);
}
function parseBetaMessage(message, params) {
  let firstParsed = null;
  const content = message.content.map((block) => {
    if (block.type === "text") {
      const parsed = parseBetaOutputFormat(params, block.text);
      if (firstParsed === null) {
        firstParsed = parsed;
      }
      return {
        ...block,
        parsed
      };
    }
    return block;
  });
  return {
    ...message,
    content,
    parsed_output: firstParsed
  };
}
function parseBetaOutputFormat(params, content) {
  if (params.output_format?.type !== "json_schema") {
    return null;
  }
  try {
    if ("parse" in params.output_format) {
      return params.output_format.parse(content);
    }
    return JSON.parse(content);
  } catch (error) {
    throw new AnthropicError(`Failed to parse structured output: ${error}`);
  }
}

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize = (input) => {
  let current = 0;
  let tokens = [];
  while (current < input.length) {
    let char = input[current];
    if (char === "\\") {
      current++;
      continue;
    }
    if (char === "{") {
      tokens.push({
        type: "brace",
        value: "{"
      });
      current++;
      continue;
    }
    if (char === "}") {
      tokens.push({
        type: "brace",
        value: "}"
      });
      current++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "paren",
        value: "["
      });
      current++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "paren",
        value: "]"
      });
      current++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "separator",
        value: ":"
      });
      current++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "delimiter",
        value: ","
      });
      current++;
      continue;
    }
    if (char === '"') {
      let value = "";
      let danglingQuote = false;
      char = input[++current];
      while (char !== '"') {
        if (current === input.length) {
          danglingQuote = true;
          break;
        }
        if (char === "\\") {
          current++;
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          value += char + input[current];
          char = input[++current];
        } else {
          value += char;
          char = input[++current];
        }
      }
      char = input[++current];
      if (!danglingQuote) {
        tokens.push({
          type: "string",
          value
        });
      }
      continue;
    }
    let WHITESPACE = /\s/;
    if (char && WHITESPACE.test(char)) {
      current++;
      continue;
    }
    let NUMBERS = /[0-9]/;
    if (char && NUMBERS.test(char) || char === "-" || char === ".") {
      let value = "";
      if (char === "-") {
        value += char;
        char = input[++current];
      }
      while (char && NUMBERS.test(char) || char === ".") {
        value += char;
        char = input[++current];
      }
      tokens.push({
        type: "number",
        value
      });
      continue;
    }
    let LETTERS = /[a-z]/i;
    if (char && LETTERS.test(char)) {
      let value = "";
      while (char && LETTERS.test(char)) {
        if (current === input.length) {
          break;
        }
        value += char;
        char = input[++current];
      }
      if (value == "true" || value == "false" || value === "null") {
        tokens.push({
          type: "name",
          value
        });
      } else {
        current++;
        continue;
      }
      continue;
    }
    current++;
  }
  return tokens;
};
var strip = (tokens) => {
  if (tokens.length === 0) {
    return tokens;
  }
  let lastToken = tokens[tokens.length - 1];
  switch (lastToken.type) {
    case "separator":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
    case "number":
      let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
      if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
    case "string":
      let tokenBeforeTheLastToken = tokens[tokens.length - 2];
      if (tokenBeforeTheLastToken?.type === "delimiter") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      } else if (tokenBeforeTheLastToken?.type === "brace" && tokenBeforeTheLastToken.value === "{") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
      break;
    case "delimiter":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
  }
  return tokens;
};
var unstrip = (tokens) => {
  let tail = [];
  tokens.map((token) => {
    if (token.type === "brace") {
      if (token.value === "{") {
        tail.push("}");
      } else {
        tail.splice(tail.lastIndexOf("}"), 1);
      }
    }
    if (token.type === "paren") {
      if (token.value === "[") {
        tail.push("]");
      } else {
        tail.splice(tail.lastIndexOf("]"), 1);
      }
    }
  });
  if (tail.length > 0) {
    tail.reverse().map((item) => {
      if (item === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
      } else if (item === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
      }
    });
  }
  return tokens;
};
var generate = (tokens) => {
  let output = "";
  tokens.map((token) => {
    switch (token.type) {
      case "string":
        output += '"' + token.value + '"';
        break;
      default:
        output += token.value;
        break;
    }
  });
  return output;
};
var partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
var _BetaMessageStream_instances;
var _BetaMessageStream_currentMessageSnapshot;
var _BetaMessageStream_params;
var _BetaMessageStream_connectedPromise;
var _BetaMessageStream_resolveConnectedPromise;
var _BetaMessageStream_rejectConnectedPromise;
var _BetaMessageStream_endPromise;
var _BetaMessageStream_resolveEndPromise;
var _BetaMessageStream_rejectEndPromise;
var _BetaMessageStream_listeners;
var _BetaMessageStream_ended;
var _BetaMessageStream_errored;
var _BetaMessageStream_aborted;
var _BetaMessageStream_catchingPromiseCreated;
var _BetaMessageStream_response;
var _BetaMessageStream_request_id;
var _BetaMessageStream_getFinalMessage;
var _BetaMessageStream_getFinalText;
var _BetaMessageStream_handleError;
var _BetaMessageStream_beginRequest;
var _BetaMessageStream_addStreamEvent;
var _BetaMessageStream_endRequest;
var _BetaMessageStream_accumulateMessage;
var JSON_BUF_PROPERTY = "__json_buf";
function tracksToolInput(content) {
  return content.type === "tool_use" || content.type === "server_tool_use" || content.type === "mcp_tool_use";
}
var BetaMessageStream = class _BetaMessageStream {
  constructor(params) {
    _BetaMessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
    _BetaMessageStream_params.set(this, null);
    this.controller = new AbortController();
    _BetaMessageStream_connectedPromise.set(this, void 0);
    _BetaMessageStream_resolveConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_rejectConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_endPromise.set(this, void 0);
    _BetaMessageStream_resolveEndPromise.set(this, () => {
    });
    _BetaMessageStream_rejectEndPromise.set(this, () => {
    });
    _BetaMessageStream_listeners.set(this, {});
    _BetaMessageStream_ended.set(this, false);
    _BetaMessageStream_errored.set(this, false);
    _BetaMessageStream_aborted.set(this, false);
    _BetaMessageStream_catchingPromiseCreated.set(this, false);
    _BetaMessageStream_response.set(this, void 0);
    _BetaMessageStream_request_id.set(this, void 0);
    _BetaMessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet(this, _BetaMessageStream_errored, true, "f");
      if (isAbortError(error)) {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet(this, _BetaMessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet(this, _BetaMessageStream_connectedPromise, new Promise((resolve4, reject) => {
      __classPrivateFieldSet(this, _BetaMessageStream_resolveConnectedPromise, resolve4, "f");
      __classPrivateFieldSet(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _BetaMessageStream_endPromise, new Promise((resolve4, reject) => {
      __classPrivateFieldSet(this, _BetaMessageStream_resolveEndPromise, resolve4, "f");
      __classPrivateFieldSet(this, _BetaMessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _BetaMessageStream_endPromise, "f").catch(() => {
    });
    __classPrivateFieldSet(this, _BetaMessageStream_params, params, "f");
  }
  get response() {
    return __classPrivateFieldGet(this, _BetaMessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet(this, _BetaMessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _BetaMessageStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new _BetaMessageStream(params);
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    __classPrivateFieldSet(runner, _BetaMessageStream_params, { ...params, stream: true }, "f");
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet(this, _BetaMessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
      const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
      this._connected(response);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _BetaMessageStream_response, response, "f");
    __classPrivateFieldSet(this, _BetaMessageStream_request_id, response?.headers.get("request-id"), "f");
    __classPrivateFieldGet(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _BetaMessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _BetaMessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _BetaMessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve4, reject) => {
      __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve4);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _BetaMessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   * If structured outputs were used, this will be a ParsedMessage with a `parsed` field.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _BetaMessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet(this, _BetaMessageStream_ended, true, "f");
      __classPrivateFieldGet(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
      this._connected(null);
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_params = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
  }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, content.citations ?? []);
            }
            break;
          }
          case "input_json_delta": {
            if (tracksToolInput(content) && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(maybeParseBetaMessage(messageSnapshot, __classPrivateFieldGet(this, _BetaMessageStream_params, "f")), true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
    return maybeParseBetaMessage(snapshot, __classPrivateFieldGet(this, _BetaMessageStream_params, "f"));
  }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
    let snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.container = event.delta.container;
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        snapshot.context_management = event.context_management;
        if (event.usage.input_tokens != null) {
          snapshot.usage.input_tokens = event.usage.input_tokens;
        }
        if (event.usage.cache_creation_input_tokens != null) {
          snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
        }
        if (event.usage.cache_read_input_tokens != null) {
          snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
        }
        if (event.usage.server_tool_use != null) {
          snapshot.usage.server_tool_use = event.usage.server_tool_use;
        }
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                text: (snapshotContent.text || "") + event.delta.text
              };
            }
            break;
          }
          case "citations_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                citations: [...snapshotContent.citations ?? [], event.delta.citation]
              };
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent && tracksToolInput(snapshotContent)) {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
              jsonBuf += event.delta.partial_json;
              const newContent = { ...snapshotContent };
              Object.defineProperty(newContent, JSON_BUF_PROPERTY, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                try {
                  newContent.input = partialParse(jsonBuf);
                } catch (err) {
                  const error = new AnthropicError(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${err}. JSON: ${jsonBuf}`);
                  __classPrivateFieldGet(this, _BetaMessageStream_handleError, "f").call(this, error);
                }
              }
              snapshot.content[event.index] = newContent;
            }
            break;
          }
          case "thinking_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                thinking: snapshotContent.thinking + event.delta.thinking
              };
            }
            break;
          }
          case "signature_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                signature: event.delta.signature
              };
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve4, reject) => readQueue.push({ resolve: resolve4, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever(x) {
}

// node_modules/@anthropic-ai/sdk/lib/tools/CompactionControl.mjs
var DEFAULT_TOKEN_THRESHOLD = 1e5;
var DEFAULT_SUMMARY_PROMPT = `You have been working on the task described above but have not yet completed it. Write a continuation summary that will allow you (or another instance of yourself) to resume work efficiently in a future context window where the conversation history will be replaced with this summary. Your summary should be structured, concise, and actionable. Include:
1. Task Overview
The user's core request and success criteria
Any clarifications or constraints they specified
2. Current State
What has been completed so far
Files created, modified, or analyzed (with paths if relevant)
Key outputs or artifacts produced
3. Important Discoveries
Technical constraints or requirements uncovered
Decisions made and their rationale
Errors encountered and how they were resolved
What approaches were tried that didn't work (and why)
4. Next Steps
Specific actions needed to complete the task
Any blockers or open questions to resolve
Priority order if multiple steps remain
5. Context to Preserve
User preferences or style requirements
Domain-specific details that aren't obvious
Any promises made to the user
Be concise but complete\u2014err on the side of including information that would prevent duplicate work or repeated mistakes. Write in a way that enables immediate resumption of the task.
Wrap your summary in <summary></summary> tags.`;

// node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs
var _BetaToolRunner_instances;
var _BetaToolRunner_consumed;
var _BetaToolRunner_mutated;
var _BetaToolRunner_state;
var _BetaToolRunner_options;
var _BetaToolRunner_message;
var _BetaToolRunner_toolResponse;
var _BetaToolRunner_completion;
var _BetaToolRunner_iterationCount;
var _BetaToolRunner_checkAndCompact;
var _BetaToolRunner_generateToolResponse;
function promiseWithResolvers() {
  let resolve4;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve4 = res;
    reject = rej;
  });
  return { promise, resolve: resolve4, reject };
}
var BetaToolRunner = class {
  constructor(client, params, options) {
    _BetaToolRunner_instances.add(this);
    this.client = client;
    _BetaToolRunner_consumed.set(this, false);
    _BetaToolRunner_mutated.set(this, false);
    _BetaToolRunner_state.set(this, void 0);
    _BetaToolRunner_options.set(this, void 0);
    _BetaToolRunner_message.set(this, void 0);
    _BetaToolRunner_toolResponse.set(this, void 0);
    _BetaToolRunner_completion.set(this, void 0);
    _BetaToolRunner_iterationCount.set(this, 0);
    __classPrivateFieldSet(this, _BetaToolRunner_state, {
      params: {
        // You can't clone the entire params since there are functions as handlers.
        // You also don't really need to clone params.messages, but it probably will prevent a foot gun
        // somewhere.
        ...params,
        messages: structuredClone(params.messages)
      }
    }, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_options, {
      ...options,
      headers: buildHeaders([{ "x-stainless-helper": "BetaToolRunner" }, options?.headers])
    }, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
  }
  async *[(_BetaToolRunner_consumed = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_mutated = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_state = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_options = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_message = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_toolResponse = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_completion = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_iterationCount = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_instances = /* @__PURE__ */ new WeakSet(), _BetaToolRunner_checkAndCompact = async function _BetaToolRunner_checkAndCompact2() {
    const compactionControl = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.compactionControl;
    if (!compactionControl || !compactionControl.enabled) {
      return false;
    }
    let tokensUsed = 0;
    if (__classPrivateFieldGet(this, _BetaToolRunner_message, "f") !== void 0) {
      try {
        const message = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
        const totalInputTokens = message.usage.input_tokens + (message.usage.cache_creation_input_tokens ?? 0) + (message.usage.cache_read_input_tokens ?? 0);
        tokensUsed = totalInputTokens + message.usage.output_tokens;
      } catch {
        return false;
      }
    }
    const threshold = compactionControl.contextTokenThreshold ?? DEFAULT_TOKEN_THRESHOLD;
    if (tokensUsed < threshold) {
      return false;
    }
    const model = compactionControl.model ?? __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.model;
    const summaryPrompt = compactionControl.summaryPrompt ?? DEFAULT_SUMMARY_PROMPT;
    const messages = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages;
    if (messages[messages.length - 1].role === "assistant") {
      const lastMessage = messages[messages.length - 1];
      if (Array.isArray(lastMessage.content)) {
        const nonToolBlocks = lastMessage.content.filter((block) => block.type !== "tool_use");
        if (nonToolBlocks.length === 0) {
          messages.pop();
        } else {
          lastMessage.content = nonToolBlocks;
        }
      }
    }
    const response = await this.client.beta.messages.create({
      model,
      messages: [
        ...messages,
        {
          role: "user",
          content: [
            {
              type: "text",
              text: summaryPrompt
            }
          ]
        }
      ],
      max_tokens: __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_tokens
    }, {
      headers: { "x-stainless-helper": "compaction" }
    });
    if (response.content[0]?.type !== "text") {
      throw new AnthropicError("Expected text response for compaction");
    }
    __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages = [
      {
        role: "user",
        content: response.content
      }
    ];
    return true;
  }, Symbol.asyncIterator)]() {
    var _a5;
    if (__classPrivateFieldGet(this, _BetaToolRunner_consumed, "f")) {
      throw new AnthropicError("Cannot iterate over a consumed stream");
    }
    __classPrivateFieldSet(this, _BetaToolRunner_consumed, true, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_mutated, true, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, void 0, "f");
    try {
      while (true) {
        let stream;
        try {
          if (__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_iterations && __classPrivateFieldGet(this, _BetaToolRunner_iterationCount, "f") >= __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_iterations) {
            break;
          }
          __classPrivateFieldSet(this, _BetaToolRunner_mutated, false, "f");
          __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, void 0, "f");
          __classPrivateFieldSet(this, _BetaToolRunner_iterationCount, (_a5 = __classPrivateFieldGet(this, _BetaToolRunner_iterationCount, "f"), _a5++, _a5), "f");
          __classPrivateFieldSet(this, _BetaToolRunner_message, void 0, "f");
          const { max_iterations, compactionControl, ...params } = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params;
          if (params.stream) {
            stream = this.client.beta.messages.stream({ ...params }, __classPrivateFieldGet(this, _BetaToolRunner_options, "f"));
            __classPrivateFieldSet(this, _BetaToolRunner_message, stream.finalMessage(), "f");
            __classPrivateFieldGet(this, _BetaToolRunner_message, "f").catch(() => {
            });
            yield stream;
          } else {
            __classPrivateFieldSet(this, _BetaToolRunner_message, this.client.beta.messages.create({ ...params, stream: false }, __classPrivateFieldGet(this, _BetaToolRunner_options, "f")), "f");
            yield __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
          }
          const isCompacted = await __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_checkAndCompact).call(this);
          if (!isCompacted) {
            if (!__classPrivateFieldGet(this, _BetaToolRunner_mutated, "f")) {
              const { role, content } = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
              __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.push({ role, content });
            }
            const toolMessage = await __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.at(-1));
            if (toolMessage) {
              __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.push(toolMessage);
            } else if (!__classPrivateFieldGet(this, _BetaToolRunner_mutated, "f")) {
              break;
            }
          }
        } finally {
          if (stream) {
            stream.abort();
          }
        }
      }
      if (!__classPrivateFieldGet(this, _BetaToolRunner_message, "f")) {
        throw new AnthropicError("ToolRunner concluded without a message from the server");
      }
      __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").resolve(await __classPrivateFieldGet(this, _BetaToolRunner_message, "f"));
    } catch (error) {
      __classPrivateFieldSet(this, _BetaToolRunner_consumed, false, "f");
      __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").promise.catch(() => {
      });
      __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").reject(error);
      __classPrivateFieldSet(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
      throw error;
    }
  }
  setMessagesParams(paramsOrMutator) {
    if (typeof paramsOrMutator === "function") {
      __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params = paramsOrMutator(__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params);
    } else {
      __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params = paramsOrMutator;
    }
    __classPrivateFieldSet(this, _BetaToolRunner_mutated, true, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, void 0, "f");
  }
  /**
   * Get the tool response for the last message from the assistant.
   * Avoids redundant tool executions by caching results.
   *
   * @returns A promise that resolves to a BetaMessageParam containing tool results, or null if no tools need to be executed
   *
   * @example
   * const toolResponse = await runner.generateToolResponse();
   * if (toolResponse) {
   *   console.log('Tool results:', toolResponse.content);
   * }
   */
  async generateToolResponse() {
    const message = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f") ?? this.params.messages.at(-1);
    if (!message) {
      return null;
    }
    return __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, message);
  }
  /**
   * Wait for the async iterator to complete. This works even if the async iterator hasn't yet started, and
   * will wait for an instance to start and go to completion.
   *
   * @returns A promise that resolves to the final BetaMessage when the iterator completes
   *
   * @example
   * // Start consuming the iterator
   * for await (const message of runner) {
   *   console.log('Message:', message.content);
   * }
   *
   * // Meanwhile, wait for completion from another part of the code
   * const finalMessage = await runner.done();
   * console.log('Final response:', finalMessage.content);
   */
  done() {
    return __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").promise;
  }
  /**
   * Returns a promise indicating that the stream is done. Unlike .done(), this will eagerly read the stream:
   * * If the iterator has not been consumed, consume the entire iterator and return the final message from the
   * assistant.
   * * If the iterator has been consumed, waits for it to complete and returns the final message.
   *
   * @returns A promise that resolves to the final BetaMessage from the conversation
   * @throws {AnthropicError} If no messages were processed during the conversation
   *
   * @example
   * const finalMessage = await runner.runUntilDone();
   * console.log('Final response:', finalMessage.content);
   */
  async runUntilDone() {
    if (!__classPrivateFieldGet(this, _BetaToolRunner_consumed, "f")) {
      for await (const _ of this) {
      }
    }
    return this.done();
  }
  /**
   * Get the current parameters being used by the ToolRunner.
   *
   * @returns A readonly view of the current ToolRunnerParams
   *
   * @example
   * const currentParams = runner.params;
   * console.log('Current model:', currentParams.model);
   * console.log('Message count:', currentParams.messages.length);
   */
  get params() {
    return __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params;
  }
  /**
   * Add one or more messages to the conversation history.
   *
   * @param messages - One or more BetaMessageParam objects to add to the conversation
   *
   * @example
   * runner.pushMessages(
   *   { role: 'user', content: 'Also, what about the weather in NYC?' }
   * );
   *
   * @example
   * // Adding multiple messages
   * runner.pushMessages(
   *   { role: 'user', content: 'What about NYC?' },
   *   { role: 'user', content: 'And Boston?' }
   * );
   */
  pushMessages(...messages) {
    this.setMessagesParams((params) => ({
      ...params,
      messages: [...params.messages, ...messages]
    }));
  }
  /**
   * Makes the ToolRunner directly awaitable, equivalent to calling .runUntilDone()
   * This allows using `await runner` instead of `await runner.runUntilDone()`
   */
  then(onfulfilled, onrejected) {
    return this.runUntilDone().then(onfulfilled, onrejected);
  }
};
_BetaToolRunner_generateToolResponse = async function _BetaToolRunner_generateToolResponse2(lastMessage) {
  if (__classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f") !== void 0) {
    return __classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f");
  }
  __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, generateToolResponse(__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params, lastMessage), "f");
  return __classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f");
};
async function generateToolResponse(params, lastMessage = params.messages.at(-1)) {
  if (!lastMessage || lastMessage.role !== "assistant" || !lastMessage.content || typeof lastMessage.content === "string") {
    return null;
  }
  const toolUseBlocks = lastMessage.content.filter((content) => content.type === "tool_use");
  if (toolUseBlocks.length === 0) {
    return null;
  }
  const toolResults = await Promise.all(toolUseBlocks.map(async (toolUse) => {
    const tool = params.tools.find((t) => ("name" in t ? t.name : t.mcp_server_name) === toolUse.name);
    if (!tool || !("run" in tool)) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: `Error: Tool '${toolUse.name}' not found`,
        is_error: true
      };
    }
    try {
      let input = toolUse.input;
      if ("parse" in tool && tool.parse) {
        input = tool.parse(input);
      }
      const result = await tool.run(input);
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: result
      };
    } catch (error) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: `Error: ${error instanceof Error ? error.message : String(error)}`,
        is_error: true
      };
    }
  }));
  return {
    role: "user",
    content: toolResults
  };
}

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder = class _JSONLDecoder {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  async *decoder() {
    const lineDecoder = new LineDecoder();
    for await (const chunk of this.iterator) {
      for (const line of lineDecoder.decode(chunk)) {
        yield JSON.parse(line);
      }
    }
    for (const line of lineDecoder.flush()) {
      yield JSON.parse(line);
    }
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(response, controller) {
    if (!response.body) {
      controller.abort();
      if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
        throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
      }
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    return new _JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.create({
   *     requests: [
   *       {
   *         custom_id: 'my-custom-id-1',
   *         params: {
   *           max_tokens: 1024,
   *           messages: [
   *             { content: 'Hello, world', role: 'user' },
   *           ],
   *           model: 'claude-sonnet-4-5-20250929',
   *         },
   *       },
   *     ],
   *   });
   * ```
   */
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/batches?beta=true", {
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.retrieve(
   *     'message_batch_id',
   *   );
   * ```
   */
  retrieve(messageBatchID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path3`/v1/messages/batches/${messageBatchID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaMessageBatch of client.beta.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/messages/batches?beta=true", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaDeletedMessageBatch =
   *   await client.beta.messages.batches.delete(
   *     'message_batch_id',
   *   );
   * ```
   */
  delete(messageBatchID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.delete(path3`/v1/messages/batches/${messageBatchID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.cancel(
   *     'message_batch_id',
   *   );
   * ```
   */
  cancel(messageBatchID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.post(path3`/v1/messages/batches/${messageBatchID}/cancel?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatchIndividualResponse =
   *   await client.beta.messages.batches.results(
   *     'message_batch_id',
   *   );
   * ```
   */
  async results(messageBatchID, params = {}, options) {
    const batch = await this.retrieve(messageBatchID);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    const { betas } = params ?? {};
    return this._client.get(batch.results_url, {
      ...options,
      headers: buildHeaders([
        {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          Accept: "application/binary"
        },
        options?.headers
      ]),
      stream: true,
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-7-sonnet-latest": "February 19th, 2026",
  "claude-3-7-sonnet-20250219": "February 19th, 2026"
};
var Messages = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches(this._client);
  }
  create(params, options) {
    const { betas, ...body } = params;
    if (body.model in DEPRECATED_MODELS) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    let timeout = this._client._options.timeout;
    if (!body.stream && timeout == null) {
      const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? void 0;
      timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
    }
    return this._client.post("/v1/messages?beta=true", {
      body,
      timeout: timeout ?? 6e5,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ]),
      stream: params.stream ?? false
    });
  }
  /**
   * Send a structured list of input messages with text and/or image content, along with an expected `output_format` and
   * the response will be automatically parsed and available in the `parsed` property of the message.
   *
   * @example
   * ```ts
   * const message = await client.beta.messages.parse({
   *   model: 'claude-3-5-sonnet-20241022',
   *   max_tokens: 1024,
   *   messages: [{ role: 'user', content: 'What is 2+2?' }],
   *   output_format: zodOutputFormat(z.object({ answer: z.number() }), 'math'),
   * });
   *
   * console.log(message.parsed?.answer); // 4
   * ```
   */
  parse(params, options) {
    options = {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...params.betas ?? [], "structured-outputs-2025-11-13"].toString() },
        options?.headers
      ])
    };
    return this.create(params, options).then((message) => parseBetaMessage(message, params));
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return BetaMessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const betaMessageTokensCount =
   *   await client.beta.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-opus-4-5-20251101',
   *   });
   * ```
   */
  countTokens(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "token-counting-2024-11-01"].toString() },
        options?.headers
      ])
    });
  }
  toolRunner(body, options) {
    return new BetaToolRunner(this._client, body, options);
  }
};
Messages.Batches = Batches;
Messages.BetaToolRunner = BetaToolRunner;

// node_modules/@anthropic-ai/sdk/resources/beta/skills/versions.mjs
var Versions = class extends APIResource {
  /**
   * Create Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.create(
   *   'skill_id',
   * );
   * ```
   */
  create(skillID, params = {}, options) {
    const { betas, ...body } = params ?? {};
    return this._client.post(path3`/v1/skills/${skillID}/versions?beta=true`, multipartFormRequestOptions({
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.retrieve(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  retrieve(version, params, options) {
    const { skill_id, betas } = params;
    return this._client.get(path3`/v1/skills/${skill_id}/versions/${version}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * List Skill Versions
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const versionListResponse of client.beta.skills.versions.list(
   *   'skill_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(skillID, params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList(path3`/v1/skills/${skillID}/versions?beta=true`, PageCursor, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.delete(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  delete(version, params, options) {
    const { skill_id, betas } = params;
    return this._client.delete(path3`/v1/skills/${skill_id}/versions/${version}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/skills/skills.mjs
var Skills = class extends APIResource {
  constructor() {
    super(...arguments);
    this.versions = new Versions(this._client);
  }
  /**
   * Create Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.create();
   * ```
   */
  create(params = {}, options) {
    const { betas, ...body } = params ?? {};
    return this._client.post("/v1/skills?beta=true", multipartFormRequestOptions({
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.retrieve('skill_id');
   * ```
   */
  retrieve(skillID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path3`/v1/skills/${skillID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * List Skills
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const skillListResponse of client.beta.skills.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/skills?beta=true", PageCursor, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.delete('skill_id');
   * ```
   */
  delete(skillID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.delete(path3`/v1/skills/${skillID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
};
Skills.Versions = Versions;

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.models = new Models(this._client);
    this.messages = new Messages(this._client);
    this.files = new Files(this._client);
    this.skills = new Skills(this._client);
  }
};
Beta.Models = Models;
Beta.Messages = Messages;
Beta.Files = Files;
Beta.Skills = Skills;

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions = class extends APIResource {
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/complete", {
      body,
      timeout: this._client._options.timeout ?? 6e5,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ]),
      stream: params.stream ?? false
    });
  }
};

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
var _MessageStream_instances;
var _MessageStream_currentMessageSnapshot;
var _MessageStream_connectedPromise;
var _MessageStream_resolveConnectedPromise;
var _MessageStream_rejectConnectedPromise;
var _MessageStream_endPromise;
var _MessageStream_resolveEndPromise;
var _MessageStream_rejectEndPromise;
var _MessageStream_listeners;
var _MessageStream_ended;
var _MessageStream_errored;
var _MessageStream_aborted;
var _MessageStream_catchingPromiseCreated;
var _MessageStream_response;
var _MessageStream_request_id;
var _MessageStream_getFinalMessage;
var _MessageStream_getFinalText;
var _MessageStream_handleError;
var _MessageStream_beginRequest;
var _MessageStream_addStreamEvent;
var _MessageStream_endRequest;
var _MessageStream_accumulateMessage;
var JSON_BUF_PROPERTY2 = "__json_buf";
function tracksToolInput2(content) {
  return content.type === "tool_use" || content.type === "server_tool_use";
}
var MessageStream = class _MessageStream {
  constructor() {
    _MessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _MessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _MessageStream_connectedPromise.set(this, void 0);
    _MessageStream_resolveConnectedPromise.set(this, () => {
    });
    _MessageStream_rejectConnectedPromise.set(this, () => {
    });
    _MessageStream_endPromise.set(this, void 0);
    _MessageStream_resolveEndPromise.set(this, () => {
    });
    _MessageStream_rejectEndPromise.set(this, () => {
    });
    _MessageStream_listeners.set(this, {});
    _MessageStream_ended.set(this, false);
    _MessageStream_errored.set(this, false);
    _MessageStream_aborted.set(this, false);
    _MessageStream_catchingPromiseCreated.set(this, false);
    _MessageStream_response.set(this, void 0);
    _MessageStream_request_id.set(this, void 0);
    _MessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet(this, _MessageStream_errored, true, "f");
      if (isAbortError(error)) {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet(this, _MessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve4, reject) => {
      __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve4, "f");
      __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve4, reject) => {
      __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve4, "f");
      __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _MessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _MessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet(this, _MessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet(this, _MessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet(this, _MessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _MessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new _MessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet(this, _MessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
      this._connected(response);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _MessageStream_response, response, "f");
    __classPrivateFieldSet(this, _MessageStream_request_id, response?.headers.get("request-id"), "f");
    __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _MessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _MessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _MessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve4, reject) => {
      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve4);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _MessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _MessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet(this, _MessageStream_ended, true, "f");
      __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      this._connected(null);
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, void 0, "f");
  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, content.citations ?? []);
            }
            break;
          }
          case "input_json_delta": {
            if (tracksToolInput2(content) && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
    let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        if (event.usage.input_tokens != null) {
          snapshot.usage.input_tokens = event.usage.input_tokens;
        }
        if (event.usage.cache_creation_input_tokens != null) {
          snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
        }
        if (event.usage.cache_read_input_tokens != null) {
          snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
        }
        if (event.usage.server_tool_use != null) {
          snapshot.usage.server_tool_use = event.usage.server_tool_use;
        }
        return snapshot;
      case "content_block_start":
        snapshot.content.push({ ...event.content_block });
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                text: (snapshotContent.text || "") + event.delta.text
              };
            }
            break;
          }
          case "citations_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                citations: [...snapshotContent.citations ?? [], event.delta.citation]
              };
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent && tracksToolInput2(snapshotContent)) {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
              jsonBuf += event.delta.partial_json;
              const newContent = { ...snapshotContent };
              Object.defineProperty(newContent, JSON_BUF_PROPERTY2, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                newContent.input = partialParse(jsonBuf);
              }
              snapshot.content[event.index] = newContent;
            }
            break;
          }
          case "thinking_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                thinking: snapshotContent.thinking + event.delta.thinking
              };
            }
            break;
          }
          case "signature_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                signature: event.delta.signature
              };
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve4, reject) => readQueue.push({ resolve: resolve4, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever2(x) {
}

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2 = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.create({
   *   requests: [
   *     {
   *       custom_id: 'my-custom-id-1',
   *       params: {
   *         max_tokens: 1024,
   *         messages: [
   *           { content: 'Hello, world', role: 'user' },
   *         ],
   *         model: 'claude-sonnet-4-5-20250929',
   *       },
   *     },
   *   ],
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/v1/messages/batches", { body, ...options });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.retrieve(
   *   'message_batch_id',
   * );
   * ```
   */
  retrieve(messageBatchID, options) {
    return this._client.get(path3`/v1/messages/batches/${messageBatchID}`, options);
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const messageBatch of client.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/v1/messages/batches", Page, { query, ...options });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const deletedMessageBatch =
   *   await client.messages.batches.delete('message_batch_id');
   * ```
   */
  delete(messageBatchID, options) {
    return this._client.delete(path3`/v1/messages/batches/${messageBatchID}`, options);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.cancel(
   *   'message_batch_id',
   * );
   * ```
   */
  cancel(messageBatchID, options) {
    return this._client.post(path3`/v1/messages/batches/${messageBatchID}/cancel`, options);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatchIndividualResponse =
   *   await client.messages.batches.results('message_batch_id');
   * ```
   */
  async results(messageBatchID, options) {
    const batch = await this.retrieve(messageBatchID);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    return this._client.get(batch.results_url, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      stream: true,
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches2(this._client);
  }
  create(body, options) {
    if (body.model in DEPRECATED_MODELS2) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    let timeout = this._client._options.timeout;
    if (!body.stream && timeout == null) {
      const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? void 0;
      timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
    }
    return this._client.post("/v1/messages", {
      body,
      timeout: timeout ?? 6e5,
      ...options,
      stream: body.stream ?? false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return MessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const messageTokensCount =
   *   await client.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-opus-4-5-20251101',
   *   });
   * ```
   */
  countTokens(body, options) {
    return this._client.post("/v1/messages/count_tokens", { body, ...options });
  }
};
var DEPRECATED_MODELS2 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-7-sonnet-latest": "February 19th, 2026",
  "claude-3-7-sonnet-20250219": "February 19th, 2026"
};
Messages2.Batches = Batches2;

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2 = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path3`/v1/models/${modelID}`, {
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/models", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/internal/utils/env.mjs
var readEnv = (env) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};

// node_modules/@anthropic-ai/sdk/client.mjs
var _BaseAnthropic_instances;
var _a;
var _BaseAnthropic_encoder;
var _BaseAnthropic_baseURLOverridden;
var HUMAN_PROMPT = "\\n\\nHuman:";
var AI_PROMPT = "\\n\\nAssistant:";
var BaseAnthropic = class {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = readEnv("ANTHROPIC_API_KEY") ?? null, authToken = readEnv("ANTHROPIC_AUTH_TOKEN") ?? null, ...opts } = {}) {
    _BaseAnthropic_instances.add(this);
    _BaseAnthropic_encoder.set(this, void 0);
    const options = {
      apiKey,
      authToken,
      ...opts,
      baseURL: baseURL || `https://api.anthropic.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("ANTHROPIC_LOG"), "process.env['ANTHROPIC_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _BaseAnthropic_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : null;
    this.authToken = authToken;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      authToken: this.authToken,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (values.get("x-api-key") || values.get("authorization")) {
      return;
    }
    if (this.apiKey && values.get("x-api-key")) {
      return;
    }
    if (nulls.has("x-api-key")) {
      return;
    }
    if (this.authToken && values.get("authorization")) {
      return;
    }
    if (nulls.has("authorization")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  async authHeaders(opts) {
    return buildHeaders([await this.apiKeyAuth(opts), await this.bearerAuth(opts)]);
  }
  async apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return void 0;
    }
    return buildHeaders([{ "X-Api-Key": this.apiKey }]);
  }
  async bearerAuth(opts) {
    if (this.authToken == null) {
      return void 0;
    }
    return buildHeaders([{ Authorization: `Bearer ${this.authToken}` }]);
  }
  /**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  buildURL(path9, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _BaseAnthropic_instances, "m", _BaseAnthropic_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL(path9) ? new URL(path9) : new URL(baseURL + (baseURL.endsWith("/") && path9.startsWith("/") ? path9.slice(1) : path9));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  _calculateNonstreamingTimeout(maxTokens) {
    const defaultTimeout = 10 * 60;
    const expectedTimeout = 60 * 60 * maxTokens / 128e3;
    if (expectedTimeout > defaultTimeout) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details");
    }
    return defaultTimeout * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  get(path9, opts) {
    return this.methodRequest("get", path9, opts);
  }
  post(path9, opts) {
    return this.methodRequest("post", path9, opts);
  }
  patch(path9, opts) {
    return this.methodRequest("patch", path9, opts);
  }
  put(path9, opts) {
    return this.methodRequest("put", path9, opts);
  }
  delete(path9, opts) {
    return this.methodRequest("delete", path9, opts);
  }
  methodRequest(method, path9, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path9, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path9, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path: path9, ...opts });
  }
  requestAPIList(Page3, options) {
    const request = this.makeRequest(options, null, void 0);
    return new PagePromise(this, request, Page3);
  }
  async fetchWithTimeout(url, init2, ms, controller) {
    const { signal, method, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  calculateNonstreamingTimeout(maxTokens, maxNonstreamingTokens) {
    const maxTime = 60 * 60 * 1e3;
    const defaultTime = 60 * 10 * 1e3;
    const expectedTime = maxTime * maxTokens / 128e3;
    if (expectedTime > defaultTime || maxNonstreamingTokens != null && maxTokens > maxNonstreamingTokens) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details");
    }
    return defaultTime;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path9, query, defaultBaseURL } = options;
    const url = this.buildURL(path9, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders(),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
        "anthropic-version": "2023-06-01"
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _BaseAnthropic_encoder, "f").call(this, { body, headers });
    }
  }
};
_a = BaseAnthropic, _BaseAnthropic_encoder = /* @__PURE__ */ new WeakMap(), _BaseAnthropic_instances = /* @__PURE__ */ new WeakSet(), _BaseAnthropic_baseURLOverridden = function _BaseAnthropic_baseURLOverridden2() {
  return this.baseURL !== "https://api.anthropic.com";
};
BaseAnthropic.Anthropic = _a;
BaseAnthropic.HUMAN_PROMPT = HUMAN_PROMPT;
BaseAnthropic.AI_PROMPT = AI_PROMPT;
BaseAnthropic.DEFAULT_TIMEOUT = 6e5;
BaseAnthropic.AnthropicError = AnthropicError;
BaseAnthropic.APIError = APIError;
BaseAnthropic.APIConnectionError = APIConnectionError;
BaseAnthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
BaseAnthropic.APIUserAbortError = APIUserAbortError;
BaseAnthropic.NotFoundError = NotFoundError;
BaseAnthropic.ConflictError = ConflictError;
BaseAnthropic.RateLimitError = RateLimitError;
BaseAnthropic.BadRequestError = BadRequestError;
BaseAnthropic.AuthenticationError = AuthenticationError;
BaseAnthropic.InternalServerError = InternalServerError;
BaseAnthropic.PermissionDeniedError = PermissionDeniedError;
BaseAnthropic.UnprocessableEntityError = UnprocessableEntityError;
BaseAnthropic.toFile = toFile;
var Anthropic = class extends BaseAnthropic {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this);
    this.messages = new Messages2(this);
    this.models = new Models2(this);
    this.beta = new Beta(this);
  }
};
Anthropic.Completions = Completions;
Anthropic.Messages = Messages2;
Anthropic.Models = Models2;
Anthropic.Beta = Beta;

// src/services/providers/AnthropicProvider.ts
var AnthropicProvider = class {
  name = "Anthropic";
  client = null;
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model || "claude-3-5-haiku-20241022";
  }
  getClient() {
    if (!this.client && this.apiKey && this.apiKey.trim().length > 0) {
      try {
        this.client = new Anthropic({ apiKey: this.apiKey });
      } catch (error) {
        Logger.warn("Failed to initialize Anthropic client:", error);
        throw new Error("Failed to initialize Anthropic client");
      }
    }
    if (!this.client) {
      throw new Error("Anthropic client not initialized");
    }
    return this.client;
  }
  async authenticate(apiKey) {
    return apiKey.trim().length > 0 && apiKey.startsWith("sk-");
  }
  isAvailable() {
    return this.apiKey.trim().length > 0;
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("Anthropic provider is not available");
    }
    const prompt = this.constructPrompt(text);
    try {
      const client = this.getClient();
      const response = await client.messages.create({
        model: this.model,
        max_tokens: 256,
        messages: [{
          role: "user",
          content: prompt
        }]
      });
      const content = response.content[0];
      if (content.type !== "text") {
        throw new Error("Unexpected response type from Anthropic API");
      }
      return this.parseResponse(content.text);
    } catch (error) {
      const err = error;
      if (err?.status === 429 || err?.response?.status === 429) {
        throw new Error("Rate limit exceeded. Please try again later.");
      }
      if (err?.status === 401 || err?.response?.status === 401) {
        throw new Error("Invalid API key. Please check your Anthropic API key.");
      }
      let errorMessage = "Unknown error";
      try {
        const errorStr = String(error);
        if (errorStr !== "[object Object]") {
          errorMessage = errorStr;
        } else if (err?.name) {
          errorMessage = `${err.name}: API request failed`;
        }
      } catch {
        errorMessage = "Unknown error";
      }
      throw new Error(`Anthropic API error: ${errorMessage}`);
    }
  }
  constructPrompt(text) {
    return `Classify this idea into one category and suggest 2-4 relevant tags.

Idea: "${text}"

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Rules:
- Choose the single best category
- Tags should be specific and relevant (2-4 tags)
- Use lowercase for category and tags

Example response:
{
  "category": "game",
  "tags": ["rpg", "fantasy", "multiplayer"]
}

Response:`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: parsed.confidence || 0.8
      };
    } catch (error) {
      Logger.warn("Failed to parse Anthropic response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
};

// node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet2(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet2(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/openai/internal/utils/uuid.mjs
var uuid42 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2?.randomUUID) {
    uuid42 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/openai/internal/errors.mjs
function isAbortError2(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError2 = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};

// node_modules/openai/core/error.mjs
var OpenAIError = class extends Error {
};
var APIError2 = class _APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("x-request-id");
    this.error = error;
    const data = error;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError2({ message, cause: castToError2(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError2(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError2(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError2(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError2(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError2(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError2(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError2(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError2(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError2 = class extends APIError2 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError2 = class extends APIError2 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError2 = class extends APIConnectionError2 {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError2 = class extends APIError2 {
};
var AuthenticationError2 = class extends APIError2 {
};
var PermissionDeniedError2 = class extends APIError2 {
};
var NotFoundError2 = class extends APIError2 {
};
var ConflictError2 = class extends APIError2 {
};
var UnprocessableEntityError2 = class extends APIError2 {
};
var RateLimitError2 = class extends APIError2 {
};
var InternalServerError2 = class extends APIError2 {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};
var InvalidWebhookSignatureError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// node_modules/openai/internal/utils/values.mjs
var startsWithSchemeRegexp2 = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL2 = (url) => {
  return startsWithSchemeRegexp2.test(url);
};
var isArray2 = (val) => (isArray2 = Array.isArray, isArray2(val));
var isReadonlyArray2 = isArray2;
function maybeObj2(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj2(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
var validatePositiveInteger2 = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON2 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/openai/internal/utils/sleep.mjs
var sleep2 = (ms) => new Promise((resolve4) => setTimeout(resolve4, ms));

// node_modules/openai/version.mjs
var VERSION2 = "6.9.1";

// node_modules/openai/internal/detect-platform.mjs
var isRunningInBrowser2 = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform2() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties2 = () => {
  const detectedPlatform = getDetectedPlatform2();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(Deno.build.os),
      "X-Stainless-Arch": normalizeArch2(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch2(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo2();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo2() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch2 = (arch3) => {
  if (arch3 === "x32")
    return "x32";
  if (arch3 === "x86_64" || arch3 === "x64")
    return "x64";
  if (arch3 === "arm")
    return "arm";
  if (arch3 === "aarch64" || arch3 === "arm64")
    return "arm64";
  if (arch3)
    return `other:${arch3}`;
  return "unknown";
};
var normalizePlatform2 = (platform3) => {
  platform3 = platform3.toLowerCase();
  if (platform3.includes("ios"))
    return "iOS";
  if (platform3 === "android")
    return "Android";
  if (platform3 === "darwin")
    return "MacOS";
  if (platform3 === "win32")
    return "Windows";
  if (platform3 === "freebsd")
    return "FreeBSD";
  if (platform3 === "openbsd")
    return "OpenBSD";
  if (platform3 === "linux")
    return "Linux";
  if (platform3)
    return `Other:${platform3}`;
  return "Unknown";
};
var _platformHeaders2;
var getPlatformHeaders2 = () => {
  return _platformHeaders2 ?? (_platformHeaders2 = getPlatformProperties2());
};

// node_modules/openai/internal/shims.mjs
function getDefaultFetch2() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream2(...args) {
  const ReadableStream3 = globalThis.ReadableStream;
  if (typeof ReadableStream3 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream3(...args);
}
function ReadableStreamFrom2(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream2({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable2(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream2(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/openai/internal/request-options.mjs
var FallbackEncoder2 = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var default_formatter = (v) => String(v);
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var has = (obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key));
var hex_table = /* @__PURE__ */ (() => {
  const array = [];
  for (let i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray2(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var push_to_array = function(arr, value_or_array) {
  Array.prototype.push.apply(arr, isArray2(value_or_array) ? value_or_array : [value_or_array]);
};
var toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder(obj, defaults.encoder, charset, "value", format))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/internal/utils/bytes.mjs
function concatBytes2(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_2;
function encodeUTF82(str2) {
  let encoder;
  return (encodeUTF8_2 ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_2 = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_2;
function decodeUTF82(bytes) {
  let decoder;
  return (decodeUTF8_2 ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_2 = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/openai/internal/decoders/line.mjs
var _LineDecoder_buffer2;
var _LineDecoder_carriageReturnIndex2;
var LineDecoder2 = class {
  constructor() {
    _LineDecoder_buffer2.set(this, void 0);
    _LineDecoder_carriageReturnIndex2.set(this, void 0);
    __classPrivateFieldSet2(this, _LineDecoder_buffer2, new Uint8Array(), "f");
    __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF82(chunk) : chunk;
    __classPrivateFieldSet2(this, _LineDecoder_buffer2, concatBytes2([__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex2(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f"), __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") == null) {
        __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") != null && (patternIndex.index !== __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF82(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(0, __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") - 1)));
        __classPrivateFieldSet2(this, _LineDecoder_buffer2, __classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(__classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f")), "f");
        __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF82(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet2(this, _LineDecoder_buffer2, __classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer2 = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex2 = /* @__PURE__ */ new WeakMap();
LineDecoder2.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder2.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex2(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex2(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/openai/internal/utils/log.mjs
var levelNumbers2 = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel2 = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn2(levelNumbers2, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor2(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers2))}`);
  return void 0;
};
function noop2() {
}
function makeLogFn2(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers2[fnLevel] > levelNumbers2[logLevel]) {
    return noop2;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger2 = {
  error: noop2,
  warn: noop2,
  info: noop2,
  debug: noop2
};
var cachedLoggers2 = /* @__PURE__ */ new WeakMap();
function loggerFor2(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger2;
  }
  const cachedLogger = cachedLoggers2.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn2("error", logger, logLevel),
    warn: makeLogFn2("warn", logger, logLevel),
    info: makeLogFn2("info", logger, logLevel),
    debug: makeLogFn2("debug", logger, logLevel)
  };
  cachedLoggers2.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails2 = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/openai/core/streaming.mjs
var _Stream_client2;
var Stream2 = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client2.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet2(this, _Stream_client2, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor2(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages2(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError2(void 0, data.error, void 0, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError2(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError2(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder2();
      const iter = ReadableStreamToAsyncIterable2(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError2(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet2(this, _Stream_client2, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet2(this, _Stream_client2, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    return makeReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF82(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages2(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder2();
  const lineDecoder = new LineDecoder2();
  const iter = ReadableStreamToAsyncIterable2(response.body);
  for await (const sseChunk of iterSSEChunks2(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks2(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF82(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex2(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder2 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition2(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition2(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/openai/internal/parse.mjs
async function defaultParseResponse2(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor2(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream2.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json = await response.json();
      return addRequestID2(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor2(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails2({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID2(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}

// node_modules/openai/core/api-promise.mjs
var _APIPromise_client2;
var APIPromise2 = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse2) {
    super((resolve4) => {
      resolve4(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client2.set(this, void 0);
    __classPrivateFieldSet2(this, _APIPromise_client2, client, "f");
  }
  _thenUnwrap(transform) {
    return new _APIPromise(__classPrivateFieldGet2(this, _APIPromise_client2, "f"), this.responsePromise, async (client, props) => addRequestID2(transform(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet2(this, _APIPromise_client2, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client2 = /* @__PURE__ */ new WeakMap();

// node_modules/openai/core/pagination.mjs
var _AbstractPage_client2;
var AbstractPage2 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client2.set(this, void 0);
    __classPrivateFieldSet2(this, _AbstractPage_client2, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet2(this, _AbstractPage_client2, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise2 = class extends APIPromise2 {
  constructor(client, request, Page3) {
    super(client, request, async (client2, props) => new Page3(client2, props.response, await defaultParseResponse2(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page2 = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
};
var CursorPage = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const data = this.getPaginatedItems();
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj2(this.options.query),
        after: id
      }
    };
  }
};
var ConversationCursorPage = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj2(this.options.query),
        after: cursor
      }
    };
  }
};

// node_modules/openai/internal/uploads.mjs
var checkFileSupport2 = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile2(fileBits, fileName, options) {
  checkFileSupport2();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName2(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var maybeMultipartFormRequestOptions = async (opts, fetch3) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm2(opts.body, fetch3) };
};
var multipartFormRequestOptions2 = async (opts, fetch3) => {
  return { ...opts, body: await createForm2(opts.body, fetch3) };
};
var supportsFormDataMap2 = /* @__PURE__ */ new WeakMap();
function supportsFormData2(fetchObject) {
  const fetch3 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap2.get(fetch3);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch3 ? fetch3.Response : (await fetch3("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap2.set(fetch3, promise);
  return promise;
}
var createForm2 = async (body, fetch3) => {
  if (!await supportsFormData2(fetch3)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue2(form, key, value)));
  return form;
};
var isNamedBlob2 = (value) => value instanceof Blob && "name" in value;
var isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable2(value) || isNamedBlob2(value));
var hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
var addFormValue2 = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile2([await value.blob()], getName2(value)));
  } else if (isAsyncIterable2(value)) {
    form.append(key, makeFile2([await new Response(ReadableStreamFrom2(value)).blob()], getName2(value)));
  } else if (isNamedBlob2(value)) {
    form.append(key, value, getName2(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue2(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue2(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/internal/to-file.mjs
var isBlobLike2 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike2 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike2(value);
var isResponseLike2 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile2(value, name, options) {
  checkFileSupport2();
  value = await value;
  if (isFileLike2(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile2([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike2(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile2(await getBytes2(blob), name, options);
  }
  const parts = await getBytes2(value);
  name || (name = getName2(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile2(parts, name, options);
}
async function getBytes2(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike2(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable2(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes2(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError2(value)}`);
  }
  return parts;
}
function propsForError2(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}

// node_modules/openai/core/resource.mjs
var APIResource2 = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/internal/utils/path.mjs
function encodeURIPath2(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction2 = (pathEncoder = encodeURIPath2) => function path9(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path10 = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY2) ?? EMPTY2)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path10.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path10}
${underline}`);
  }
  return path10;
};
var path4 = /* @__PURE__ */ createPathTagFunction2(encodeURIPath2);

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages3 = class extends APIResource2 {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(completionID, query = {}, options) {
    return this._client.getAPIList(path4`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool) {
  return tool !== void 0 && "function" in tool && tool.function !== void 0;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
var isToolMessage = (message) => {
  return message?.role === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet2(this, _EventStream_connectedPromise, new Promise((resolve4, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveConnectedPromise, resolve4, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _EventStream_endPromise, new Promise((resolve4, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveEndPromise, resolve4, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve4, reject) => {
      __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve4);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet2(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet2(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError2();
  }
  if (error instanceof APIUserAbortError2) {
    __classPrivateFieldSet2(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runTools(client, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.filter((x) => x.type === "function").at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse2 = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet2(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet2(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new _ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addChatCompletion(__classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addChatCompletion(__classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet2(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet2(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet2(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => isChatCompletionFunctionTool(tool) && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    const state = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet2(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet2(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    const responseFormat = __classPrivateFieldGet2(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a5, _b, _c, _d;
    let snapshot = __classPrivateFieldGet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a5 = choice.logprobs).content ?? (_a5.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet2(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet2(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse2(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet2(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse2(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve4, reject) => readQueue.push({ resolve: resolve4, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.messages = new Messages3(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionID, options) {
    return this._client.get(path4`/chat/completions/${completionID}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionID, body, options) {
    return this._client.post(path4`/chat/completions/${completionID}`, { body, ...options });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(completionID, options) {
    return this._client.delete(path4`/chat/completions/${completionID}`, options);
  }
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};
Completions2.Messages = Messages3;

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
Chat.Completions = Completions2;

// node_modules/openai/internal/headers.mjs
var brand_privateNullableHeaders2 = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders2(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders2 in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray2(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray2(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders2 = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders2(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders2]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource2 {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "application/octet-stream" }, options?.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions2({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions2({ body, ...options, __metadata: { model: body.model } }, this._client));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches3 = class extends APIResource2 {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchID, options) {
    return this._client.get(path4`/batches/${batchID}`, options);
  }
  /**
   * List your organization's batches.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchID, options) {
    return this._client.post(path4`/batches/${batchID}/cancel`, options);
  }
};

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource2 {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantID, options) {
    return this._client.get(path4`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantID, body, options) {
    return this._client.post(path4`/assistants/${assistantID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(assistantID, options) {
    return this._client.delete(path4`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource2 {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions = class extends APIResource2 {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/chatkit/sessions.mjs
var Sessions2 = class extends APIResource2 {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(body, options) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(sessionID, options) {
    return this._client.post(path4`/chatkit/sessions/${sessionID}/cancel`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/chatkit/threads.mjs
var Threads = class extends APIResource2 {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(threadID, options) {
    return this._client.get(path4`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(threadID, options) {
    return this._client.delete(path4`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(threadID, query = {}, options) {
    return this._client.getAPIList(path4`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) });
  }
};

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
var ChatKit = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads(this._client);
  }
};
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads;

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages4 = class extends APIResource2 {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadID, body, options) {
    return this._client.post(path4`/threads/${threadID}/messages`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(messageID, params, options) {
    const { thread_id } = params;
    return this._client.get(path4`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(messageID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path4`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path4`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(messageID, params, options) {
    const { thread_id } = params;
    return this._client.delete(path4`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource2 {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(stepID, params, options) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path4`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(runID, params, options) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path4`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/internal/utils/base64.mjs
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};

// node_modules/openai/internal/utils/env.mjs
var readEnv2 = (env) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};

// node_modules/openai/lib/AssistantStream.mjs
var _AssistantStream_instances;
var _a2;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve4, reject) => readQueue.push({ resolve: resolve4, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a2();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options) {
    const runner = new _a2();
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _a2();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _a2();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet2(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet2(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet2(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet2(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet2(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet2(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, runId, params, options);
  }
};
_a2 = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet2(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever2(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet2(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet2(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet2(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet2(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet2(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet2(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet2(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet2(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet2(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet2(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet2(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet2(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet2(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet2(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet2(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet2(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet2(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet2(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet2(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet2(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet2(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a2.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a2.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet2(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet2(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet2(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever2(_x) {
}

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path4`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(runID, params, options) {
    const { thread_id } = params;
    return this._client.get(path4`/threads/${thread_id}/runs/${runID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path4`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path4`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(runID, params, options) {
    const { thread_id } = params;
    return this._client.post(path4`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(run.id, { thread_id: threadId }, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(runId, params, options) {
    const headers = buildHeaders2([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const { data: run, response } = await this.retrieve(runId, params, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path4`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(runId, params, options) {
    const run = await this.submitToolOutputs(runId, params, options);
    return await this.poll(run.id, params, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(runId, params, options) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
  }
};
Runs.Steps = Steps;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages4(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(body = {}, options) {
    return this._client.post("/threads", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadID, options) {
    return this._client.get(path4`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadID, body, options) {
    return this._client.post(path4`/threads/${threadID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(threadID, options) {
    return this._client.delete(path4`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads2.Runs = Runs;
Threads2.Messages = Messages4;

// node_modules/openai/resources/beta/beta.mjs
var Beta2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads2(this._client);
  }
};
Beta2.Realtime = Realtime;
Beta2.ChatKit = ChatKit;
Beta2.Assistants = Assistants;
Beta2.Threads = Threads2;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/containers/files/content.mjs
var Content = class extends APIResource2 {
  /**
   * Retrieve Container File Content
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path4`/containers/${container_id}/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/containers/files/files.mjs
var Files2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerID, body, options) {
    return this._client.post(path4`/containers/${containerID}/files`, multipartFormRequestOptions2({ body, ...options }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path4`/containers/${container_id}/files/${fileID}`, options);
  }
  /**
   * List Container files
   */
  list(containerID, query = {}, options) {
    return this._client.getAPIList(path4`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete Container File
   */
  delete(fileID, params, options) {
    const { container_id } = params;
    return this._client.delete(path4`/containers/${container_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
};
Files2.Content = Content;

// node_modules/openai/resources/containers/containers.mjs
var Containers = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.files = new Files2(this._client);
  }
  /**
   * Create Container
   */
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerID, options) {
    return this._client.get(path4`/containers/${containerID}`, options);
  }
  /**
   * List Containers
   */
  list(query = {}, options) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options });
  }
  /**
   * Delete Container
   */
  delete(containerID, options) {
    return this._client.delete(path4`/containers/${containerID}`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
};
Containers.Files = Files2;

// node_modules/openai/resources/conversations/items.mjs
var Items = class extends APIResource2 {
  /**
   * Create items in a conversation with the given ID.
   */
  create(conversationID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path4`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(itemID, params, options) {
    const { conversation_id, ...query } = params;
    return this._client.get(path4`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(conversationID, query = {}, options) {
    return this._client.getAPIList(path4`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(itemID, params, options) {
    const { conversation_id } = params;
    return this._client.delete(path4`/conversations/${conversation_id}/items/${itemID}`, options);
  }
};

// node_modules/openai/resources/conversations/conversations.mjs
var Conversations = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  /**
   * Create a conversation.
   */
  create(body = {}, options) {
    return this._client.post("/conversations", { body, ...options });
  }
  /**
   * Get a conversation
   */
  retrieve(conversationID, options) {
    return this._client.get(path4`/conversations/${conversationID}`, options);
  }
  /**
   * Update a conversation
   */
  update(conversationID, body, options) {
    return this._client.post(path4`/conversations/${conversationID}`, { body, ...options });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(conversationID, options) {
    return this._client.delete(path4`/conversations/${conversationID}`, options);
  }
};
Conversations.Items = Items;

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource2 {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor2(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor2(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};

// node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems = class extends APIResource2 {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(outputItemID, params, options) {
    const { eval_id, run_id } = params;
    return this._client.get(path4`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(runID, params, options) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path4`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalID, body, options) {
    return this._client.post(path4`/evals/${evalID}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(runID, params, options) {
    const { eval_id } = params;
    return this._client.get(path4`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(evalID, query = {}, options) {
    return this._client.getAPIList(path4`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete an eval run.
   */
  delete(runID, params, options) {
    const { eval_id } = params;
    return this._client.delete(path4`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(runID, params, options) {
    const { eval_id } = params;
    return this._client.post(path4`/evals/${eval_id}/runs/${runID}`, options);
  }
};
Runs2.OutputItems = OutputItems;

// node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalID, options) {
    return this._client.get(path4`/evals/${evalID}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalID, body, options) {
    return this._client.post(path4`/evals/${evalID}`, { body, ...options });
  }
  /**
   * List evaluations for a project.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  delete(evalID, options) {
    return this._client.delete(path4`/evals/${evalID}`, options);
  }
};
Evals.Runs = Runs2;

// node_modules/openai/resources/files.mjs
var Files3 = class extends APIResource2 {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions2({ body, ...options }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileID, options) {
    return this._client.get(path4`/files/${fileID}`, options);
  }
  /**
   * Returns a list of files.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(fileID, options) {
    return this._client.delete(path4`/files/${fileID}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileID, options) {
    return this._client.get(path4`/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError2({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};

// node_modules/openai/resources/fine-tuning/methods.mjs
var Methods = class extends APIResource2 {
};

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders = class extends APIResource2 {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
};
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions = class extends APIResource2 {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(path4`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page2, { body, method: "post", ...options });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    return this._client.get(path4`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(permissionID, params, options) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path4`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
  }
};

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints.Permissions = Permissions;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2 = class extends APIResource2 {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path4`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobID, options) {
    return this._client.get(path4`/fine_tuning/jobs/${fineTuningJobID}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobID, options) {
    return this._client.post(path4`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path4`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobID, options) {
    return this._client.post(path4`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobID, options) {
    return this._client.post(path4`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
  }
};
Jobs.Checkpoints = Checkpoints2;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
};
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;

// node_modules/openai/resources/graders/grader-models.mjs
var GraderModels = class extends APIResource2 {
};

// node_modules/openai/resources/graders/graders.mjs
var Graders2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
};
Graders2.GraderModels = GraderModels;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource2 {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions2({ body, ...options }, this._client));
  }
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions2({ body, ...options, stream: body.stream ?? false }, this._client));
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/models.mjs
var Models3 = class extends APIResource2 {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(path4`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", Page2, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(model, options) {
    return this._client.delete(path4`/models/${model}`, options);
  }
};

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource2 {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/calls.mjs
var Calls = class extends APIResource2 {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(callID, body, options) {
    return this._client.post(path4`/realtime/calls/${callID}/accept`, {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(callID, options) {
    return this._client.post(path4`/realtime/calls/${callID}/hangup`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(callID, body, options) {
    return this._client.post(path4`/realtime/calls/${callID}/refer`, {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(callID, body = {}, options) {
    return this._client.post(path4`/realtime/calls/${callID}/reject`, {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/realtime/client-secrets.mjs
var ClientSecrets = class extends APIResource2 {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/client_secrets", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/realtime.mjs
var Realtime2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
};
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;

// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// node_modules/openai/lib/responses/ResponseStream.mjs
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;
var ResponseStream = class _ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet2(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new _ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet2(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet2(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    let snapshot = __classPrivateFieldGet2(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = output.content?.[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve4, reject) => readQueue.push({ resolve: resolve4, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet2(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
};
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// node_modules/openai/resources/responses/input-items.mjs
var InputItems = class extends APIResource2 {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(responseID, query = {}, options) {
    return this._client.getAPIList(path4`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/responses/input-tokens.mjs
var InputTokens = class extends APIResource2 {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(body = {}, options) {
    return this._client.post("/responses/input_tokens", { body, ...options });
  }
};

// node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
    this.inputTokens = new InputTokens(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options) {
    return this._client.get(path4`/responses/${responseID}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(responseID, options) {
    return this._client.delete(path4`/responses/${responseID}`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseID, options) {
    return this._client.post(path4`/responses/${responseID}/cancel`, options);
  }
};
Responses.InputItems = InputItems;
Responses.InputTokens = InputTokens;

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource2 {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadID, body, options) {
    return this._client.post(path4`/uploads/${uploadID}/parts`, multipartFormRequestOptions2({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadID, options) {
    return this._client.post(path4`/uploads/${uploadID}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadID, body, options) {
    return this._client.post(path4`/uploads/${uploadID}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource2 {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path4`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path4`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.post(path4`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(batchID, params, options) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path4`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreID, batchID, options) {
    const headers = buildHeaders2([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/vector-stores/files.mjs
var Files4 = class extends APIResource2 {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path4`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path4`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(fileID, params, options) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path4`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(vectorStoreID, query = {}, options) {
    return this._client.getAPIList(path4`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.delete(path4`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreID, fileID, options) {
    const headers = buildHeaders2([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path4`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page2, { ...options, headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
};

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.files = new Files4(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreID, options) {
    return this._client.get(path4`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreID, body, options) {
    return this._client.post(path4`/vector_stores/${vectorStoreID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(vectorStoreID, options) {
    return this._client.delete(path4`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreID, body, options) {
    return this._client.getAPIList(path4`/vector_stores/${vectorStoreID}/search`, Page2, {
      body,
      method: "post",
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};
VectorStores.Files = Files4;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/videos.mjs
var Videos = class extends APIResource2 {
  /**
   * Create a video
   */
  create(body, options) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(videoID, options) {
    return this._client.get(path4`/videos/${videoID}`, options);
  }
  /**
   * List videos
   */
  list(query = {}, options) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete a video
   */
  delete(videoID, options) {
    return this._client.delete(path4`/videos/${videoID}`, options);
  }
  /**
   * Download video content
   */
  downloadContent(videoID, query = {}, options) {
    return this._client.get(path4`/videos/${videoID}/content`, {
      query,
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Create a video remix
   */
  remix(videoID, body, options) {
    return this._client.post(path4`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances;
var _Webhooks_validateSecret;
var _Webhooks_getRequiredHeader;
var Webhooks = class extends APIResource2 {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders2([headers]).values;
    const signatureHeader = __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1e3);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
};
_Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === void 0) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};

// node_modules/openai/client.mjs
var _OpenAI_instances;
var _a3;
var _OpenAI_encoder;
var _OpenAI_baseURLOverridden;
var OpenAI = class {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv2("OPENAI_BASE_URL"), apiKey = readEnv2("OPENAI_API_KEY"), organization = readEnv2("OPENAI_ORG_ID") ?? null, project = readEnv2("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv2("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, void 0);
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files3(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models3(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta2(this);
    this.batches = new Batches3(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === void 0) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser2()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a3.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel2(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel2(readEnv2("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch2();
    __classPrivateFieldSet2(this, _OpenAI_encoder, FallbackEncoder2, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders2([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid42()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError2.generate(status, error, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(
        `Failed to get token from 'apiKey' function: ${err.message}`,
        // @ts-ignore
        { cause: err }
      );
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path9, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet2(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL2(path9) ? new URL(path9) : new URL(baseURL + (baseURL.endsWith("/") && path9.startsWith("/") ? path9.slice(1) : path9));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj2(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  get(path9, opts) {
    return this.methodRequest("get", path9, opts);
  }
  post(path9, opts) {
    return this.methodRequest("post", path9, opts);
  }
  patch(path9, opts) {
    return this.methodRequest("patch", path9, opts);
  }
  put(path9, opts) {
    return this.methodRequest("put", path9, opts);
  }
  delete(path9, opts) {
    return this.methodRequest("delete", path9, opts);
  }
  methodRequest(method, path9, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path9, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise2(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor2(this).debug(`[${requestLogID}] sending request`, formatRequestDetails2({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError2);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError2();
      }
      const isTimeout = isAbortError2(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor2(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor2(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails2({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor2(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor2(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails2({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError2();
      }
      throw new APIConnectionError2({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream2(response.body);
        loggerFor2(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor2(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails2({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor2(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError2(err2).message);
      const errJSON = safeJSON2(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor2(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails2({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor2(this).info(responseInfo);
    loggerFor2(this).debug(`[${requestLogID}] response start`, formatRequestDetails2({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path9, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path: path9, ...opts });
  }
  requestAPIList(Page3, options) {
    const request = this.makeRequest(options, null, void 0);
    return new PagePromise2(this, request, Page3);
  }
  async fetchWithTimeout(url, init2, ms, controller) {
    const { signal, method, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path9, query, defaultBaseURL } = options;
    const url = this.buildURL(path9, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger2("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders2([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders2(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders2([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom2(body) };
    } else {
      return __classPrivateFieldGet2(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
};
_a3 = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a3;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError2;
OpenAI.APIConnectionError = APIConnectionError2;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError2;
OpenAI.APIUserAbortError = APIUserAbortError2;
OpenAI.NotFoundError = NotFoundError2;
OpenAI.ConflictError = ConflictError2;
OpenAI.RateLimitError = RateLimitError2;
OpenAI.BadRequestError = BadRequestError2;
OpenAI.AuthenticationError = AuthenticationError2;
OpenAI.InternalServerError = InternalServerError2;
OpenAI.PermissionDeniedError = PermissionDeniedError2;
OpenAI.UnprocessableEntityError = UnprocessableEntityError2;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile2;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files3;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models3;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta2;
OpenAI.Batches = Batches3;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;

// src/services/providers/OpenAIProvider.ts
var OpenAIProvider = class {
  name = "OpenAI";
  client = null;
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model || "gpt-4o-mini";
  }
  getClient() {
    if (!this.client && this.apiKey && this.apiKey.trim().length > 0) {
      try {
        this.client = new OpenAI({ apiKey: this.apiKey });
      } catch (error) {
        Logger.warn("Failed to initialize OpenAI client:", error);
        throw new Error("Failed to initialize OpenAI client");
      }
    }
    if (!this.client) {
      throw new Error("OpenAI client not initialized");
    }
    return this.client;
  }
  async authenticate(apiKey) {
    return apiKey.trim().length > 0 && apiKey.startsWith("sk-");
  }
  isAvailable() {
    return this.apiKey.trim().length > 0;
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("OpenAI provider is not available");
    }
    const prompt = this.constructPrompt(text);
    try {
      const client = this.getClient();
      const response = await client.chat.completions.create({
        model: this.model,
        messages: [{
          role: "user",
          content: prompt
        }],
        max_tokens: 256,
        temperature: 0.1
      });
      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error("No content in OpenAI response");
      }
      return this.parseResponse(content);
    } catch (error) {
      const err = error;
      if (err?.status === 429 || err?.response?.status === 429) {
        throw new Error("Rate limit exceeded. Please try again later.");
      }
      if (err?.status === 401 || err?.response?.status === 401) {
        throw new Error("Invalid API key. Please check your OpenAI API key.");
      }
      if (error instanceof Error) {
        const message = error.message || "Unknown error";
        throw new Error(`OpenAI API error: ${message}`);
      }
      throw new Error("OpenAI API error: Request failed");
    }
  }
  constructPrompt(text) {
    return `Classify this idea into one category and suggest 2-4 relevant tags.

Idea: "${text}"

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Rules:
- Choose the single best category
- Tags should be specific and relevant (2-4 tags)
- Use lowercase for category and tags

Example response:
{
  "category": "game",
  "tags": ["rpg", "fantasy", "multiplayer"]
}

Response:`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: parsed.confidence || 0.8
      };
    } catch (error) {
      Logger.warn("Failed to parse OpenAI response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
};

// node_modules/@google/generative-ai/dist/index.mjs
var SchemaType;
(function(SchemaType2) {
  SchemaType2["STRING"] = "string";
  SchemaType2["NUMBER"] = "number";
  SchemaType2["INTEGER"] = "integer";
  SchemaType2["BOOLEAN"] = "boolean";
  SchemaType2["ARRAY"] = "array";
  SchemaType2["OBJECT"] = "object";
})(SchemaType || (SchemaType = {}));
var ExecutableCodeLanguage;
(function(ExecutableCodeLanguage2) {
  ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
  ExecutableCodeLanguage2["PYTHON"] = "python";
})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
  Outcome2["OUTCOME_OK"] = "outcome_ok";
  Outcome2["OUTCOME_FAILED"] = "outcome_failed";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(Outcome || (Outcome = {}));
var POSSIBLE_ROLES = ["user", "model", "function", "system"];
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var BlockReason;
(function(BlockReason2) {
  BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockReason2["SAFETY"] = "SAFETY";
  BlockReason2["OTHER"] = "OTHER";
})(BlockReason || (BlockReason = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["BLOCKLIST"] = "BLOCKLIST";
  FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason2["SPII"] = "SPII";
  FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason2["OTHER"] = "OTHER";
})(FinishReason || (FinishReason = {}));
var TaskType;
(function(TaskType2) {
  TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
  TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
  TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
  TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
  TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
  TaskType2["CLUSTERING"] = "CLUSTERING";
})(TaskType || (TaskType = {}));
var FunctionCallingMode;
(function(FunctionCallingMode2) {
  FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingMode2["AUTO"] = "AUTO";
  FunctionCallingMode2["ANY"] = "ANY";
  FunctionCallingMode2["NONE"] = "NONE";
})(FunctionCallingMode || (FunctionCallingMode = {}));
var DynamicRetrievalMode;
(function(DynamicRetrievalMode2) {
  DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalMode || (DynamicRetrievalMode = {}));
var GoogleGenerativeAIError = class extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
};
var GoogleGenerativeAIResponseError = class extends GoogleGenerativeAIError {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
};
var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
};
var GoogleGenerativeAIAbortError = class extends GoogleGenerativeAIError {
};
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.24.1";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));
var RequestUrl = class {
  constructor(model, task, apiKey, stream, requestOptions) {
    this.model = model;
    this.task = task;
    this.apiKey = apiKey;
    this.stream = stream;
    this.requestOptions = requestOptions;
  }
  toString() {
    var _a5, _b;
    const apiVersion = ((_a5 = this.requestOptions) === null || _a5 === void 0 ? void 0 : _a5.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
    let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
    if (this.stream) {
      url += "?alt=sse";
    }
    return url;
  }
};
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function getHeaders(url) {
  var _a5;
  const headers = new Headers();
  headers.append("Content-Type", "application/json");
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  let customHeaders = (_a5 = url.requestOptions) === null || _a5 === void 0 ? void 0 : _a5.customHeaders;
  if (customHeaders) {
    if (!(customHeaders instanceof Headers)) {
      try {
        customHeaders = new Headers(customHeaders);
      } catch (e) {
        throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
      }
    }
    for (const [headerName, headerValue] of customHeaders.entries()) {
      if (headerName === "x-goog-api-key") {
        throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
      } else if (headerName === "x-goog-api-client") {
        throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
      }
      headers.append(headerName, headerValue);
    }
  }
  return headers;
}
async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
  const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
  return {
    url: url.toString(),
    fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
  };
}
async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, fetchFn = fetch) {
  const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
  return makeRequest(url, fetchOptions, fetchFn);
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
  let response;
  try {
    response = await fetchFn(url, fetchOptions);
  } catch (e) {
    handleResponseError(e, url);
  }
  if (!response.ok) {
    await handleResponseNotOk(response, url);
  }
  return response;
}
function handleResponseError(e, url) {
  let err = e;
  if (err.name === "AbortError") {
    err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  } else if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  }
  throw err;
}
async function handleResponseNotOk(response, url) {
  let message = "";
  let errorDetails;
  try {
    const json = await response.json();
    message = json.error.message;
    if (json.error.details) {
      message += ` ${JSON.stringify(json.error.details)}`;
      errorDetails = json.error.details;
    }
  } catch (e) {
  }
  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
function buildFetchOptions(requestOptions) {
  const fetchOptions = {};
  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
    const controller = new AbortController();
    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
      setTimeout(() => controller.abort(), requestOptions.timeout);
    }
    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {
      requestOptions.signal.addEventListener("abort", () => {
        controller.abort();
      });
    }
    fetchOptions.signal = controller.signal;
  }
  return fetchOptions;
}
function addHelpers(response) {
  response.text = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getText(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return "";
  };
  response.functionCall = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
      return getFunctionCalls(response)[0];
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  response.functionCalls = () => {
    if (response.candidates && response.candidates.length > 0) {
      if (response.candidates.length > 1) {
        console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
      }
      if (hadBadFinishReason(response.candidates[0])) {
        throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
      }
      return getFunctionCalls(response);
    } else if (response.promptFeedback) {
      throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
    }
    return void 0;
  };
  return response;
}
function getText(response) {
  var _a5, _b, _c, _d;
  const textStrings = [];
  if ((_b = (_a5 = response.candidates) === null || _a5 === void 0 ? void 0 : _a5[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
      if (part.text) {
        textStrings.push(part.text);
      }
      if (part.executableCode) {
        textStrings.push("\n```" + part.executableCode.language + "\n" + part.executableCode.code + "\n```\n");
      }
      if (part.codeExecutionResult) {
        textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
      }
    }
  }
  if (textStrings.length > 0) {
    return textStrings.join("");
  } else {
    return "";
  }
}
function getFunctionCalls(response) {
  var _a5, _b, _c, _d;
  const functionCalls = [];
  if ((_b = (_a5 = response.candidates) === null || _a5 === void 0 ? void 0 : _a5[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
    for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
      if (part.functionCall) {
        functionCalls.push(part.functionCall);
      }
    }
  }
  if (functionCalls.length > 0) {
    return functionCalls;
  } else {
    return void 0;
  }
}
var badFinishReasons = [
  FinishReason.RECITATION,
  FinishReason.SAFETY,
  FinishReason.LANGUAGE
];
function hadBadFinishReason(candidate) {
  return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
}
function formatBlockErrorMessage(response) {
  var _a5, _b, _c;
  let message = "";
  if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
    message += "Response was blocked";
    if ((_a5 = response.promptFeedback) === null || _a5 === void 0 ? void 0 : _a5.blockReason) {
      message += ` due to ${response.promptFeedback.blockReason}`;
    }
    if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {
      message += `: ${response.promptFeedback.blockReasonMessage}`;
    }
  } else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {
    const firstCandidate = response.candidates[0];
    if (hadBadFinishReason(firstCandidate)) {
      message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
      if (firstCandidate.finishMessage) {
        message += `: ${firstCandidate.finishMessage}`;
      }
    }
  }
  return message;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function processStream(response) {
  const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
  const responseStream = getResponseStream(inputStream);
  const [stream1, stream2] = responseStream.tee();
  return {
    stream: generateResponseSequence(stream1),
    response: getResponsePromise(stream2)
  };
}
async function getResponsePromise(stream) {
  const allResponses = [];
  const reader = stream.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      return addHelpers(aggregateResponses(allResponses));
    }
    allResponses.push(value);
  }
}
function generateResponseSequence(stream) {
  return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
    const reader = stream.getReader();
    while (true) {
      const { value, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(addHelpers(value));
    }
  });
}
function getResponseStream(inputStream) {
  const reader = inputStream.getReader();
  const stream = new ReadableStream({
    start(controller) {
      let currentText = "";
      return pump();
      function pump() {
        return reader.read().then(({ value, done }) => {
          if (done) {
            if (currentText.trim()) {
              controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
              return;
            }
            controller.close();
            return;
          }
          currentText += value;
          let match = currentText.match(responseLineRE);
          let parsedResponse;
          while (match) {
            try {
              parsedResponse = JSON.parse(match[1]);
            } catch (e) {
              controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
              return;
            }
            controller.enqueue(parsedResponse);
            currentText = currentText.substring(match[0].length);
            match = currentText.match(responseLineRE);
          }
          return pump();
        }).catch((e) => {
          let err = e;
          err.stack = e.stack;
          if (err.name === "AbortError") {
            err = new GoogleGenerativeAIAbortError("Request aborted when reading from the stream");
          } else {
            err = new GoogleGenerativeAIError("Error reading from the stream");
          }
          throw err;
        });
      }
    }
  });
  return stream;
}
function aggregateResponses(responses) {
  const lastResponse = responses[responses.length - 1];
  const aggregatedResponse = {
    promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback
  };
  for (const response of responses) {
    if (response.candidates) {
      let candidateIndex = 0;
      for (const candidate of response.candidates) {
        if (!aggregatedResponse.candidates) {
          aggregatedResponse.candidates = [];
        }
        if (!aggregatedResponse.candidates[candidateIndex]) {
          aggregatedResponse.candidates[candidateIndex] = {
            index: candidateIndex
          };
        }
        aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
        aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
        aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
        aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
        aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
        if (candidate.content && candidate.content.parts) {
          if (!aggregatedResponse.candidates[candidateIndex].content) {
            aggregatedResponse.candidates[candidateIndex].content = {
              role: candidate.content.role || "user",
              parts: []
            };
          }
          const newPart = {};
          for (const part of candidate.content.parts) {
            if (part.text) {
              newPart.text = part.text;
            }
            if (part.functionCall) {
              newPart.functionCall = part.functionCall;
            }
            if (part.executableCode) {
              newPart.executableCode = part.executableCode;
            }
            if (part.codeExecutionResult) {
              newPart.codeExecutionResult = part.codeExecutionResult;
            }
            if (Object.keys(newPart).length === 0) {
              newPart.text = "";
            }
            aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
          }
        }
      }
      candidateIndex++;
    }
    if (response.usageMetadata) {
      aggregatedResponse.usageMetadata = response.usageMetadata;
    }
  }
  return aggregatedResponse;
}
async function generateContentStream(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(
    model,
    Task.STREAM_GENERATE_CONTENT,
    apiKey,
    /* stream */
    true,
    JSON.stringify(params),
    requestOptions
  );
  return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(
    model,
    Task.GENERATE_CONTENT,
    apiKey,
    /* stream */
    false,
    JSON.stringify(params),
    requestOptions
  );
  const responseJson = await response.json();
  const enhancedResponse = addHelpers(responseJson);
  return {
    response: enhancedResponse
  };
}
function formatSystemInstruction(input) {
  if (input == null) {
    return void 0;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
function formatNewContent(request) {
  let newParts = [];
  if (typeof request === "string") {
    newParts = [{ text: request }];
  } else {
    for (const partOrString of request) {
      if (typeof partOrString === "string") {
        newParts.push({ text: partOrString });
      } else {
        newParts.push(partOrString);
      }
    }
  }
  return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
  const userContent = { role: "user", parts: [] };
  const functionContent = { role: "function", parts: [] };
  let hasUserContent = false;
  let hasFunctionContent = false;
  for (const part of parts) {
    if ("functionResponse" in part) {
      functionContent.parts.push(part);
      hasFunctionContent = true;
    } else {
      userContent.parts.push(part);
      hasUserContent = true;
    }
  }
  if (hasUserContent && hasFunctionContent) {
    throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
  }
  if (!hasUserContent && !hasFunctionContent) {
    throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
  }
  if (hasUserContent) {
    return userContent;
  }
  return functionContent;
}
function formatCountTokensInput(params, modelParams) {
  var _a5;
  let formattedGenerateContentRequest = {
    model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,
    generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,
    safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,
    tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,
    toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,
    systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,
    cachedContent: (_a5 = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a5 === void 0 ? void 0 : _a5.name,
    contents: []
  };
  const containsGenerateContentRequest = params.generateContentRequest != null;
  if (params.contents) {
    if (containsGenerateContentRequest) {
      throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
    }
    formattedGenerateContentRequest.contents = params.contents;
  } else if (containsGenerateContentRequest) {
    formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
  } else {
    const content = formatNewContent(params);
    formattedGenerateContentRequest.contents = [content];
  }
  return { generateContentRequest: formattedGenerateContentRequest };
}
function formatGenerateContentInput(params) {
  let formattedRequest;
  if (params.contents) {
    formattedRequest = params;
  } else {
    const content = formatNewContent(params);
    formattedRequest = { contents: [content] };
  }
  if (params.systemInstruction) {
    formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
  }
  return formattedRequest;
}
function formatEmbedContentInput(params) {
  if (typeof params === "string" || Array.isArray(params)) {
    const content = formatNewContent(params);
    return { content };
  }
  return params;
}
var VALID_PART_FIELDS = [
  "text",
  "inlineData",
  "functionCall",
  "functionResponse",
  "executableCode",
  "codeExecutionResult"
];
var VALID_PARTS_PER_ROLE = {
  user: ["text", "inlineData"],
  function: ["functionResponse"],
  model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
  // System instructions shouldn't be in history anyway.
  system: ["text"]
};
function validateChatHistory(history) {
  let prevContent = false;
  for (const currContent of history) {
    const { role, parts } = currContent;
    if (!prevContent && role !== "user") {
      throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
    }
    if (!POSSIBLE_ROLES.includes(role)) {
      throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
    }
    if (!Array.isArray(parts)) {
      throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
    }
    if (parts.length === 0) {
      throw new GoogleGenerativeAIError("Each Content should have at least one part");
    }
    const countFields = {
      text: 0,
      inlineData: 0,
      functionCall: 0,
      functionResponse: 0,
      fileData: 0,
      executableCode: 0,
      codeExecutionResult: 0
    };
    for (const part of parts) {
      for (const key of VALID_PART_FIELDS) {
        if (key in part) {
          countFields[key] += 1;
        }
      }
    }
    const validParts = VALID_PARTS_PER_ROLE[role];
    for (const key of VALID_PART_FIELDS) {
      if (!validParts.includes(key) && countFields[key] > 0) {
        throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
      }
    }
    prevContent = true;
  }
}
function isValidResponse(response) {
  var _a5;
  if (response.candidates === void 0 || response.candidates.length === 0) {
    return false;
  }
  const content = (_a5 = response.candidates[0]) === null || _a5 === void 0 ? void 0 : _a5.content;
  if (content === void 0) {
    return false;
  }
  if (content.parts === void 0 || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === void 0 || Object.keys(part).length === 0) {
      return false;
    }
    if (part.text !== void 0 && part.text === "") {
      return false;
    }
  }
  return true;
}
var SILENT_ERROR = "SILENT_ERROR";
var ChatSession = class {
  constructor(apiKey, model, params, _requestOptions = {}) {
    this.model = model;
    this.params = params;
    this._requestOptions = _requestOptions;
    this._history = [];
    this._sendPromise = Promise.resolve();
    this._apiKey = apiKey;
    if (params === null || params === void 0 ? void 0 : params.history) {
      validateChatHistory(params.history);
      this._history = params.history;
    }
  }
  /**
   * Gets the chat history so far. Blocked prompts are not added to history.
   * Blocked candidates are not added to history, nor are the prompts that
   * generated them.
   */
  async getHistory() {
    await this._sendPromise;
    return this._history;
  }
  /**
   * Sends a chat message and receives a non-streaming
   * {@link GenerateContentResult}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessage(request, requestOptions = {}) {
    var _a5, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a5 = this.params) === null || _a5 === void 0 ? void 0 : _a5.safetySettings,
      generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
      tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
      toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    let finalResult;
    this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
      var _a6;
      if (isValidResponse(result.response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({
          parts: [],
          // Response seems to come back without a role set.
          role: "model"
        }, (_a6 = result.response.candidates) === null || _a6 === void 0 ? void 0 : _a6[0].content);
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(result.response);
        if (blockErrorMessage) {
          console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
      finalResult = result;
    }).catch((e) => {
      this._sendPromise = Promise.resolve();
      throw e;
    });
    await this._sendPromise;
    return finalResult;
  }
  /**
   * Sends a chat message and receives the response as a
   * {@link GenerateContentStreamResult} containing an iterable stream
   * and a response promise.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async sendMessageStream(request, requestOptions = {}) {
    var _a5, _b, _c, _d, _e, _f;
    await this._sendPromise;
    const newContent = formatNewContent(request);
    const generateContentRequest = {
      safetySettings: (_a5 = this.params) === null || _a5 === void 0 ? void 0 : _a5.safetySettings,
      generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
      tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
      toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
      systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
      cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
      contents: [...this._history, newContent]
    };
    const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
    this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
      throw new Error(SILENT_ERROR);
    }).then((streamResult) => streamResult.response).then((response) => {
      if (isValidResponse(response)) {
        this._history.push(newContent);
        const responseContent = Object.assign({}, response.candidates[0].content);
        if (!responseContent.role) {
          responseContent.role = "model";
        }
        this._history.push(responseContent);
      } else {
        const blockErrorMessage = formatBlockErrorMessage(response);
        if (blockErrorMessage) {
          console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
        }
      }
    }).catch((e) => {
      if (e.message !== SILENT_ERROR) {
        console.error(e);
      }
    });
    return streamPromise;
  }
};
async function countTokens(apiKey, model, params, singleRequestOptions) {
  const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
  return response.json();
}
async function embedContent(apiKey, model, params, requestOptions) {
  const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
  return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
  const requestsWithModel = params.requests.map((request) => {
    return Object.assign(Object.assign({}, request), { model });
  });
  const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
  return response.json();
}
var GenerativeModel = class {
  constructor(apiKey, modelParams, _requestOptions = {}) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
    if (modelParams.model.includes("/")) {
      this.model = modelParams.model;
    } else {
      this.model = `models/${modelParams.model}`;
    }
    this.generationConfig = modelParams.generationConfig || {};
    this.safetySettings = modelParams.safetySettings || [];
    this.tools = modelParams.tools;
    this.toolConfig = modelParams.toolConfig;
    this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
    this.cachedContent = modelParams.cachedContent;
  }
  /**
   * Makes a single non-streaming call to the model
   * and returns an object containing a single {@link GenerateContentResponse}.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContent(request, requestOptions = {}) {
    var _a5;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a5 = this.cachedContent) === null || _a5 === void 0 ? void 0 : _a5.name }, formattedParams), generativeModelRequestOptions);
  }
  /**
   * Makes a single streaming call to the model and returns an object
   * containing an iterable stream that iterates over all chunks in the
   * streaming response as well as a promise that returns the final
   * aggregated response.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async generateContentStream(request, requestOptions = {}) {
    var _a5;
    const formattedParams = formatGenerateContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a5 = this.cachedContent) === null || _a5 === void 0 ? void 0 : _a5.name }, formattedParams), generativeModelRequestOptions);
  }
  /**
   * Gets a new {@link ChatSession} instance which can be used for
   * multi-turn chats.
   */
  startChat(startChatParams) {
    var _a5;
    return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a5 = this.cachedContent) === null || _a5 === void 0 ? void 0 : _a5.name }, startChatParams), this._requestOptions);
  }
  /**
   * Counts the tokens in the provided request.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async countTokens(request, requestOptions = {}) {
    const formattedParams = formatCountTokensInput(request, {
      model: this.model,
      generationConfig: this.generationConfig,
      safetySettings: this.safetySettings,
      tools: this.tools,
      toolConfig: this.toolConfig,
      systemInstruction: this.systemInstruction,
      cachedContent: this.cachedContent
    });
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  /**
   * Embeds the provided content.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async embedContent(request, requestOptions = {}) {
    const formattedParams = formatEmbedContentInput(request);
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
  }
  /**
   * Embeds an array of {@link EmbedContentRequest}s.
   *
   * Fields set in the optional {@link SingleRequestOptions} parameter will
   * take precedence over the {@link RequestOptions} values provided to
   * {@link GoogleGenerativeAI.getGenerativeModel }.
   */
  async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
    const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
  }
};
var GoogleGenerativeAI = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }
  /**
   * Gets a {@link GenerativeModel} instance for the provided model name.
   */
  getGenerativeModel(modelParams, requestOptions) {
    if (!modelParams.model) {
      throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
    }
    return new GenerativeModel(this.apiKey, modelParams, requestOptions);
  }
  /**
   * Creates a {@link GenerativeModel} instance from provided content cache.
   */
  getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
    if (!cachedContent.name) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
    }
    if (!cachedContent.model) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
    }
    const disallowedDuplicates = ["model", "systemInstruction"];
    for (const key of disallowedDuplicates) {
      if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {
        if (key === "model") {
          const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
          const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
          if (modelParamsComp === cachedContentComp) {
            continue;
          }
        }
        throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
      }
    }
    const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
    return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
  }
};

// src/services/providers/GeminiProvider.ts
var GeminiProvider = class {
  name = "Gemini";
  client = null;
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model || "gemini-1.5-flash";
  }
  getClient() {
    if (!this.client && this.apiKey && this.apiKey.trim().length > 0) {
      try {
        this.client = new GoogleGenerativeAI(this.apiKey);
      } catch (error) {
        Logger.warn("Failed to initialize Gemini client:", error);
        throw new Error("Failed to initialize Gemini client");
      }
    }
    if (!this.client) {
      throw new Error("Gemini client not initialized");
    }
    return this.client;
  }
  async authenticate(apiKey) {
    return apiKey.trim().length > 0;
  }
  isAvailable() {
    return this.apiKey.trim().length > 0;
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("Gemini provider is not available");
    }
    const prompt = this.constructPrompt(text);
    try {
      const client = this.getClient();
      const genModel = client.getGenerativeModel({ model: this.model });
      const result = await genModel.generateContent(prompt);
      const response = await result.response;
      const content = response.text();
      return this.parseResponse(content);
    } catch (error) {
      const err = error;
      if (err?.status === 429 || err?.response?.status === 429) {
        throw new Error("Rate limit exceeded. Please try again later.");
      }
      if (err?.status === 401 || err?.response?.status === 401) {
        throw new Error("Invalid API key. Please check your Gemini API key.");
      }
      if (error instanceof Error) {
        const message = error.message || "Unknown error";
        throw new Error(`Gemini API error: ${message}`);
      }
      throw new Error("Gemini API error: Request failed");
    }
  }
  constructPrompt(text) {
    return `Classify this idea into one category and suggest 2-4 relevant tags.

Idea: "${text}"

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Rules:
- Choose the single best category
- Tags should be specific and relevant (2-4 tags)
- Use lowercase for category and tags

Example response:
{
  "category": "game",
  "tags": ["rpg", "fantasy", "multiplayer"]
}

Response:`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: parsed.confidence || 0.8
      };
    } catch (error) {
      Logger.warn("Failed to parse Gemini response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
};

// node_modules/groq-sdk/version.mjs
var VERSION3 = "0.37.0";

// node_modules/groq-sdk/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'groq-sdk/shims/${shims.kind}'\` before importing anything else from groq-sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import 'groq-sdk/shims/${shims.kind}'\` after \`import 'groq-sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/groq-sdk/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/groq-sdk/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'groq-sdk'\`:
- \`import 'groq-sdk/shims/node'\` (if you're running on Node)
- \`import 'groq-sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/groq-sdk/_shims/index.mjs
var init = () => {
  if (!kind)
    setShims(getRuntime(), { auto: true });
};
init();

// node_modules/groq-sdk/error.mjs
var GroqError = class extends Error {
};
var APIError3 = class _APIError extends GroqError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError3({ message, cause: castToError3(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError3(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError3(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError3(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError3(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError3(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError3(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError3(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError3(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError3 = class extends APIError3 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError3 = class extends APIError3 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError3 = class extends APIConnectionError3 {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError3 = class extends APIError3 {
};
var AuthenticationError3 = class extends APIError3 {
};
var PermissionDeniedError3 = class extends APIError3 {
};
var NotFoundError3 = class extends APIError3 {
};
var ConflictError3 = class extends APIError3 {
};
var UnprocessableEntityError3 = class extends APIError3 {
};
var RateLimitError3 = class extends APIError3 {
};
var InternalServerError3 = class extends APIError3 {
};

// node_modules/groq-sdk/lib/streaming.mjs
var Stream3 = class _Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder3();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new GroqError(`Attempted to iterate over a response with no body`);
      }
      const lineDecoder = new LineDecoder3();
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || sse.event === "error") {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError3(data.error.status_code, data.error, data.error.message, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder3();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller),
      new _Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
var SSEDecoder3 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition3(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder3 = class _LineDecoder {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = _LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(_LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new GroqError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new GroqError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new GroqError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder3.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder3.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition3(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/groq-sdk/uploads.mjs
var isResponseLike3 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike3 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike3(value);
var isBlobLike3 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable2 = (value) => {
  return isFileLike3(value) || isResponseLike3(value) || isFsReadStream(value);
};
async function toFile3(value, name, options) {
  value = await value;
  if (isFileLike3(value)) {
    return value;
  }
  if (isResponseLike3(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike3(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes3(value);
  name || (name = getName3(value) ?? "unknown_file");
  if (!options?.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes3(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike3(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError3(value)}`);
  }
  return parts;
}
function propsForError3(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName3(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions3 = async (opts) => {
  const form = await createForm3(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm3 = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue3(form, key, value)));
  return form;
};
var addFormValue3 = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable2(value)) {
    const file = await toFile3(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue3(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue3(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/groq-sdk/core.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _APIClient_baseURLOverridden;
var _AbstractPage_client3;
init();
async function defaultParseResponse3(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream3.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const mediaType = contentType?.split(";")[0]?.trim();
  const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise3 = class _APIPromise extends Promise {
  constructor(responsePromise, parseResponse2 = defaultParseResponse3) {
    super((resolve4) => {
      resolve4(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
  }
  _thenUnwrap(transform) {
    return new _APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props), props));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import  from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    baseURLOverridden,
    maxRetries = 2,
    timeout = 6e4,
    // 1 minute
    httpAgent,
    fetch: overriddenFetch
  }) {
    _APIClient_baseURLOverridden.set(this, void 0);
    this.baseURL = baseURL;
    __classPrivateFieldSet3(this, _APIClient_baseURLOverridden, baseURLOverridden, "f");
    this.maxRetries = validatePositiveInteger3("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger3("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch ?? fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      ...["head", "get"].includes(opts.method) ? {} : { "Content-Type": "application/json" },
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders3(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid43()}`;
  }
  get(path9, opts) {
    return this.methodRequest("get", path9, opts);
  }
  post(path9, opts) {
    return this.methodRequest("post", path9, opts);
  }
  patch(path9, opts) {
    return this.methodRequest("patch", path9, opts);
  }
  put(path9, opts) {
    return this.methodRequest("put", path9, opts);
  }
  delete(path9, opts) {
    return this.methodRequest("delete", path9, opts);
  }
  methodRequest(method, path9, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike3(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path: path9, ...opts2, body };
    }));
  }
  getAPIList(path9, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path: path9, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path9, query, defaultBaseURL, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path9, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger3("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = options.timeout + 1e3;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!inputOptions.idempotencyKey)
        inputOptions.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = inputOptions.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout: options.timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    if (getHeader(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader(headers, "x-stainless-timeout") === void 0 && options.timeout) {
      reqHeaders["x-stainless-timeout"] = String(Math.trunc(options.timeout / 1e3));
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError3.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise3(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError3();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError3);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError3();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError3();
      }
      throw new APIConnectionError3({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError3(e).message);
      const errJSON = safeJSON3(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page3, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise3(this, request, Page3);
  }
  buildURL(path9, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet3(this, _APIClient_baseURLOverridden, "f") && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL3(path9) ? new URL(path9) : new URL(baseURL + (baseURL.endsWith("/") && path9.startsWith("/") ? path9.slice(1) : path9));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj3(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new GroqError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init2, ms, controller) {
    const { signal, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep3(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION3}`;
  }
};
_APIClient_baseURLOverridden = /* @__PURE__ */ new WeakMap();
var AbstractPage3 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client3.set(this, void 0);
    __classPrivateFieldSet3(this, _AbstractPage_client3, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new GroqError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet3(this, _AbstractPage_client3, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client3 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise3 = class extends APIPromise3 {
  constructor(client, request, Page3) {
    super(request, async (props) => new Page3(client, props.response, await defaultParseResponse3(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var getPlatformProperties3 = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": normalizePlatform3(Deno.build.os),
      "X-Stainless-Arch": normalizeArch3(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": normalizePlatform3(process.platform),
      "X-Stainless-Arch": normalizeArch3(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo3();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION3,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo3() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch3 = (arch3) => {
  if (arch3 === "x32")
    return "x32";
  if (arch3 === "x86_64" || arch3 === "x64")
    return "x64";
  if (arch3 === "arm")
    return "arm";
  if (arch3 === "aarch64" || arch3 === "arm64")
    return "arm64";
  if (arch3)
    return `other:${arch3}`;
  return "unknown";
};
var normalizePlatform3 = (platform3) => {
  platform3 = platform3.toLowerCase();
  if (platform3.includes("ios"))
    return "iOS";
  if (platform3 === "android")
    return "Android";
  if (platform3 === "darwin")
    return "MacOS";
  if (platform3 === "win32")
    return "Windows";
  if (platform3 === "freebsd")
    return "FreeBSD";
  if (platform3 === "openbsd")
    return "OpenBSD";
  if (platform3 === "linux")
    return "Linux";
  if (platform3)
    return `Other:${platform3}`;
  return "Unknown";
};
var _platformHeaders3;
var getPlatformHeaders3 = () => {
  return _platformHeaders3 ?? (_platformHeaders3 = getPlatformProperties3());
};
var safeJSON3 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp3 = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL3 = (url) => {
  return startsWithSchemeRegexp3.test(url);
};
var sleep3 = (ms) => new Promise((resolve4) => setTimeout(resolve4, ms));
var validatePositiveInteger3 = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new GroqError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new GroqError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError3 = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
var readEnv3 = (env) => {
  if (typeof process !== "undefined") {
    return process.env?.[env]?.trim() ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};
function isEmptyObj3(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn3(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn3(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    console.log(`Groq:DEBUG:${action}`, ...args);
  }
}
var uuid43 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser3 = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof headers?.get === "function";
};
var getHeader = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};

// node_modules/groq-sdk/resource.mjs
var APIResource3 = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/groq-sdk/resources/audio/speech.mjs
var Speech2 = class extends APIResource3 {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'The quick brown fox jumped over the lazy dog',
   *   model: 'playai-tts',
   *   voice: 'Fritz-PlayAI',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/speech", {
      body,
      ...options,
      headers: { Accept: "audio/wav", ...options?.headers },
      __binaryResponse: true
    });
  }
};

// node_modules/groq-sdk/resources/audio/transcriptions.mjs
var Transcriptions2 = class extends APIResource3 {
  /**
   * Transcribes audio into the input language.
   *
   * @example
   * ```ts
   * const transcription =
   *   await client.audio.transcriptions.create({
   *     model: 'whisper-large-v3-turbo',
   *   });
   * ```
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/transcriptions", multipartFormRequestOptions3({ body, ...options }));
  }
};

// node_modules/groq-sdk/resources/audio/translations.mjs
var Translations2 = class extends APIResource3 {
  /**
   * Translates audio into English.
   *
   * @example
   * ```ts
   * const translation = await client.audio.translations.create({
   *   model: 'whisper-large-v3-turbo',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/translations", multipartFormRequestOptions3({ body, ...options }));
  }
};

// node_modules/groq-sdk/resources/audio/audio.mjs
var Audio2 = class extends APIResource3 {
  constructor() {
    super(...arguments);
    this.speech = new Speech2(this._client);
    this.transcriptions = new Transcriptions2(this._client);
    this.translations = new Translations2(this._client);
  }
};
Audio2.Speech = Speech2;
Audio2.Transcriptions = Transcriptions2;
Audio2.Translations = Translations2;

// node_modules/groq-sdk/resources/batches.mjs
var Batches4 = class extends APIResource3 {
  /**
   * Creates and executes a batch from an uploaded file of requests.
   * [Learn more](/docs/batch).
   */
  create(body, options) {
    return this._client.post("/openai/v1/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/openai/v1/batches/${batchId}`, options);
  }
  /**
   * List your organization's batches.
   */
  list(options) {
    return this._client.get("/openai/v1/batches", options);
  }
  /**
   * Cancels a batch.
   */
  cancel(batchId, options) {
    return this._client.post(`/openai/v1/batches/${batchId}/cancel`, options);
  }
};

// node_modules/groq-sdk/resources/chat/completions.mjs
var Completions4 = class extends APIResource3 {
  create(body, options) {
    return this._client.post("/openai/v1/chat/completions", {
      body,
      ...options,
      stream: body.stream ?? false
    });
  }
};

// node_modules/groq-sdk/resources/chat/chat.mjs
var Chat2 = class extends APIResource3 {
  constructor() {
    super(...arguments);
    this.completions = new Completions4(this._client);
  }
};
Chat2.Completions = Completions4;

// node_modules/groq-sdk/resources/completions.mjs
var Completions5 = class extends APIResource3 {
};

// node_modules/groq-sdk/resources/embeddings.mjs
var Embeddings2 = class extends APIResource3 {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'nomic-embed-text-v1_5',
   *   });
   * ```
   */
  create(body, options) {
    return this._client.post("/openai/v1/embeddings", { body, ...options });
  }
};

// node_modules/groq-sdk/resources/files.mjs
var Files5 = class extends APIResource3 {
  /**
   * Upload a file that can be used across various endpoints.
   *
   * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also
   * has a specific required [format](/docs/batch).
   *
   * Please contact us if you need to increase these storage limits.
   */
  create(body, options) {
    return this._client.post("/openai/v1/files", multipartFormRequestOptions3({ body, ...options }));
  }
  /**
   * Returns a list of files.
   */
  list(options) {
    return this._client.get("/openai/v1/files", options);
  }
  /**
   * Delete a file.
   */
  delete(fileId, options) {
    return this._client.delete(`/openai/v1/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/openai/v1/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/octet-stream", ...options?.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns information about a file.
   */
  info(fileId, options) {
    return this._client.get(`/openai/v1/files/${fileId}`, options);
  }
};

// node_modules/groq-sdk/resources/models.mjs
var Models4 = class extends APIResource3 {
  /**
   * Get a specific model
   */
  retrieve(model, options) {
    return this._client.get(`/openai/v1/models/${model}`, options);
  }
  /**
   * get all available models
   */
  list(options) {
    return this._client.get("/openai/v1/models", options);
  }
  /**
   * Delete a model
   */
  delete(model, options) {
    return this._client.delete(`/openai/v1/models/${model}`, options);
  }
};

// node_modules/groq-sdk/index.mjs
var _Groq_instances;
var _a4;
var _Groq_baseURLOverridden;
var Groq = class extends APIClient {
  /**
   * API Client for interfacing with the Groq API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv3("GROQ_BASE_URL"), apiKey = readEnv3("GROQ_API_KEY"), ...opts } = {}) {
    if (apiKey === void 0) {
      throw new GroqError("The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      ...opts,
      baseURL: baseURL || `https://api.groq.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser3()) {
      throw new GroqError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Groq({ apiKey, dangerouslyAllowBrowser: true })");
    }
    super({
      baseURL: options.baseURL,
      baseURLOverridden: baseURL ? baseURL !== "https://api.groq.com" : false,
      timeout: options.timeout ?? 6e4,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    _Groq_instances.add(this);
    this.completions = new Completions5(this);
    this.chat = new Chat2(this);
    this.embeddings = new Embeddings2(this);
    this.audio = new Audio2(this);
    this.models = new Models4(this);
    this.batches = new Batches4(this);
    this.files = new Files5(this);
    this._options = options;
    this.apiKey = apiKey;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a4 = Groq, _Groq_instances = /* @__PURE__ */ new WeakSet(), _Groq_baseURLOverridden = function _Groq_baseURLOverridden2() {
  return this.baseURL !== "https://api.groq.com";
};
Groq.Groq = _a4;
Groq.DEFAULT_TIMEOUT = 6e4;
Groq.GroqError = GroqError;
Groq.APIError = APIError3;
Groq.APIConnectionError = APIConnectionError3;
Groq.APIConnectionTimeoutError = APIConnectionTimeoutError3;
Groq.APIUserAbortError = APIUserAbortError3;
Groq.NotFoundError = NotFoundError3;
Groq.ConflictError = ConflictError3;
Groq.RateLimitError = RateLimitError3;
Groq.BadRequestError = BadRequestError3;
Groq.AuthenticationError = AuthenticationError3;
Groq.InternalServerError = InternalServerError3;
Groq.PermissionDeniedError = PermissionDeniedError3;
Groq.UnprocessableEntityError = UnprocessableEntityError3;
Groq.toFile = toFile3;
Groq.fileFromPath = fileFromPath;
Groq.Completions = Completions5;
Groq.Chat = Chat2;
Groq.Embeddings = Embeddings2;
Groq.Audio = Audio2;
Groq.Models = Models4;
Groq.Batches = Batches4;
Groq.Files = Files5;
var groq_sdk_default = Groq;

// src/services/providers/GroqProvider.ts
var GroqProvider = class {
  name = "Groq";
  client = null;
  apiKey;
  model;
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model || "llama-3.3-70b-versatile";
  }
  getClient() {
    if (!this.client && this.apiKey && this.apiKey.trim().length > 0) {
      try {
        this.client = new groq_sdk_default({ apiKey: this.apiKey });
      } catch (error) {
        Logger.warn("Failed to initialize Groq client:", error);
        throw new Error("Failed to initialize Groq client");
      }
    }
    if (!this.client) {
      throw new Error("Groq client not initialized");
    }
    return this.client;
  }
  async authenticate(apiKey) {
    return apiKey.trim().length > 0;
  }
  isAvailable() {
    return this.apiKey.trim().length > 0;
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("Groq provider is not available");
    }
    const prompt = this.constructPrompt(text);
    try {
      const client = this.getClient();
      const response = await client.chat.completions.create({
        model: this.model,
        messages: [{
          role: "user",
          content: prompt
        }],
        max_tokens: 256,
        temperature: 0.1
      });
      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error("No content in Groq response");
      }
      return this.parseResponse(content);
    } catch (error) {
      const err = error;
      if (err?.status === 429 || err?.response?.status === 429) {
        throw new Error("Rate limit exceeded. Please try again later.");
      }
      if (err?.status === 401 || err?.response?.status === 401) {
        throw new Error("Invalid API key. Please check your Groq API key.");
      }
      if (error instanceof Error) {
        const message = error.message || "Unknown error";
        throw new Error(`Groq API error: ${message}`);
      }
      throw new Error("Groq API error: Request failed");
    }
  }
  constructPrompt(text) {
    return `Classify this idea into one category and suggest 2-4 relevant tags.

Idea: "${text}"

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Rules:
- Choose the single best category
- Tags should be specific and relevant (2-4 tags)
- Use lowercase for category and tags

Example response:
{
  "category": "game",
  "tags": ["rpg", "fantasy", "multiplayer"]
}

Response:`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: parsed.confidence || 0.8
      };
    } catch (error) {
      Logger.warn("Failed to parse Groq response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
};

// src/services/providers/OpenRouterProvider.ts
var OpenRouterProvider = class {
  name = "OpenRouter";
  apiKey;
  model;
  baseUrl = "https://openrouter.ai/api/v1/chat/completions";
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model || "openai/gpt-4o-mini";
  }
  async authenticate(apiKey) {
    return apiKey.trim().length > 0;
  }
  isAvailable() {
    return this.apiKey.trim().length > 0;
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("OpenRouter provider is not available");
    }
    const prompt = this.constructPrompt(text);
    try {
      const response = await fetch(this.baseUrl, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`,
          "Content-Type": "application/json",
          "HTTP-Referer": "https://github.com/FallingWithStyle/obsidian-ideatr",
          "X-Title": "Ideatr"
        },
        body: JSON.stringify({
          model: this.model,
          messages: [{
            role: "user",
            content: prompt
          }],
          max_tokens: 256,
          temperature: 0.1
        })
      });
      if (!response.ok) {
        if (response.status === 429) {
          throw new Error("Rate limit exceeded. Please try again later.");
        }
        if (response.status === 401) {
          throw new Error("Invalid API key. Please check your OpenRouter API key.");
        }
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`OpenRouter API error: ${errorData.error || response.statusText}`);
      }
      const data = await response.json();
      const content = data.choices?.[0]?.message?.content;
      if (!content) {
        throw new Error("No content in OpenRouter response");
      }
      return this.parseResponse(content);
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("Rate limit")) {
          throw error;
        }
        if (error.message.includes("Invalid API key")) {
          throw error;
        }
        throw new Error(`OpenRouter API error: ${error.message}`);
      }
      throw new Error("OpenRouter API error: Request failed");
    }
  }
  constructPrompt(text) {
    return `Classify this idea into one category and suggest 2-4 relevant tags.

Idea: "${text}"

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Rules:
- Choose the single best category
- Tags should be specific and relevant (2-4 tags)
- Use lowercase for category and tags

Example response:
{
  "category": "game",
  "tags": ["rpg", "fantasy", "multiplayer"]
}

Response:`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: parsed.confidence || 0.8
      };
    } catch (error) {
      Logger.warn("Failed to parse OpenRouter response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
};

// src/services/providers/CustomEndpointProvider.ts
var CustomEndpointProvider = class {
  name = "Custom Endpoint";
  endpointUrl;
  format;
  constructor(endpointUrl, format = "ollama") {
    this.endpointUrl = endpointUrl;
    this.format = format;
  }
  async authenticate(endpointUrl) {
    try {
      new URL(endpointUrl);
      return endpointUrl.trim().length > 0;
    } catch {
      return false;
    }
  }
  isAvailable() {
    return this.endpointUrl.trim().length > 0;
  }
  async classify(text) {
    if (!this.isAvailable()) {
      throw new Error("Custom endpoint provider is not available");
    }
    const prompt = this.constructPrompt(text);
    try {
      let requestBody;
      let responsePath;
      if (this.format === "ollama") {
        requestBody = {
          model: "llama3.2",
          messages: [{
            role: "user",
            content: prompt
          }],
          stream: false
        };
        responsePath = "message.content";
      } else {
        requestBody = {
          model: "gpt-4o-mini",
          messages: [{
            role: "user",
            content: prompt
          }],
          max_tokens: 256,
          temperature: 0.1
        };
        responsePath = "choices[0].message.content";
      }
      const response = await fetch(this.endpointUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Custom endpoint error: ${errorData.error || response.statusText}`);
      }
      const data = await response.json();
      let content;
      if (responsePath === "message.content") {
        content = data.message?.content || "";
      } else {
        content = data.choices?.[0]?.message?.content || "";
      }
      if (!content) {
        throw new Error("No content in custom endpoint response");
      }
      return this.parseResponse(content);
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Custom endpoint error: ${error.message}`);
      }
      throw new Error("Custom endpoint error: Request failed");
    }
  }
  constructPrompt(text) {
    return `Classify this idea into one category and suggest 2-4 relevant tags.

Idea: "${text}"

Categories: game, saas, tool, story, mechanic, hardware, ip, brand, ux, personal

Rules:
- Choose the single best category
- Tags should be specific and relevant (2-4 tags)
- Use lowercase for category and tags

Example response:
{
  "category": "game",
  "tags": ["rpg", "fantasy", "multiplayer"]
}

Response:`;
  }
  parseResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      return {
        category: this.validateCategory(parsed.category),
        tags: Array.isArray(parsed.tags) ? parsed.tags.slice(0, 5) : [],
        confidence: parsed.confidence || 0.8
      };
    } catch (error) {
      Logger.warn("Failed to parse custom endpoint response:", content, error);
      return {
        category: "",
        tags: [],
        confidence: 0
      };
    }
  }
  validateCategory(category) {
    const validCategories = [
      "game",
      "saas",
      "tool",
      "story",
      "mechanic",
      "hardware",
      "ip",
      "brand",
      "ux",
      "personal"
    ];
    const normalized = category?.toLowerCase().trim();
    return validCategories.includes(normalized) ? normalized : "";
  }
};

// src/services/providers/ProviderFactory.ts
var ProviderFactory = class {
  /**
   * Create a provider instance based on type
   */
  static createProvider(providerType, apiKey, settings) {
    switch (providerType) {
      case "anthropic":
        return new AnthropicProvider(apiKey, settings?.customModel);
      case "openai":
        return new OpenAIProvider(apiKey, settings?.customModel);
      case "gemini":
        return new GeminiProvider(apiKey, settings?.customModel);
      case "groq":
        return new GroqProvider(apiKey, settings?.customModel);
      case "openrouter":
        return new OpenRouterProvider(apiKey, settings?.openRouterModel);
      case "custom":
        if (!settings?.customEndpointUrl) {
          throw new Error("Custom endpoint URL is required for custom provider");
        }
        const format = settings.customEndpointUrl.includes("/v1/chat/completions") ? "openai" : "ollama";
        return new CustomEndpointProvider(settings.customEndpointUrl, format);
      case "custom-model":
        if (!settings?.customModelProvider || !settings?.customModel) {
          throw new Error("Custom model provider and model are required for custom-model provider");
        }
        const customProviderType = settings.customModelProvider;
        switch (customProviderType) {
          case "anthropic":
            return new AnthropicProvider(apiKey, settings.customModel);
          case "openai":
            return new OpenAIProvider(apiKey, settings.customModel);
          case "gemini":
            return new GeminiProvider(apiKey, settings.customModel);
          case "groq":
            return new GroqProvider(apiKey, settings.customModel);
          default:
            throw new Error(`Unsupported custom model provider: ${customProviderType}`);
        }
      case "none":
        throw new Error('Cannot create provider for type "none"');
      default:
        throw new Error(`Unknown provider type: ${providerType}`);
    }
  }
};

// src/utils/ModelValidator.ts
var CLOUD_MODELS = {
  // Anthropic Models
  "anthropic-haiku": {
    key: "anthropic-haiku",
    name: "Claude 3.5 Haiku",
    badge: "EFFICIENT",
    provider: "anthropic",
    modelId: "claude-3-5-haiku-20241022",
    description: "Fast, cost-effective model ideal for classification tasks. Excellent at structured work like categorization and tagging.",
    quality: 4,
    speed: 5,
    cost: "low",
    costEstimate: "~$0.002 per idea",
    pros: ["Fast", "Cost-effective", "Good accuracy", "Low latency"],
    cons: ["Less nuanced than larger models"],
    bestFor: "Most users"
  },
  "anthropic-sonnet": {
    key: "anthropic-sonnet",
    name: "Claude 3.5 Sonnet",
    badge: "BALANCED",
    provider: "anthropic",
    modelId: "claude-3-5-sonnet-20241022",
    description: "Balanced performance with better reasoning and accuracy. Great for complex or nuanced classification tasks.",
    quality: 4.5,
    speed: 4,
    cost: "medium",
    costEstimate: "~$0.015 per idea",
    pros: ["Better reasoning", "Higher accuracy", "Handles complexity well"],
    cons: ["More expensive", "Slightly slower"],
    bestFor: "Users who want better quality"
  },
  "anthropic-opus": {
    key: "anthropic-opus",
    name: "Claude 3 Opus",
    badge: "PREMIUM",
    provider: "anthropic",
    modelId: "claude-3-opus-20240229",
    description: "Highest quality model for complex or nuanced classification. Best for edge cases and ambiguous ideas.",
    quality: 5,
    speed: 2,
    cost: "high",
    costEstimate: "~$0.15 per idea",
    pros: ["Best quality", "Excellent reasoning", "Handles edge cases"],
    cons: ["Expensive", "Slower", "Overkill for simple tasks"],
    bestFor: "Power users with complex ideas"
  },
  // OpenAI Models
  "openai-mini": {
    key: "openai-mini",
    name: "GPT-4o Mini",
    badge: "EFFICIENT",
    provider: "openai",
    modelId: "gpt-4o-mini",
    description: "Fast, cost-effective model ideal for classification tasks. Excellent at structured work like categorization and tagging.",
    quality: 4,
    speed: 5,
    cost: "low",
    costEstimate: "~$0.001 per idea",
    pros: ["Very fast", "Most cost-effective", "Good accuracy", "Low latency"],
    cons: ["Less nuanced than GPT-4o"],
    bestFor: "Most users"
  },
  "openai-4o": {
    key: "openai-4o",
    name: "GPT-4o",
    badge: "BALANCED",
    provider: "openai",
    modelId: "gpt-4o",
    description: "High-quality model with excellent reasoning capabilities. Great for complex or nuanced classification tasks.",
    quality: 4.5,
    speed: 4,
    cost: "medium",
    costEstimate: "~$0.01 per idea",
    pros: ["Better reasoning", "Higher accuracy", "Handles complexity well"],
    cons: ["More expensive", "Slightly slower"],
    bestFor: "Users who want better quality"
  },
  // Gemini Models
  "gemini-flash": {
    key: "gemini-flash",
    name: "Gemini 1.5 Flash",
    badge: "EFFICIENT",
    provider: "gemini",
    modelId: "gemini-1.5-flash",
    description: "Fast, cost-effective model ideal for classification tasks. Excellent at structured work like categorization and tagging.",
    quality: 4,
    speed: 5,
    cost: "low",
    costEstimate: "~$0.0005 per idea",
    pros: ["Very fast", "Most cost-effective", "Good accuracy", "Low latency"],
    cons: ["Less nuanced than Pro"],
    bestFor: "Most users"
  },
  "gemini-pro": {
    key: "gemini-pro",
    name: "Gemini 1.5 Pro",
    badge: "BALANCED",
    provider: "gemini",
    modelId: "gemini-1.5-pro",
    description: "High-quality model with better reasoning and accuracy. Great for complex or nuanced classification tasks.",
    quality: 4.5,
    speed: 4,
    cost: "medium",
    costEstimate: "~$0.005 per idea",
    pros: ["Better reasoning", "Higher accuracy", "Handles complexity well"],
    cons: ["More expensive", "Slightly slower"],
    bestFor: "Users who want better quality"
  },
  // Groq Models
  "groq-llama-70b": {
    key: "groq-llama-70b",
    name: "Llama 3.3 70B Versatile",
    badge: "BALANCED",
    provider: "groq",
    modelId: "llama-3.3-70b-versatile",
    description: "High-quality model with excellent reasoning. Fast inference via Groq's infrastructure.",
    quality: 4.5,
    speed: 5,
    cost: "low",
    costEstimate: "Free (via Groq)",
    pros: ["Free", "Very fast", "High quality", "Excellent reasoning"],
    cons: ["Requires Groq API key"],
    bestFor: "Users who want free high-quality AI"
  },
  "groq-mixtral": {
    key: "groq-mixtral",
    name: "Mixtral 8x7B",
    badge: "VERSATILE",
    provider: "groq",
    modelId: "mixtral-8x7b-32768",
    description: "High-quality mixture-of-experts model. Fast inference via Groq's infrastructure.",
    quality: 4.5,
    speed: 5,
    cost: "low",
    costEstimate: "Free (via Groq)",
    pros: ["Free", "Very fast", "High quality", "Mixture-of-experts"],
    cons: ["Requires Groq API key"],
    bestFor: "Users who want free high-quality AI"
  }
};
function getCloudModelsByProvider(provider) {
  return Object.values(CLOUD_MODELS).filter((m) => m.provider === provider);
}

// src/settings/sections/CloudAISettingsSection.ts
var CloudAISettingsSection = class extends BaseSettingsSection {
  showComparison = false;
  display(containerEl) {
    containerEl.createEl("h3", { text: "Cloud AI" });
    const comparisonContainer = containerEl.createDiv({ cls: "cloud-model-comparison-container" });
    const comparisonButton = comparisonContainer.createEl("button", {
      text: this.showComparison ? "\u25BC Hide Model Comparison" : "\u25B6 Show Model Comparison",
      cls: "mod-link"
    });
    comparisonButton.style.marginBottom = "1em";
    comparisonButton.addEventListener("click", () => {
      this.showComparison = !this.showComparison;
      comparisonButton.textContent = this.showComparison ? "\u25BC Hide Model Comparison" : "\u25B6 Show Model Comparison";
      const comparisonSection2 = containerEl.querySelector(".cloud-model-comparison-section");
      if (comparisonSection2) {
        comparisonSection2.style.display = this.showComparison ? "block" : "none";
      }
    });
    const comparisonSection = containerEl.createDiv({ cls: "cloud-model-comparison-section" });
    comparisonSection.style.display = "none";
    this.renderModelComparison(comparisonSection);
    new import_obsidian11.Setting(containerEl).setName("Enable Cloud AI").setDesc("Use cloud AI providers for better quality and faster responses (requires API key)").addToggle((toggle) => toggle.setValue(this.plugin.settings.cloudProvider !== "none").onChange(async (value) => {
      if (value) {
        if (this.plugin.settings.cloudProvider === "none") {
          this.plugin.settings.cloudProvider = "anthropic";
        }
        this.plugin.settings.preferCloud = true;
      } else {
        this.plugin.settings.cloudProvider = "none";
        this.plugin.settings.preferCloud = false;
      }
      await this.saveSettings();
      this.refresh();
    }));
    const hasAnyApiKey = this.plugin.settings.cloudApiKeys && Object.values(this.plugin.settings.cloudApiKeys).some((key) => key && key.length > 0) || this.plugin.settings.cloudApiKey && this.plugin.settings.cloudApiKey.length > 0;
    if (this.plugin.settings.cloudProvider !== "none" || hasAnyApiKey) {
      new import_obsidian11.Setting(containerEl).setName("Cloud Provider").setDesc("Select the cloud AI provider").addDropdown((dropdown) => {
        dropdown.addOption("anthropic", "Anthropic (Claude 3.5 Haiku)").addOption("openai", "OpenAI (GPT-4o Mini)").addOption("gemini", "Google Gemini (Gemini 1.5 Flash)").addOption("groq", "Groq (Llama 3.3 70B)").addOption("openrouter", "OpenRouter (Multiple Models)").addOption("custom", "Custom Endpoint (Ollama/LM Studio)").addOption("none", "None").setValue(this.plugin.settings.cloudProvider === "none" ? "none" : this.plugin.settings.cloudProvider).onChange(async (value) => {
          this.plugin.settings.cloudProvider = value;
          await this.saveSettings();
          this.refresh();
        });
      });
      if (this.plugin.settings.cloudProvider !== "none") {
        if (this.plugin.settings.cloudProvider !== "custom") {
          const providerNames = {
            "anthropic": "Anthropic",
            "openai": "OpenAI",
            "gemini": "Google Gemini",
            "groq": "Groq",
            "openrouter": "OpenRouter"
          };
          const apiKeyUrls = {
            "anthropic": "https://console.anthropic.com/",
            "openai": "https://platform.openai.com/api-keys",
            "gemini": "https://makersuite.google.com/app/apikey",
            "groq": "https://console.groq.com/keys",
            "openrouter": "https://openrouter.ai/keys"
          };
          const currentProvider = this.plugin.settings.cloudProvider;
          let currentApiKey = "";
          if (this.plugin.settings.cloudApiKeys && currentProvider in this.plugin.settings.cloudApiKeys) {
            currentApiKey = this.plugin.settings.cloudApiKeys[currentProvider] || "";
          }
          if (!currentApiKey && this.plugin.settings.cloudApiKey && this.plugin.settings.cloudProvider === currentProvider) {
            currentApiKey = this.plugin.settings.cloudApiKey;
          }
          new import_obsidian11.Setting(containerEl).setName("API Key").setDesc(`Enter your ${providerNames[this.plugin.settings.cloudProvider] || "provider"} API key`).addText((text) => {
            text.setPlaceholder("sk-...").setValue(currentApiKey);
            text.inputEl.setAttribute("type", "password");
            text.onChange(async (value) => {
              if (!this.plugin.settings.cloudApiKeys) {
                this.plugin.settings.cloudApiKeys = {
                  anthropic: "",
                  openai: "",
                  gemini: "",
                  groq: "",
                  openrouter: ""
                };
              }
              if (currentProvider in this.plugin.settings.cloudApiKeys) {
                this.plugin.settings.cloudApiKeys[currentProvider] = value;
              }
              await this.saveSettings();
            });
          });
          const helpText = containerEl.createDiv("setting-item-description");
          helpText.style.marginTop = "5px";
          const providerName = providerNames[this.plugin.settings.cloudProvider] || "provider";
          const apiKeyUrl = apiKeyUrls[this.plugin.settings.cloudProvider] || "#";
          helpText.innerHTML = `<a href="${apiKeyUrl}" target="_blank">Get your ${providerName} API key</a>`;
          const costEstimates = {
            "anthropic": "~$0.002 per idea (Claude 3.5 Haiku)",
            "openai": "~$0.001 per idea (GPT-4o Mini)",
            "gemini": "~$0.0005 per idea (Gemini 1.5 Flash)",
            "groq": "Free (Llama 3.3 70B)",
            "openrouter": "Varies by model (see OpenRouter pricing)"
          };
          const costEstimate = costEstimates[this.plugin.settings.cloudProvider] || "Varies";
          const costText = containerEl.createDiv("setting-item-description");
          costText.style.marginTop = "5px";
          costText.style.color = "var(--text-muted)";
          costText.textContent = `Cost estimate: ${costEstimate}`;
          new import_obsidian11.Setting(containerEl).setName("Test Connection").setDesc("Verify your API key is valid").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
            const currentProvider2 = this.plugin.settings.cloudProvider;
            const apiKey = this.plugin.settings.cloudApiKeys && currentProvider2 in this.plugin.settings.cloudApiKeys ? (this.plugin.settings.cloudApiKeys[currentProvider2] || "").trim() : "";
            if (!apiKey) {
              new import_obsidian11.Notice("Please enter an API key first");
              return;
            }
            button.setButtonText("Testing...");
            button.setDisabled(true);
            try {
              const provider = ProviderFactory.createProvider(
                this.plugin.settings.cloudProvider,
                apiKey,
                {
                  openRouterModel: this.plugin.settings.openRouterModel,
                  customEndpointUrl: this.plugin.settings.customEndpointUrl
                }
              );
              const authResult = await provider.authenticate(apiKey);
              if (!authResult) {
                new import_obsidian11.Notice("Authentication failed: Invalid API key format");
                return;
              }
              const testResult = await provider.classify("Test idea for connection verification");
              if (testResult && (testResult.category || testResult.tags.length > 0)) {
                new import_obsidian11.Notice(`\u2713 Connection successful! Provider: ${provider.name}`);
              } else {
                new import_obsidian11.Notice("Connection test completed, but got unexpected response");
              }
            } catch (error) {
              console.error("Connection test failed:", error);
              const errorMessage = error instanceof Error ? error.message : "Unknown error";
              new import_obsidian11.Notice(`Connection failed: ${errorMessage}`);
            } finally {
              button.setButtonText("Test Connection");
              button.setDisabled(false);
            }
          }));
        }
        if (this.plugin.settings.cloudProvider === "openrouter") {
          new import_obsidian11.Setting(containerEl).setName("Model").setDesc("Select the model to use via OpenRouter").addText((text) => text.setPlaceholder("openai/gpt-4o-mini").setValue(this.plugin.settings.openRouterModel || "openai/gpt-4o-mini").onChange(async (value) => {
            this.plugin.settings.openRouterModel = value;
            await this.saveSettings();
          }));
        }
        if (this.plugin.settings.cloudProvider === "custom") {
          new import_obsidian11.Setting(containerEl).setName("Endpoint URL").setDesc("Enter your custom endpoint URL (e.g., http://localhost:11434/api/chat for Ollama)").addText((text) => text.setPlaceholder("http://localhost:11434/api/chat").setValue(this.plugin.settings.customEndpointUrl || "").onChange(async (value) => {
            this.plugin.settings.customEndpointUrl = value;
            await this.saveSettings();
          }));
          const customCostText = containerEl.createDiv("setting-item-description");
          customCostText.style.marginTop = "5px";
          customCostText.style.color = "var(--text-muted)";
          customCostText.textContent = "Cost estimate: Free (self-hosted)";
          new import_obsidian11.Setting(containerEl).setName("Test Connection").setDesc("Verify your custom endpoint is accessible").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
            const endpointUrl = this.plugin.settings.customEndpointUrl.trim();
            if (!endpointUrl) {
              new import_obsidian11.Notice("Please enter an endpoint URL first");
              return;
            }
            button.setButtonText("Testing...");
            button.setDisabled(true);
            try {
              const provider = ProviderFactory.createProvider(
                "custom",
                "",
                {
                  customEndpointUrl: endpointUrl
                }
              );
              const authResult = await provider.authenticate(endpointUrl);
              if (!authResult) {
                new import_obsidian11.Notice("Authentication failed: Invalid endpoint URL");
                return;
              }
              const testResult = await provider.classify("Test idea for connection verification");
              if (testResult && (testResult.category || testResult.tags.length > 0)) {
                new import_obsidian11.Notice(`\u2713 Connection successful! Provider: ${provider.name}`);
              } else {
                new import_obsidian11.Notice("Connection test completed, but got unexpected response");
              }
            } catch (error) {
              console.error("Connection test failed:", error);
              const errorMessage = error instanceof Error ? error.message : "Unknown error";
              new import_obsidian11.Notice(`Connection failed: ${errorMessage}`);
            } finally {
              button.setButtonText("Test Connection");
              button.setDisabled(false);
            }
          }));
        }
        new import_obsidian11.Setting(containerEl).setName("Prefer Cloud AI").setDesc("Use cloud AI when available, fallback to local AI on failure").addToggle((toggle) => toggle.setValue(this.plugin.settings.preferCloud).onChange(async (value) => {
          this.plugin.settings.preferCloud = value;
          await this.saveSettings();
        }));
      }
    }
  }
  renderModelComparison(containerEl) {
    containerEl.empty();
    containerEl.createEl("h4", { text: "Cloud AI Model Comparison" });
    containerEl.createEl("p", {
      text: "Compare default cloud AI models to find the best fit for your needs. All models are validated for Ideatr's classification and tagging tasks.",
      cls: "cloud-model-comparison-intro"
    });
    containerEl.querySelector(".cloud-model-comparison-intro")?.setAttribute("style", "margin-bottom: 1em; color: var(--text-muted); font-size: 0.9em;");
    const modelsByProvider = {
      "Anthropic": getCloudModelsByProvider("anthropic"),
      "OpenAI": getCloudModelsByProvider("openai"),
      "Google Gemini": getCloudModelsByProvider("gemini"),
      "Groq": getCloudModelsByProvider("groq")
    };
    for (const [providerName, models] of Object.entries(modelsByProvider)) {
      if (models.length === 0)
        continue;
      const displayModels = models.map(cloudModelToDisplayInfo);
      renderModelGroup(containerEl, providerName, displayModels, false);
    }
  }
};

// src/settings/sections/WebSearchSettingsSection.ts
var import_obsidian12 = require("obsidian");
var WebSearchSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    new import_obsidian12.Setting(containerEl).setName("Enable Web Search").setDesc("Search for similar ideas/products/services on the web").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWebSearch).onChange(async (value) => {
      this.plugin.settings.enableWebSearch = value;
      await this.saveSettings();
    }));
    new import_obsidian12.Setting(containerEl).setName("Auto-search existence on capture").setDesc("Automatically search for similar items when capturing ideas").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSearchExistence).onChange(async (value) => {
      this.plugin.settings.autoSearchExistence = value;
      await this.saveSettings();
    }));
    new import_obsidian12.Setting(containerEl).setName("Web Search Provider").setDesc("Select the web search provider to use").addDropdown((dropdown) => dropdown.addOption("google", "Google").addOption("duckduckgo", "DuckDuckGo").addOption("none", "None").setValue(this.plugin.settings.webSearchProvider).onChange(async (value) => {
      this.plugin.settings.webSearchProvider = value;
      await this.saveSettings();
      this.refresh();
    }));
    if (this.plugin.settings.webSearchProvider === "google") {
      new import_obsidian12.Setting(containerEl).setName("Google API Key").setDesc("Google Custom Search API key").addText((text) => text.setPlaceholder("Enter your Google API key").setValue(this.plugin.settings.googleSearchApiKey).onChange(async (value) => {
        this.plugin.settings.googleSearchApiKey = value;
        await this.saveSettings();
      }));
      new import_obsidian12.Setting(containerEl).setName("Google Search Engine ID").setDesc("Google Custom Search Engine ID (CSE ID)").addText((text) => text.setPlaceholder("Enter your Google CSE ID").setValue(this.plugin.settings.googleSearchEngineId).onChange(async (value) => {
        this.plugin.settings.googleSearchEngineId = value;
        await this.saveSettings();
      }));
    }
    new import_obsidian12.Setting(containerEl).setName("Web search timeout (ms)").setDesc("Maximum time to wait for web search response").addText((text) => text.setPlaceholder("15000").setValue(String(this.plugin.settings.webSearchTimeout)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.webSearchTimeout = numValue;
        await this.saveSettings();
      }
    }));
    new import_obsidian12.Setting(containerEl).setName("Max search results (1-10)").setDesc("Maximum number of search results to store in frontmatter").addText((text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.maxSearchResults)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 1 && numValue <= 10) {
        this.plugin.settings.maxSearchResults = numValue;
        await this.saveSettings();
      }
    }));
  }
};

// src/settings/sections/NameVariantSettingsSection.ts
var import_obsidian13 = require("obsidian");
var NameVariantSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    new import_obsidian13.Setting(containerEl).setName("Enable Name Variants").setDesc("Generate name variants for ideas").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableNameVariants).onChange(async (value) => {
      this.plugin.settings.enableNameVariants = value;
      await this.saveSettings();
    }));
    new import_obsidian13.Setting(containerEl).setName("Auto-generate variants on capture").setDesc("Automatically generate name variants when capturing ideas").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoGenerateVariants).onChange(async (value) => {
      this.plugin.settings.autoGenerateVariants = value;
      await this.saveSettings();
    }));
    new import_obsidian13.Setting(containerEl).setName("Max variants (5-10)").setDesc("Maximum number of name variants to generate").addText((text) => text.setPlaceholder("8").setValue(String(this.plugin.settings.maxVariants)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 5 && numValue <= 10) {
        this.plugin.settings.maxVariants = numValue;
        await this.saveSettings();
      }
    }));
    new import_obsidian13.Setting(containerEl).setName("Use LLM for name extraction").setDesc("Use AI to intelligently extract idea names (more accurate but slower)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useLLMForNameExtraction).onChange(async (value) => {
      this.plugin.settings.useLLMForNameExtraction = value;
      await this.saveSettings();
    }));
    new import_obsidian13.Setting(containerEl).setName("Cache max size").setDesc("Maximum number of cached variants (0 = unlimited)").addText((text) => text.setPlaceholder("100").setValue(String(this.plugin.settings.variantCacheMaxSize || 0)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue >= 0) {
        this.plugin.settings.variantCacheMaxSize = numValue;
        await this.saveSettings();
      }
    }));
    new import_obsidian13.Setting(containerEl).setName("Persist cache to disk").setDesc("Save variant cache to disk (survives plugin reloads)").addToggle((toggle) => toggle.setValue(this.plugin.settings.variantCachePersist).onChange(async (value) => {
      this.plugin.settings.variantCachePersist = value;
      await this.saveSettings();
    }));
    new import_obsidian13.Setting(containerEl).setName("Clear variant cache").setDesc("Clear all cached name variants").addButton((button) => button.setButtonText("Clear Cache").setCta().onClick(async () => {
      if (this.plugin.nameVariantService) {
        this.plugin.nameVariantService.clearCache();
        new import_obsidian13.Notice("Variant cache cleared");
      }
    }));
  }
};

// src/settings/sections/ScaffoldSettingsSection.ts
var import_obsidian14 = require("obsidian");
var ScaffoldSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    new import_obsidian14.Setting(containerEl).setName("Enable Scaffolds").setDesc("Generate scaffold templates for ideas").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableScaffolds).onChange(async (value) => {
      this.plugin.settings.enableScaffolds = value;
      await this.saveSettings();
    }));
    new import_obsidian14.Setting(containerEl).setName("Scaffold default action").setDesc("Default action when generating scaffold: append to current note or create new note").addDropdown((dropdown) => dropdown.addOption("append", "Append to current note").addOption("new-note", "Create new note").setValue(this.plugin.settings.scaffoldDefaultAction).onChange(async (value) => {
      this.plugin.settings.scaffoldDefaultAction = value;
      await this.saveSettings();
    }));
  }
};

// src/settings/sections/ProjectElevationSettingsSection.ts
var import_obsidian15 = require("obsidian");
var ProjectElevationSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    new import_obsidian15.Setting(containerEl).setName("Enable Project Elevation").setDesc("Allow elevating ideas to full projects").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableElevation).onChange(async (value) => {
      this.plugin.settings.enableElevation = value;
      await this.saveSettings();
    }));
    new import_obsidian15.Setting(containerEl).setName("Projects Directory").setDesc("Directory where elevated projects will be created (relative to vault root)").addText((text) => text.setPlaceholder("Projects").setValue(this.plugin.settings.elevationProjectsDirectory).onChange(async (value) => {
      const sanitized = value.trim().replace(/^\/+|\/+$/g, "").replace(/\s+/g, "-");
      this.plugin.settings.elevationProjectsDirectory = sanitized || "Projects";
      await this.saveSettings();
    }));
    new import_obsidian15.Setting(containerEl).setName("Default Folders").setDesc("Comma-separated list of folders to create in each elevated project (e.g., docs,notes,assets)").addText((text) => text.setPlaceholder("docs,notes,assets").setValue(this.plugin.settings.elevationDefaultFolders).onChange(async (value) => {
      const sanitized = value.split(",").map((f) => f.trim().replace(/[^a-zA-Z0-9_-]/g, "")).filter((f) => f.length > 0).join(",");
      this.plugin.settings.elevationDefaultFolders = sanitized || "docs,notes,assets";
      await this.saveSettings();
    }));
    new import_obsidian15.Setting(containerEl).setName("Create Project Metadata").setDesc("Create project metadata file for future project management integrations (planned expansion)").addToggle((toggle) => toggle.setValue(this.plugin.settings.elevationCreateDevraMetadata).onChange(async (value) => {
      this.plugin.settings.elevationCreateDevraMetadata = value;
      await this.saveSettings();
    }));
    const elevationHelp = containerEl.createDiv("setting-item-description");
    elevationHelp.style.marginTop = "10px";
    elevationHelp.style.padding = "10px";
    elevationHelp.style.backgroundColor = "var(--background-secondary)";
    elevationHelp.style.borderRadius = "4px";
    elevationHelp.innerHTML = `
            <strong>About Project Elevation:</strong><br>
            Elevating an idea moves it from the Ideas/ directory to a project folder structure in ${this.plugin.settings.elevationProjectsDirectory || "Projects"}/.
            The original idea file becomes the project's README.md, and default folders are created automatically.
            <br><br>
            <strong>Note:</strong> Folder structure customization is planned for v2. Currently, the default structure is used for all projects.
        `;
  }
};

// src/settings/sections/ErrorLoggingSettingsSection.ts
var import_obsidian16 = require("obsidian");
var ErrorLoggingSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    new import_obsidian16.Setting(containerEl).setName("Enable error logging").setDesc("Collect error logs for bug reports. Logs are stored locally and only sent if you choose to include them.").addToggle((toggle) => toggle.setValue(this.plugin.settings.errorLoggingEnabled).onChange(async (value) => {
      this.plugin.settings.errorLoggingEnabled = value;
      await this.saveSettings();
      if (this.plugin.errorLogService) {
        this.plugin.errorLogService.updateSettings({
          enabled: value,
          maxEntries: this.plugin.settings.errorLogMaxEntries,
          retentionDays: this.plugin.settings.errorLogRetentionDays
        });
      }
    }));
    new import_obsidian16.Setting(containerEl).setName("Maximum log entries").setDesc("Maximum number of error log entries to keep in memory (default: 50)").addText((text) => text.setPlaceholder("50").setValue(String(this.plugin.settings.errorLogMaxEntries)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0 && numValue <= 500) {
        this.plugin.settings.errorLogMaxEntries = numValue;
        await this.saveSettings();
        if (this.plugin.errorLogService) {
          this.plugin.errorLogService.updateSettings({
            enabled: this.plugin.settings.errorLoggingEnabled,
            maxEntries: numValue,
            retentionDays: this.plugin.settings.errorLogRetentionDays
          });
        }
      }
    }));
    new import_obsidian16.Setting(containerEl).setName("Log retention (days)").setDesc("Number of days to retain error logs (default: 7)").addText((text) => text.setPlaceholder("7").setValue(String(this.plugin.settings.errorLogRetentionDays)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0 && numValue <= 30) {
        this.plugin.settings.errorLogRetentionDays = numValue;
        await this.saveSettings();
        if (this.plugin.errorLogService) {
          this.plugin.errorLogService.updateSettings({
            enabled: this.plugin.settings.errorLoggingEnabled,
            maxEntries: this.plugin.settings.errorLogMaxEntries,
            retentionDays: numValue
          });
        }
      }
    }));
    new import_obsidian16.Setting(containerEl).setName("Clear error logs").setDesc("Clear all stored error logs").addButton((button) => button.setButtonText("Clear Logs").onClick(() => {
      if (this.plugin.errorLogService) {
        this.plugin.errorLogService.clearLogs();
        new import_obsidian16.Notice("Error logs cleared");
      }
    }));
  }
};

// src/settings/sections/FeedbackSettingsSection.ts
var import_obsidian18 = require("obsidian");

// src/views/FeatureRequestModal.ts
var import_obsidian17 = require("obsidian");
var FeatureRequestModal = class extends import_obsidian17.Modal {
  errorLogService;
  systemInfo;
  requestType = "feature";
  description = "";
  includeErrorLogs = false;
  includeSystemInfo = true;
  constructor(app, systemInfo, errorLogService) {
    super(app);
    this.systemInfo = systemInfo;
    this.errorLogService = errorLogService;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-feedback-modal");
    contentEl.createEl("h2", { text: "Submit Feedback" });
    contentEl.createEl("p", {
      text: "Help improve Ideatr by submitting a feature request or bug report.",
      cls: "ideatr-feedback-description"
    });
    const typeContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
    typeContainer.createEl("label", {
      text: "Type:",
      attr: { for: "ideatr-request-type" },
      cls: "ideatr-label"
    });
    const typeSelect = typeContainer.createEl("select", {
      attr: { id: "ideatr-request-type" },
      cls: "ideatr-select"
    });
    typeSelect.createEl("option", { text: "Feature Request", attr: { value: "feature" } });
    typeSelect.createEl("option", { text: "Bug Report", attr: { value: "bug" } });
    typeSelect.createEl("option", { text: "Performance Issue", attr: { value: "performance" } });
    typeSelect.value = this.requestType;
    typeSelect.addEventListener("change", (e) => {
      this.requestType = e.target.value;
      this.updateDescriptionPlaceholder();
    });
    const descContainer = contentEl.createEl("div", { cls: "ideatr-setting-item" });
    descContainer.createEl("label", {
      text: "Description:",
      attr: { for: "ideatr-description" },
      cls: "ideatr-label"
    });
    const descriptionTextarea = descContainer.createEl("textarea", {
      attr: {
        id: "ideatr-description",
        rows: "8",
        placeholder: this.getDescriptionPlaceholder()
      },
      cls: "ideatr-textarea"
    });
    descriptionTextarea.value = this.description;
    descriptionTextarea.addEventListener("input", (e) => {
      this.description = e.target.value;
    });
    const optionsContainer = contentEl.createEl("div", { cls: "ideatr-feedback-options" });
    optionsContainer.createEl("h3", { text: "Additional Information (Optional)" });
    const systemInfoContainer = optionsContainer.createEl("div", { cls: "ideatr-checkbox-item" });
    const systemInfoCheckbox = systemInfoContainer.createEl("input", {
      attr: {
        type: "checkbox",
        id: "ideatr-include-system-info",
        checked: this.includeSystemInfo
      }
    });
    systemInfoContainer.createEl("label", {
      text: "Include system information (Obsidian version, plugin version, OS)",
      attr: { for: "ideatr-include-system-info" }
    });
    systemInfoCheckbox.addEventListener("change", (e) => {
      this.includeSystemInfo = e.target.checked;
    });
    if (this.errorLogService) {
      const errorLogsContainer = optionsContainer.createEl("div", { cls: "ideatr-checkbox-item" });
      const errorLogsCheckbox = errorLogsContainer.createEl("input", {
        attr: {
          type: "checkbox",
          id: "ideatr-include-error-logs",
          checked: this.includeErrorLogs
        }
      });
      errorLogsContainer.createEl("label", {
        text: "Include recent error logs (last 7 days, sanitized)",
        attr: { for: "ideatr-include-error-logs" }
      });
      errorLogsCheckbox.addEventListener("change", (e) => {
        this.includeErrorLogs = e.target.checked;
      });
      const recentLogs = this.errorLogService.getRecentLogs();
      if (recentLogs.length > 0) {
        const logCount = optionsContainer.createEl("p", {
          text: `${recentLogs.length} error log${recentLogs.length > 1 ? "s" : ""} available`,
          cls: "ideatr-help-text"
        });
        logCount.style.marginTop = "5px";
        logCount.style.fontSize = "0.9em";
        logCount.style.color = "var(--text-muted)";
      }
    }
    const previewContainer = contentEl.createEl("div", { cls: "ideatr-feedback-preview" });
    previewContainer.createEl("h3", { text: "Preview" });
    const previewTextarea = previewContainer.createEl("textarea", {
      attr: {
        id: "ideatr-preview",
        rows: "12",
        readonly: "true"
      },
      cls: "ideatr-textarea"
    });
    previewTextarea.style.fontFamily = "var(--font-monospace)";
    previewTextarea.style.fontSize = "0.9em";
    const updatePreview = () => {
      previewTextarea.value = this.generateIssueContent();
    };
    typeSelect.addEventListener("change", updatePreview);
    descriptionTextarea.addEventListener("input", updatePreview);
    systemInfoCheckbox.addEventListener("change", updatePreview);
    if (this.errorLogService) {
      const errorLogsCheckbox = contentEl.querySelector("#ideatr-include-error-logs");
      if (errorLogsCheckbox) {
        errorLogsCheckbox.addEventListener("change", updatePreview);
      }
    }
    updatePreview();
    const buttonContainer = contentEl.createEl("div", { cls: "ideatr-button-container" });
    const copyButton = buttonContainer.createEl("button", {
      text: "Copy to Clipboard",
      cls: "mod-cta"
    });
    copyButton.addEventListener("click", () => this.handleCopyToClipboard());
    const emailButton = buttonContainer.createEl("button", {
      text: "Open Email",
      cls: "mod-cta"
    });
    emailButton.addEventListener("click", () => this.handleOpenEmail());
    const githubButton = buttonContainer.createEl("button", {
      text: "Open GitHub Issue",
      cls: "mod-cta"
    });
    githubButton.addEventListener("click", () => this.handleOpenGitHub());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  getDescriptionPlaceholder() {
    if (this.requestType === "bug") {
      return "Describe the bug:\n\n1. What happened?\n2. What did you expect to happen?\n3. Steps to reproduce:\n   - Step 1\n   - Step 2\n   - Step 3";
    } else if (this.requestType === "performance") {
      return "Describe the performance issue:\n\n- What operation is slow?\n- How long does it take?\n- When did you first notice this?\n- Any patterns (specific features, large vaults, etc.)?";
    } else {
      return "Describe your feature request:\n\n- What problem does this solve?\n- How would you like it to work?\n- Any additional context or examples?";
    }
  }
  updateDescriptionPlaceholder() {
    const textarea = this.contentEl.querySelector("#ideatr-description");
    if (textarea) {
      textarea.placeholder = this.getDescriptionPlaceholder();
    }
  }
  generateIssueContent() {
    const typeLabel = this.requestType === "bug" ? "Bug Report" : this.requestType === "performance" ? "Performance Issue" : "Feature Request";
    let content = `## ${typeLabel}

`;
    if (this.description.trim()) {
      content += `${this.description}

`;
    } else {
      content += `[Please describe your ${this.requestType === "bug" ? "bug" : "feature request"} here]

`;
    }
    if (this.includeSystemInfo) {
      content += `## System Information

`;
      content += `- **Obsidian Version:** ${this.systemInfo.obsidianVersion}
`;
      content += `- **Ideatr Version:** ${this.systemInfo.pluginVersion}
`;
      content += `- **Platform:** ${this.systemInfo.platform}
`;
      content += `- **OS:** ${this.systemInfo.os}

`;
    }
    if (this.includeErrorLogs && this.errorLogService) {
      const recentLogs = this.errorLogService.getRecentLogs();
      if (recentLogs.length > 0) {
        content += this.errorLogService.formatLogsForIssue(recentLogs);
        content += "\n\n";
      }
    }
    return content.trim();
  }
  generateIssueTitle() {
    const typePrefix = this.requestType === "bug" ? "[Bug]" : this.requestType === "performance" ? "[Performance]" : "[Feature]";
    const description = this.description.trim();
    if (description) {
      const firstLine = description.split("\n")[0].trim();
      const title = firstLine.length > 50 ? firstLine.substring(0, 47) + "..." : firstLine;
      return `${typePrefix} ${title}`;
    }
    const defaultTitle = this.requestType === "bug" ? "Bug report" : this.requestType === "performance" ? "Performance issue" : "Feature request";
    return `${typePrefix} ${defaultTitle}`;
  }
  async handleCopyToClipboard() {
    if (!this.description.trim()) {
      new import_obsidian17.Notice("Please enter a description first");
      return;
    }
    const content = this.generateIssueContent();
    try {
      await navigator.clipboard.writeText(content);
      new import_obsidian17.Notice("Content copied to clipboard! Paste it into a GitHub issue.");
    } catch (error) {
      console.error("Failed to copy to clipboard:", error);
      new import_obsidian17.Notice("Failed to copy to clipboard. Please copy manually from the preview.");
    }
  }
  handleOpenEmail() {
    if (!this.description.trim()) {
      new import_obsidian17.Notice("Please enter a description first");
      return;
    }
    const subject = this.generateEmailSubject();
    const body = this.generateIssueContent();
    const encodedSubject = encodeURIComponent(subject);
    const encodedBody = encodeURIComponent(body);
    const mailtoUrl = `mailto:ideatr@paraphlabs.com?subject=${encodedSubject}&body=${encodedBody}`;
    window.location.href = mailtoUrl;
    new import_obsidian17.Notice("Opening email client...");
  }
  generateEmailSubject() {
    const typePrefix = this.requestType === "bug" ? "[Bug]" : this.requestType === "performance" ? "[Performance]" : "[Feature]";
    const description = this.description.trim();
    if (description) {
      const firstLine = description.split("\n")[0].trim();
      const summary = firstLine.length > 60 ? firstLine.substring(0, 57) + "..." : firstLine;
      return `${typePrefix} ${summary}`;
    }
    const defaultTitle = this.requestType === "bug" ? "Bug report" : this.requestType === "performance" ? "Performance issue" : "Feature request";
    return `${typePrefix} ${defaultTitle}`;
  }
  handleOpenGitHub() {
    if (!this.description.trim()) {
      new import_obsidian17.Notice("Please enter a description first");
      return;
    }
    const title = encodeURIComponent(this.generateIssueTitle());
    const body = encodeURIComponent(this.generateIssueContent());
    const labels = this.requestType === "bug" ? "bug" : this.requestType === "performance" ? "performance" : "enhancement";
    const url = `https://github.com/FallingWithStyle/obsidian-ideatr/issues/new?title=${title}&body=${body}&labels=${labels}`;
    window.open(url, "_blank");
    new import_obsidian17.Notice("Opening GitHub issue page...");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings/sections/FeedbackSettingsSection.ts
var FeedbackSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    new import_obsidian18.Setting(containerEl).setName("View existing issues").setDesc("Browse and search existing bug reports and feature requests on GitHub").addButton((button) => button.setButtonText("View Issues").onClick(() => {
      window.open("https://github.com/FallingWithStyle/obsidian-ideatr/issues", "_blank");
    }));
    new import_obsidian18.Setting(containerEl).setName("Submit Feedback").setDesc("Report bugs, suggest features, or report performance issues. Error logs can be included to help diagnose issues.").addButton((button) => button.setButtonText("Submit Feedback").setCta().onClick(() => {
      let obsidianVersion = "Unknown";
      try {
        obsidianVersion = this.app.appVersion || this.app.version || "Unknown";
      } catch {
        obsidianVersion = "Unknown";
      }
      const systemInfo = {
        obsidianVersion,
        pluginVersion: this.plugin.manifest.version,
        platform: this.app.isMobile ? "mobile" : "desktop",
        os: navigator.platform || "Unknown"
      };
      const modal = new FeatureRequestModal(
        this.app,
        systemInfo,
        this.plugin.errorLogService
      );
      modal.open();
    }));
  }
};

// src/settings/sections/CaptureModalSettingsSection.ts
var import_obsidian19 = require("obsidian");

// src/utils/hotkeyPicker.ts
function eventToShortcut(e) {
  const parts = [];
  if (e.metaKey)
    parts.push("cmd");
  if (e.ctrlKey)
    parts.push("ctrl");
  if (e.altKey)
    parts.push("alt");
  if (e.shiftKey)
    parts.push("shift");
  const key = e.key.toLowerCase();
  if (key === " ") {
    parts.push("space");
  } else if (key === "enter") {
    parts.push("enter");
  } else if (key === "escape") {
    parts.push("escape");
  } else if (key === "tab") {
    parts.push("tab");
  } else if (key === "backspace") {
    parts.push("backspace");
  } else if (key === "delete") {
    parts.push("delete");
  } else if (key === "arrowup") {
    parts.push("arrowup");
  } else if (key === "arrowdown") {
    parts.push("arrowdown");
  } else if (key === "arrowleft") {
    parts.push("arrowleft");
  } else if (key === "arrowright") {
    parts.push("arrowright");
  } else if (key.length === 1) {
    parts.push(key);
  } else {
    parts.push(key);
  }
  return parts.join("+");
}
function formatShortcut2(shortcut) {
  if (!shortcut)
    return "";
  return shortcut.split("+").map((part) => {
    const trimmed = part.trim().toLowerCase();
    if (trimmed === "cmd" || trimmed === "meta")
      return "\u2318";
    if (trimmed === "ctrl")
      return "\u2303";
    if (trimmed === "alt")
      return "\u2325";
    if (trimmed === "shift")
      return "\u21E7";
    if (trimmed === "space")
      return "Space";
    if (trimmed === "enter")
      return "Enter";
    if (trimmed === "escape")
      return "Esc";
    if (trimmed === "tab")
      return "Tab";
    if (trimmed === "backspace")
      return "Backspace";
    if (trimmed === "delete")
      return "Delete";
    if (trimmed === "arrowup")
      return "\u2191";
    if (trimmed === "arrowdown")
      return "\u2193";
    if (trimmed === "arrowleft")
      return "\u2190";
    if (trimmed === "arrowright")
      return "\u2192";
    return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
  }).join(" ");
}
function createHotkeyPicker(inputEl, currentValue, onCapture) {
  let isCapturing = false;
  let capturedShortcut = currentValue || "";
  if (currentValue) {
    inputEl.value = formatShortcut2(currentValue);
    capturedShortcut = currentValue;
  } else {
    inputEl.value = "";
  }
  inputEl.placeholder = "Click and press keys...";
  inputEl.style.cursor = "text";
  inputEl.style.fontFamily = "monospace";
  inputEl.addEventListener("focus", () => {
    isCapturing = true;
    inputEl.value = "";
    inputEl.placeholder = "Press keys...";
    inputEl.style.backgroundColor = "var(--background-modifier-active-hover)";
  });
  inputEl.addEventListener("blur", () => {
    isCapturing = false;
    inputEl.style.backgroundColor = "";
    if (capturedShortcut) {
      inputEl.value = formatShortcut2(capturedShortcut);
    } else {
      inputEl.value = currentValue ? formatShortcut2(currentValue) : "";
      inputEl.placeholder = "Click and press keys...";
    }
  });
  inputEl.addEventListener("keydown", (e) => {
    if (!isCapturing)
      return;
    e.preventDefault();
    e.stopPropagation();
    if (["Meta", "Control", "Alt", "Shift"].includes(e.key)) {
      return;
    }
    const shortcut = eventToShortcut(e);
    capturedShortcut = shortcut;
    inputEl.value = formatShortcut2(shortcut);
    onCapture(shortcut);
  });
  inputEl.addEventListener("keyup", (e) => {
    if (!isCapturing)
      return;
    if (!e.metaKey && !e.ctrlKey && !e.altKey && !e.shiftKey && capturedShortcut) {
      inputEl.value = formatShortcut2(capturedShortcut);
    }
  });
}

// src/settings/sections/CaptureModalSettingsSection.ts
var CaptureModalSettingsSection = class extends BaseSettingsSection {
  display(containerEl) {
    containerEl.createEl("h3", { text: "Capture Modal Shortcuts" });
    new import_obsidian19.Setting(containerEl).setName("Capture Idea Hotkey").setDesc(`Keyboard shortcut for opening the Capture Idea modal. Click the field and press your desired key combination. Note: This setting stores your preference. To actually bind the hotkey, you must also set it in Obsidian's Hotkeys settings (Settings \u2192 Hotkeys \u2192 search for "Capture Idea").`).addText((text) => {
      createHotkeyPicker(
        text.inputEl,
        this.plugin.settings.captureIdeaHotkey,
        async (shortcut) => {
          this.plugin.settings.captureIdeaHotkey = shortcut;
          await this.saveSettings();
        }
      );
    });
    new import_obsidian19.Setting(containerEl).setName("Save Shortcut").setDesc("Keyboard shortcut for the Save button in the Capture Idea modal. Click the field and press your desired key combination.").addText((text) => {
      createHotkeyPicker(
        text.inputEl,
        this.plugin.settings.captureSaveShortcut,
        async (shortcut) => {
          this.plugin.settings.captureSaveShortcut = shortcut;
          await this.saveSettings();
        }
      );
    });
    new import_obsidian19.Setting(containerEl).setName("Ideate Shortcut").setDesc("Keyboard shortcut for the Ideate button in the Capture Idea modal. Click the field and press your desired key combination.").addText((text) => {
      createHotkeyPicker(
        text.inputEl,
        this.plugin.settings.captureIdeateShortcut,
        async (shortcut) => {
          this.plugin.settings.captureIdeateShortcut = shortcut;
          await this.saveSettings();
        }
      );
    });
  }
};

// src/settings/sections/TutorialSettingsSection.ts
var import_obsidian22 = require("obsidian");

// src/services/TutorialManager.ts
var import_obsidian20 = require("obsidian");
var fs3 = __toESM(require("fs"));
var path5 = __toESM(require("path"));
var TutorialManager = class {
  constructor(app, pluginDir) {
    this.app = app;
    this.pluginDir = pluginDir;
  }
  /**
   * Get the tutorial directory path in the vault
   */
  getTutorialVaultPath() {
    return "Tutorials";
  }
  /**
   * Check if tutorials exist in either case (for backward compatibility)
   */
  async findTutorialFolder() {
    const capitalizedPath = "Tutorials";
    const lowercasePath = "tutorials";
    const capitalizedDir = this.app.vault.getAbstractFileByPath(capitalizedPath);
    if (capitalizedDir instanceof import_obsidian20.TFolder) {
      return capitalizedDir;
    }
    const lowercaseDir = this.app.vault.getAbstractFileByPath(lowercasePath);
    if (lowercaseDir instanceof import_obsidian20.TFolder) {
      return lowercaseDir;
    }
    return null;
  }
  /**
   * Get tutorial file paths from plugin directory or vault
   * Tries multiple locations where tutorials might be stored
   */
  async getBundledTutorialFiles() {
    const tutorials = /* @__PURE__ */ new Map();
    if (this.pluginDir) {
      const tutorialDir = path5.join(this.pluginDir, "tutorials");
      try {
        if (fs3.existsSync(tutorialDir) && fs3.statSync(tutorialDir).isDirectory()) {
          const files = fs3.readdirSync(tutorialDir);
          for (const file of files) {
            if (file.endsWith(".md")) {
              const filePath = path5.join(tutorialDir, file);
              try {
                const content = fs3.readFileSync(filePath, "utf-8");
                tutorials.set(file, content);
              } catch (fileError) {
                console.warn(`Error reading tutorial file ${file}:`, fileError);
              }
            }
          }
        }
      } catch (error) {
        console.warn("Error reading tutorial directory from plugin:", error);
      }
    }
    if (tutorials.size === 0) {
      try {
        const tutorialDir = await this.findTutorialFolder();
        if (tutorialDir instanceof import_obsidian20.TFolder && tutorialDir.children) {
          for (const child of tutorialDir.children) {
            if (child instanceof import_obsidian20.TFile && child.name.endsWith(".md")) {
              try {
                const content = await this.app.vault.read(child);
                tutorials.set(child.name, content);
              } catch (fileError) {
                console.warn(`Error reading tutorial file ${child.name}:`, fileError);
              }
            }
          }
        }
      } catch (error) {
        console.warn("Error reading tutorial directory from vault:", error);
      }
    }
    return tutorials;
  }
  /**
   * Reset tutorials - copy from plugin directory to vault
   * @param overwrite - If true, overwrite existing files. If false, skip existing files silently.
   */
  async resetTutorials(overwrite = false) {
    try {
      const tutorialFiles = await this.getBundledTutorialFiles();
      if (tutorialFiles.size === 0) {
        new import_obsidian20.Notice("Tutorial files not found in plugin directory. They may need to be manually restored.");
        return false;
      }
      const vaultPath = this.getTutorialVaultPath();
      const tutorialDir = this.app.vault.getAbstractFileByPath(vaultPath);
      if (!tutorialDir) {
        try {
          await this.app.vault.createFolder(vaultPath);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage.includes("already exists") || errorMessage.includes("Folder already exists")) {
            const checkDir = this.app.vault.getAbstractFileByPath(vaultPath);
            if (!checkDir) {
            }
          } else {
            const checkDir = this.app.vault.getAbstractFileByPath(vaultPath);
            if (!checkDir) {
              throw error;
            }
          }
        }
      }
      let copiedCount = 0;
      for (const [filename, content] of tutorialFiles.entries()) {
        const filePath = `${vaultPath}/${filename}`;
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile && existingFile instanceof import_obsidian20.TFile) {
          if (overwrite) {
            await this.app.vault.modify(existingFile, content);
            copiedCount++;
          }
        } else {
          try {
            await this.app.vault.create(filePath, content);
            copiedCount++;
          } catch (createError) {
            const errorMessage = createError instanceof Error ? createError.message : String(createError);
            if (errorMessage.includes("already exists") || errorMessage.includes("File already exists")) {
              if (overwrite) {
                const foundFile = this.app.vault.getAbstractFileByPath(filePath);
                if (foundFile && foundFile instanceof import_obsidian20.TFile) {
                  await this.app.vault.modify(foundFile, content);
                  copiedCount++;
                }
              }
            } else {
              throw createError;
            }
          }
        }
      }
      if (copiedCount > 0) {
        new import_obsidian20.Notice(`Tutorials reset successfully! ${copiedCount} files restored.`);
      } else if (overwrite) {
        new import_obsidian20.Notice("All tutorial files already exist. No changes made.");
      }
      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (!errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
        console.error("Error resetting tutorials:", error);
        if (overwrite) {
          new import_obsidian20.Notice(`Failed to reset tutorials: ${errorMessage}`);
        }
      }
      return false;
    }
  }
  /**
   * Delete all tutorial files from vault
   */
  async deleteTutorials() {
    try {
      const tutorialDir = await this.findTutorialFolder();
      if (!tutorialDir) {
        new import_obsidian20.Notice("No tutorial files found to delete.");
        return false;
      }
      const vaultPath = tutorialDir.path;
      const files = [];
      const processFile = (file) => {
        if (file instanceof import_obsidian20.TFile && file.path.startsWith(vaultPath)) {
          files.push(file);
        }
        if (file.children) {
          file.children.forEach(processFile);
        }
      };
      processFile(tutorialDir);
      if (files.length === 0) {
        new import_obsidian20.Notice("No tutorial files found to delete.");
        return false;
      }
      for (const file of files) {
        await this.app.vault.delete(file);
      }
      try {
        if (tutorialDir instanceof import_obsidian20.TFolder && (!tutorialDir.children || tutorialDir.children.length === 0)) {
          await this.app.vault.delete(tutorialDir, true);
        }
      } catch {
      }
      new import_obsidian20.Notice(`Tutorials deleted successfully! ${files.length} files removed.`);
      return true;
    } catch (error) {
      console.error("Error deleting tutorials:", error);
      new import_obsidian20.Notice(`Failed to delete tutorials: ${error instanceof Error ? error.message : "Unknown error"}`);
      return false;
    }
  }
  /**
   * Check if tutorials exist in vault (checks both capitalized and lowercase for backward compatibility)
   */
  async tutorialsExistInVault() {
    const capitalizedPath = "Tutorials/00-Index.md";
    const lowercasePath = "tutorials/00-Index.md";
    const capitalizedIndex = this.app.vault.getAbstractFileByPath(capitalizedPath);
    if (capitalizedIndex instanceof import_obsidian20.TFile) {
      return true;
    }
    const lowercaseIndex = this.app.vault.getAbstractFileByPath(lowercasePath);
    return lowercaseIndex instanceof import_obsidian20.TFile;
  }
  /**
   * Check if bundled tutorials are available
   */
  async bundledTutorialsAvailable() {
    const tutorialFiles = await this.getBundledTutorialFiles();
    return tutorialFiles.size > 0;
  }
};

// src/settings/sections/TutorialSettingsSection.ts
var path6 = __toESM(require("path"));
var TutorialSettingsSection = class extends BaseSettingsSection {
  tutorialManager;
  constructor(app, plugin, settingsTab) {
    super(app, plugin, settingsTab);
    const vaultBasePath = app.vault.adapter.basePath || app.vault.configDir;
    const configDir = path6.isAbsolute(app.vault.configDir) ? app.vault.configDir : path6.join(vaultBasePath, app.vault.configDir);
    const pluginDir = path6.resolve(path6.join(configDir, "plugins", plugin.manifest.id));
    this.tutorialManager = new TutorialManager(app, pluginDir);
  }
  display(containerEl) {
    containerEl.createEl("h2", { text: "Tutorials" });
    new import_obsidian22.Setting(containerEl).setName("Open Tutorials").setDesc("Open the tutorial index to browse all available guides").addButton((button) => button.setButtonText("Open Tutorials").setCta().onClick(async () => {
      const { TutorialService: TutorialService2 } = await Promise.resolve().then(() => (init_TutorialService(), TutorialService_exports));
      const tutorialService = new TutorialService2(this.app);
      await tutorialService.openIndex();
    }));
    new import_obsidian22.Setting(containerEl).setName("Reset Tutorials").setDesc("Restore tutorial files from the plugin. Use this if tutorials were deleted, modified, or corrupted.").addButton((button) => button.setButtonText("Reset Tutorials").setWarning().onClick(async () => {
      button.setDisabled(true);
      button.setButtonText("Resetting...");
      try {
        const success = await this.tutorialManager.resetTutorials(true);
        if (success) {
          setTimeout(() => this.refresh(), 1e3);
        }
      } finally {
        button.setDisabled(false);
        button.setButtonText("Reset Tutorials");
      }
    }));
    new import_obsidian22.Setting(containerEl).setName("Delete Tutorials").setDesc('Remove all tutorial files from your vault. You can restore them later using "Reset Tutorials".').addButton((button) => button.setButtonText("Delete Tutorials").setWarning().onClick(async () => {
      const confirmed = confirm(
        'Are you sure you want to delete all tutorial files? You can restore them later using "Reset Tutorials".'
      );
      if (!confirmed) {
        return;
      }
      button.setDisabled(true);
      button.setButtonText("Deleting...");
      try {
        const success = await this.tutorialManager.deleteTutorials();
        if (success) {
          setTimeout(() => this.refresh(), 1e3);
        }
      } finally {
        button.setDisabled(false);
        button.setButtonText("Delete Tutorials");
      }
    }));
    this.displayStatus(containerEl);
  }
  async displayStatus(containerEl) {
    const statusContainer = containerEl.createDiv("tutorial-status");
    const tutorialsExist = await this.tutorialManager.tutorialsExistInVault();
    const bundledAvailable = await this.tutorialManager.bundledTutorialsAvailable();
    let statusText = "";
    let statusDesc = "";
    if (tutorialsExist) {
      statusText = "Tutorials: Installed";
      statusDesc = "Tutorial files are available in your vault.";
    } else if (bundledAvailable) {
      statusText = "Tutorials: Not Installed";
      statusDesc = "Tutorial files are not in your vault, but can be restored from the plugin.";
    } else {
      statusText = "Tutorials: Unavailable";
      statusDesc = "Tutorial files are not available. They may need to be manually added.";
    }
    new import_obsidian22.Setting(statusContainer).setName("Status").setDesc(statusDesc).setDisabled(true).addText((text) => text.setValue(statusText));
  }
};

// src/settings.ts
init_HelpIcon();
var DEFAULT_SETTINGS = {
  llmProvider: "llama",
  llamaServerUrl: "http://127.0.0.1:8080",
  llamaBinaryPath: "",
  modelPath: "",
  llamaServerPort: 8080,
  concurrency: 1,
  llmTimeout: 1e4,
  // Increased default for local inference
  autoClassify: true,
  // Domain checking
  enableDomainCheck: true,
  autoCheckDomains: false,
  // Manual by default (user can enable auto)
  enableProspectr: false,
  // Hidden by default until domain checking service is available
  prospectrUrl: "http://localhost:3000",
  domainCheckTimeout: 1e4,
  // 10 seconds
  // Web search
  enableWebSearch: true,
  autoSearchExistence: false,
  // Manual by default
  webSearchProvider: "google",
  googleSearchApiKey: "",
  googleSearchEngineId: "",
  webSearchTimeout: 15e3,
  // 15 seconds
  maxSearchResults: 5,
  // Name variant generation
  enableNameVariants: true,
  autoGenerateVariants: false,
  // Manual by default (user can enable auto)
  maxVariants: 8,
  useLLMForNameExtraction: false,
  // Rule-based by default (user can enable LLM)
  variantCacheMaxSize: 100,
  // Default: 100 entries
  variantCachePersist: true,
  // Persist cache by default
  // Scaffold generation
  enableScaffolds: true,
  scaffoldDefaultAction: "append",
  // Append to current note by default
  // Dashboard
  dashboardDefaultView: "table",
  dashboardItemsPerPage: 50,
  dashboardAutoRefresh: true,
  dashboardPersistFilters: true,
  // Clustering
  enableClustering: true,
  clusteringAlgorithm: "hierarchical",
  maxClusters: 0,
  // Auto
  clusterColorScheme: "category",
  clusteringSimilarityThreshold: 0.3,
  // Resurfacing
  enableResurfacing: true,
  resurfacingThresholdDays: 7,
  resurfacingFrequency: "manual",
  // Manual for v1
  resurfacingTime: "09:00",
  autoGenerateDigest: false,
  // Manual for v1
  digestIncludeSummary: true,
  digestMaxIdeas: 0,
  // Unlimited
  // Project elevation
  enableElevation: true,
  elevationProjectsDirectory: "Projects",
  elevationCreateDevraMetadata: true,
  // Create .devra.json metadata file (for future project management integration)
  elevationDefaultFolders: "docs,notes,assets",
  // Default folders to create
  // AI Model Management
  setupCompleted: false,
  modelDownloaded: false,
  keepModelLoaded: false,
  preloadOnStartup: false,
  localModel: "phi-3.5-mini",
  // Cloud AI
  preferCloud: false,
  cloudProvider: "none",
  cloudApiKeys: {
    anthropic: "",
    openai: "",
    gemini: "",
    groq: "",
    openrouter: ""
  },
  customEndpointUrl: "",
  openRouterModel: "",
  customModelProvider: void 0,
  customModel: void 0,
  // File Organization
  moveArchivedToFolder: false,
  // Default: don't move files, just update status
  // Error Logging
  errorLoggingEnabled: true,
  // Default: enabled
  errorLogMaxEntries: 50,
  // Default: 50 entries
  errorLogRetentionDays: 7,
  // Default: 7 days
  // Debug Mode (for developers)
  debugMode: false,
  // Default: false (only enabled for developer vaults)
  // Capture Modal Keyboard Shortcuts
  captureIdeaHotkey: "cmd+i",
  // Default: Cmd+I (Mac) or Ctrl+I (Windows/Linux) - users can customize
  captureSaveShortcut: "alt+enter",
  // Default: Alt+Enter (Mac) or Alt+Enter (Windows/Linux) - users can customize
  captureIdeateShortcut: "cmd+enter"
  // Default: Cmd+Enter (Mac) or Ctrl+Enter (Windows/Linux)
};
var IdeatrSettingTab = class extends import_obsidian23.PluginSettingTab {
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Ideatr Settings" });
    const betaNotice = containerEl.createDiv({ cls: "ideatr-beta-notice" });
    betaNotice.style.cssText = "background: var(--background-modifier-border); padding: 1em; border-radius: 4px; margin-bottom: 1.5em; border-left: 3px solid var(--text-accent);";
    const betaTitle = betaNotice.createEl("strong", { text: "\u26A0\uFE0F Ideatr is in Beta" });
    betaTitle.style.cssText = "display: block; margin-bottom: 0.5em; color: var(--text-accent);";
    const betaText = betaNotice.createEl("p", {
      text: "Ideatr is currently in beta. AI technology involves many moving parts, so things might not work as expected 100% of the time. We'd love to hear from you!"
    });
    betaText.style.cssText = "margin: 0.5em 0;";
    const betaActions = betaNotice.createDiv();
    betaActions.style.cssText = "margin-top: 0.75em; display: flex; gap: 0.5em; flex-wrap: wrap;";
    const reportButton = betaActions.createEl("a", {
      text: "\u{1F4DD} Report Bug or Request Feature",
      href: "#ideatr-feedback-section"
    });
    reportButton.style.cssText = "color: var(--text-accent); text-decoration: none; cursor: pointer;";
    reportButton.addEventListener("click", (e) => {
      e.preventDefault();
      setTimeout(() => {
        const feedbackSection2 = containerEl.querySelector("#ideatr-feedback-section");
        if (feedbackSection2) {
          feedbackSection2.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }, 100);
    });
    const roadmapLink = betaActions.createEl("a", {
      text: "\u{1F5FA}\uFE0F View Planned Features",
      href: "https://github.com/FallingWithStyle/obsidian-ideatr#roadmap",
      attr: { target: "_blank", rel: "noopener" }
    });
    roadmapLink.style.cssText = "color: var(--text-accent); text-decoration: none;";
    const githubLink = betaActions.createEl("a", {
      text: "\u{1F41B} GitHub Issues",
      href: "https://github.com/FallingWithStyle/obsidian-ideatr/issues",
      attr: { target: "_blank", rel: "noopener" }
    });
    githubLink.style.cssText = "color: var(--text-accent); text-decoration: none;";
    const llmSection = new LLMSettingsSection(this.app, this.plugin, this);
    const cloudAISection = new CloudAISettingsSection(this.app, this.plugin, this);
    const webSearchSection = new WebSearchSettingsSection(this.app, this.plugin, this);
    const nameVariantSection = new NameVariantSettingsSection(this.app, this.plugin, this);
    const scaffoldSection = new ScaffoldSettingsSection(this.app, this.plugin, this);
    const projectElevationSection = new ProjectElevationSettingsSection(this.app, this.plugin, this);
    const errorLoggingSection = new ErrorLoggingSettingsSection(this.app, this.plugin, this);
    const feedbackSection = new FeedbackSettingsSection(this.app, this.plugin, this);
    const captureModalSection = new CaptureModalSettingsSection(this.app, this.plugin, this);
    const tutorialSection = new TutorialSettingsSection(this.app, this.plugin, this);
    llmSection.display(containerEl);
    cloudAISection.display(containerEl);
    const validationTitle = containerEl.createDiv({ cls: "settings-section-title" });
    validationTitle.createEl("h2", { text: "Validation Tools" });
    const validationHelpIcon = createHelpIcon(this.app, "validation", "Learn about Validation Tools");
    validationTitle.appendChild(validationHelpIcon);
    webSearchSection.display(containerEl);
    const transformationTitle = containerEl.createDiv({ cls: "settings-section-title" });
    transformationTitle.createEl("h2", { text: "Transformation Tools" });
    const transformationHelpIcon = createHelpIcon(this.app, "transformation", "Learn about Transformation Tools");
    transformationTitle.appendChild(transformationHelpIcon);
    nameVariantSection.display(containerEl);
    scaffoldSection.display(containerEl);
    projectElevationSection.display(containerEl);
    const feedbackTitle = containerEl.createDiv({ cls: "settings-section-title", attr: { id: "ideatr-feedback-section" } });
    feedbackTitle.createEl("h2", { text: "Feedback & Support" });
    feedbackSection.display(containerEl);
    containerEl.createEl("h3", { text: "Error Logging" });
    errorLoggingSection.display(containerEl);
    const captureTitle = containerEl.createDiv({ cls: "settings-section-title" });
    captureTitle.createEl("h2", { text: "Capture Modal" });
    const captureHelpIcon = createHelpIcon(this.app, "capture-workflows", "Learn about Capture Modal");
    captureTitle.appendChild(captureHelpIcon);
    captureModalSection.display(containerEl);
    tutorialSection.display(containerEl);
  }
};

// src/core/ServiceInitializer.ts
var path7 = __toESM(require("path"));
var import_obsidian25 = require("obsidian");

// src/storage/FilenameGenerator.ts
var MAX_TITLE_LENGTH = 100;
function generateFilename(ideaText, _timestamp) {
  const title = sanitizeTitle(ideaText);
  return `${title}.md`;
}
function sanitizeTitle(text) {
  let title = text.trim().replace(/[:*?"<>|/\\]/g, "").replace(/\s+/g, " ").trim();
  if (title.length > MAX_TITLE_LENGTH) {
    title = title.substring(0, MAX_TITLE_LENGTH).trim();
  }
  if (title.length === 0) {
    title = "Untitled";
  }
  return title;
}
function addCollisionSuffix(filename, suffix) {
  const withoutExtension = filename.replace(/\.md$/, "");
  return `${withoutExtension}-${suffix}.md`;
}

// src/metadata/FrontmatterBuilder.ts
function buildFrontmatter(idea) {
  return {
    type: "idea",
    status: "captured",
    created: formatDateISO(idea.timestamp),
    id: 0,
    category: "",
    tags: [],
    related: [],
    domains: [],
    "existence-check": []
  };
}
function frontmatterToYAML(frontmatter) {
  const lines = [
    "---",
    `type: ${frontmatter.type}`,
    `status: ${frontmatter.status}`,
    `created: ${frontmatter.created}`,
    `id: ${frontmatter.id ?? 0}`,
    `category: ${frontmatter.category || ""}`,
    `tags: ${arrayToYAML(frontmatter.tags)}`,
    `related: ${arrayToYAML(frontmatter.related)}`,
    `domains: ${arrayToYAML(frontmatter.domains)}`,
    `existence-check: ${arrayToYAML(frontmatter["existence-check"])}`
  ];
  if (frontmatter.elevated) {
    lines.push(`elevated: ${frontmatter.elevated}`);
  }
  if (frontmatter.projectPath) {
    lines.push(`projectPath: ${frontmatter.projectPath}`);
  }
  if (frontmatter.codename) {
    lines.push(`codename: ${frontmatter.codename}`);
  }
  lines.push("---");
  return lines.join("\n");
}
function formatDateISO(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}
function arrayToYAML(arr) {
  if (arr.length === 0) {
    return "[]";
  }
  return `[${arr.join(", ")}]`;
}

// src/storage/FileManager.ts
var IDEAS_DIRECTORY = "Ideas";
var FileManager = class {
  vault;
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Create an idea file in the vault
   * Returns the created file
   */
  async createIdeaFile(idea) {
    await this.ensureIdeasDirectory();
    const filename = generateFilename(idea.text, idea.timestamp);
    let filepath = `${IDEAS_DIRECTORY}/${filename}`;
    filepath = await this.resolveCollision(filepath);
    const frontmatter = buildFrontmatter(idea);
    const yaml = frontmatterToYAML(frontmatter);
    const content = `${yaml}

${idea.text}`;
    const file = await this.vault.create(filepath, content);
    return file;
  }
  /**
   * Ensure Ideas directory exists, create if missing
   */
  async ensureIdeasDirectory() {
    const folder = this.vault.getAbstractFileByPath(IDEAS_DIRECTORY);
    if (!folder) {
      await this.vault.createFolder(IDEAS_DIRECTORY);
    }
  }
  /**
   * Resolve filename collisions by adding numeric suffix
   */
  async resolveCollision(filepath) {
    let currentPath = filepath;
    let suffix = 2;
    while (this.vault.getAbstractFileByPath(currentPath)) {
      const filename = filepath.split("/").pop() || "";
      const suffixedFilename = addCollisionSuffix(filename, suffix);
      currentPath = `${IDEAS_DIRECTORY}/${suffixedFilename}`;
      suffix++;
    }
    return currentPath;
  }
  /**
   * Check if a file exists at the given path
   */
  fileExists(filepath) {
    return this.vault.getAbstractFileByPath(filepath) !== null;
  }
  /**
   * Update frontmatter of an existing idea file
   */
  async updateIdeaFrontmatter(file, updates) {
    await this.vault.process(file, (content) => {
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        Logger.warn("No frontmatter found in file:", file.path);
        return content;
      }
      let newFrontmatter = match[1];
      const updateField = (key, value) => {
        const stringValue = Array.isArray(value) ? `[${value.join(", ")}]` : value;
        const fieldRegex = new RegExp(`^${key}:.*$`, "m");
        if (fieldRegex.test(newFrontmatter)) {
          newFrontmatter = newFrontmatter.replace(fieldRegex, `${key}: ${stringValue}`);
        } else {
          newFrontmatter += `
${key}: ${stringValue}`;
        }
      };
      Object.entries(updates).forEach(([key, value]) => {
        updateField(key, value);
      });
      return content.replace(frontmatterRegex, `---
${newFrontmatter}
---`);
    });
  }
  /**
   * Append content to file body, replacing existing section if found
   * @param file - File to modify
   * @param sectionTitle - Section title (e.g., "Name Variants")
   * @param content - Content to append (markdown formatted)
   * @param replaceExisting - If true, replace existing section; if false, append new section
   */
  async appendToFileBody(file, sectionTitle, content, replaceExisting = true) {
    await this.vault.process(file, (fileContent) => {
      const section = this.findSectionInContent(fileContent, sectionTitle);
      if (section && replaceExisting) {
        const before = fileContent.substring(0, section.start);
        const after = fileContent.substring(section.end);
        const newContent = this.ensureSpacing(before, "before") + content + this.ensureSpacing(after, "after");
        return newContent;
      } else if (section && !replaceExisting) {
        const before = fileContent.substring(0, section.end);
        const after = fileContent.substring(section.end);
        const newContent = this.ensureSpacing(before, "before") + "\n\n" + content + this.ensureSpacing(after, "after");
        return newContent;
      } else {
        const newContent = this.ensureSpacing(fileContent, "before") + "\n\n" + content;
        return newContent;
      }
    });
  }
  /**
   * Find section in content by title
   */
  findSectionInContent(content, sectionTitle) {
    const escaped = sectionTitle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const headerPattern = new RegExp(`^##\\s+${escaped}\\s*$`, "im");
    const match = content.match(headerPattern);
    if (!match || match.index === void 0) {
      return null;
    }
    const start = match.index;
    const headerEnd = start + match[0].length;
    const afterHeader = content.substring(headerEnd);
    const nextHeaderMatch = afterHeader.match(/^##\s+/m);
    if (nextHeaderMatch && nextHeaderMatch.index !== void 0) {
      return { start, end: headerEnd + nextHeaderMatch.index };
    }
    const blankLinePattern = /\n\n(?![\s]*[-*|])/;
    const blankLineMatch = afterHeader.match(blankLinePattern);
    if (blankLineMatch && blankLineMatch.index !== void 0) {
      const afterBlankLine = afterHeader.substring(blankLineMatch.index + 2);
      if (afterBlankLine.trim() && !afterBlankLine.match(/^\s*[-*|]/)) {
        return { start, end: headerEnd + blankLineMatch.index };
      }
    }
    return { start, end: content.length };
  }
  /**
   * Ensure proper spacing in content
   */
  ensureSpacing(text, position = "before") {
    if (position === "before") {
      return text.endsWith("\n") ? text : text + "\n";
    } else {
      return text.startsWith("\n") ? text : "\n" + text;
    }
  }
};

// src/services/SearchService.ts
var SearchService = class {
  vault;
  IDEAS_DIR = "Ideas/";
  MIN_SIMILARITY_THRESHOLD = 0.15;
  // Minimum similarity to be considered related
  constructor(vault) {
    this.vault = vault;
  }
  /**
   * Find related notes based on idea text
   */
  async findRelatedNotes(text, limit2 = 5) {
    const allFiles = this.vault.getMarkdownFiles();
    const ideaFiles = allFiles.filter((file) => file.path.startsWith(this.IDEAS_DIR));
    if (ideaFiles.length === 0) {
      return [];
    }
    const similarities = [];
    for (const file of ideaFiles) {
      try {
        const content = await this.vault.cachedRead(file);
        const bodyText = this.extractBodyText(content);
        const similarity = this.calculateSimilarity(text, bodyText);
        if (similarity >= this.MIN_SIMILARITY_THRESHOLD) {
          similarities.push({ file, similarity });
        }
      } catch (error) {
        Logger.warn(`Failed to read file ${file.path}:`, error);
      }
    }
    similarities.sort((a, b) => b.similarity - a.similarity);
    const topMatches = similarities.slice(0, limit2);
    return topMatches.map(({ file, similarity }) => ({
      path: file.path,
      title: file.basename,
      similarity
    }));
  }
  /**
   * Extract body text from markdown file, excluding frontmatter
   */
  extractBodyText(content) {
    const frontmatterRegex = /^---\n[\s\S]*?\n---(\n\n?|\n?)/;
    const bodyMatch = content.match(frontmatterRegex);
    const body = bodyMatch ? content.substring(bodyMatch[0].length) : content;
    return body.trim();
  }
  /**
   * Calculate similarity between two texts using improved Jaccard similarity
   * Filters out stop words and focuses on meaningful content
   */
  calculateSimilarity(text1, text2) {
    if (!text1 || !text2) {
      return 0;
    }
    const tokens1 = this.tokenize(text1);
    const tokens2 = this.tokenize(text2);
    if (tokens1.size === 0 || tokens2.size === 0) {
      return 0;
    }
    const intersection = new Set([...tokens1].filter((token) => tokens2.has(token)));
    const union = /* @__PURE__ */ new Set([...tokens1, ...tokens2]);
    if (union.size === 0) {
      return 0;
    }
    const baseSimilarity = intersection.size / union.size;
    const matchingRatio = intersection.size / Math.min(tokens1.size, tokens2.size);
    return Math.min(baseSimilarity * (1 + matchingRatio * 0.3), 1);
  }
  /**
   * Tokenize text into normalized words, filtering out stop words
   */
  tokenize(text) {
    const stopWords = /* @__PURE__ */ new Set([
      "the",
      "a",
      "an",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "from",
      "as",
      "is",
      "are",
      "was",
      "were",
      "been",
      "be",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "can",
      "this",
      "that",
      "these",
      "those",
      "i",
      "you",
      "he",
      "she",
      "it",
      "we",
      "they",
      "what",
      "which",
      "who",
      "when",
      "where",
      "why",
      "how",
      "all",
      "each",
      "every",
      "some",
      "any",
      "no",
      "other",
      "another",
      "such",
      "only",
      "just",
      "more",
      "most",
      "very",
      "much",
      "many",
      "few",
      "little",
      "own",
      "same",
      "so",
      "than",
      "too",
      "also"
    ]);
    const normalized = text.toLowerCase();
    const cleaned = normalized.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").replace(/#{1,6}\s+/g, "").replace(/\*\*([^\*]+)\*\*/g, "$1").replace(/\*([^\*]+)\*/g, "$1").replace(/`([^`]+)`/g, "$1").replace(/[^\w\s]/g, " ");
    const words = cleaned.split(/\s+/);
    const tokens = words.map((word) => word.trim()).filter((word) => word.length > 3 && !stopWords.has(word));
    return new Set(tokens);
  }
};

// src/services/ClassificationService.ts
var ClassificationService = class {
  llmService;
  searchService;
  constructor(llmService, searchService) {
    this.llmService = llmService;
    this.searchService = searchService;
  }
  /**
   * Check if AI classification is available
   */
  isAvailable() {
    return this.llmService.isAvailable();
  }
  /**
   * Classify an idea using available services
   */
  async classifyIdea(text) {
    const result = {
      category: "",
      tags: [],
      related: []
    };
    const tasks = [];
    if (this.llmService.isAvailable()) {
      tasks.push(
        this.llmService.classify(text).then((classification) => {
          result.category = classification.category;
          result.tags = [...new Set(classification.tags)];
        }).catch((error) => {
          Logger.warn("LLM classification failed:", error);
        })
      );
    }
    tasks.push(
      this.searchService.findRelatedNotes(text, 3).then((relatedNotes) => {
        result.related = relatedNotes.map((note) => note.path);
      }).catch((error) => {
        Logger.warn("Related note search failed:", error);
      })
    );
    await Promise.all(tasks);
    return result;
  }
};

// src/services/DuplicateDetector.ts
var DuplicateDetector = class {
  searchService;
  DEFAULT_THRESHOLD = 0.75;
  constructor(searchService) {
    this.searchService = searchService;
  }
  /**
   * Check if idea is a duplicate
   */
  async checkDuplicate(text, threshold) {
    const actualThreshold = threshold ?? this.DEFAULT_THRESHOLD;
    if (!text || text.trim().length === 0) {
      return {
        isDuplicate: false,
        duplicates: [],
        threshold: actualThreshold
      };
    }
    const relatedNotes = await this.searchService.findRelatedNotes(text, 10);
    const duplicates = relatedNotes.filter(
      (note) => note.similarity !== void 0 && note.similarity >= actualThreshold
    );
    return {
      isDuplicate: duplicates.length > 0,
      duplicates,
      threshold: actualThreshold
    };
  }
};

// src/services/DomainService.ts
var DomainService = class {
  prospectrService;
  constructor(prospectrService) {
    this.prospectrService = prospectrService;
  }
  /**
   * Extract domain names from idea text
   * 
   * Simple regex-based extraction for common domain patterns
   */
  extractDomains(text) {
    const domainPattern = /\b([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.(?:[a-zA-Z]{2,}))\b/g;
    const matches = text.match(domainPattern);
    if (!matches) {
      return [];
    }
    const quotedPattern = /["']([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})["']/g;
    const quotedMatches = text.match(quotedPattern);
    if (quotedMatches) {
      quotedMatches.forEach((match) => {
        const domain = match.replace(/["']/g, "");
        if (!matches.includes(domain)) {
          matches.push(domain);
        }
      });
    }
    const domainLabelPattern = /domain(?:s)?:\s*([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi;
    const labelMatches = text.match(domainLabelPattern);
    if (labelMatches) {
      labelMatches.forEach((match) => {
        const domain = match.replace(/domain(?:s)?:\s*/i, "").trim();
        if (domain && !matches.includes(domain)) {
          matches.push(domain);
        }
      });
    }
    return [...new Set(matches.map((d) => d.toLowerCase().trim()))];
  }
  /**
   * Check domain availability for an idea
   * 
   * Extracts domains from text and checks availability using domain checking service.
   * Only checks domains that are explicitly mentioned in the text.
   * 
   * @param text - Idea text to extract domains from
   * @param projectName - Optional project name (reserved for future use)
   */
  async checkDomains(text, _projectName) {
    const domains = this.extractDomains(text);
    if (domains.length === 0) {
      return [];
    }
    if (!this.prospectrService.isAvailable()) {
      return domains.map((domain) => ({
        domain,
        available: false,
        error: "Domain checking service is not available",
        checkedAt: (/* @__PURE__ */ new Date()).toISOString()
      }));
    }
    try {
      return await this.prospectrService.checkDomainsAvailability(domains);
    } catch (error) {
      Logger.warn("Domain checking failed:", error);
      return domains.map((domain) => ({
        domain,
        available: false,
        error: error instanceof Error ? error.message : "Unknown error",
        checkedAt: (/* @__PURE__ */ new Date()).toISOString()
      }));
    }
  }
};

// src/services/ProspectrService.ts
var ProspectrService = class {
  prospectrUrl;
  isEnabled;
  timeout;
  constructor(prospectrUrl = "http://localhost:3000", timeout = 1e4) {
    this.prospectrUrl = prospectrUrl;
    this.timeout = timeout;
    this.isEnabled = false;
  }
  /**
   * Check if domain checking service is available
   */
  isAvailable() {
    void this.prospectrUrl;
    void this.timeout;
    return this.isEnabled;
  }
  /**
   * Check if a domain is available
   * 
   * Stubbed implementation - returns placeholder result
   * When implemented, will use timeout for API calls
   */
  async checkDomainAvailability(domain) {
    if (!this.isAvailable()) {
      return {
        domain,
        available: false,
        error: "Domain checking service is not available",
        checkedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
    return {
      domain,
      available: false,
      error: "Domain checking service is not yet implemented",
      checkedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Check multiple domains at once
   */
  async checkDomainsAvailability(domains) {
    const results = await Promise.all(
      domains.map((domain) => this.checkDomainAvailability(domain))
    );
    return results;
  }
};

// src/services/WebSearchService.ts
var WebSearchService = class {
  settings;
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Check if web search service is available
   */
  isAvailable() {
    if (this.settings.webSearchProvider === "none") {
      return false;
    }
    if (this.settings.webSearchProvider === "google") {
      return !!(this.settings.googleSearchApiKey && this.settings.googleSearchEngineId);
    }
    return false;
  }
  /**
   * Search for similar ideas/products/services
   */
  async search(query, _context, maxResults) {
    if (!this.isAvailable() || !query || query.trim().length === 0) {
      return [];
    }
    const limit2 = maxResults || this.settings.maxSearchResults || 5;
    try {
      const results = await this.performSearch(query, limit2);
      return this.processResults(results, query);
    } catch (error) {
      Logger.warn("Web search failed:", error);
      return [];
    }
  }
  /**
   * Perform actual API call to Google Custom Search
   */
  async performSearch(query, maxResults) {
    if (this.settings.webSearchProvider !== "google") {
      throw new Error("Only Google Custom Search is currently supported");
    }
    const apiKey = this.settings.googleSearchApiKey;
    const engineId = this.settings.googleSearchEngineId;
    const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${engineId}&q=${encodeURIComponent(query)}&num=${Math.min(maxResults, 10)}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(
      () => controller.abort(),
      this.settings.webSearchTimeout
    );
    try {
      const response = await fetch(url, {
        signal: controller.signal,
        method: "GET"
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        if (response.status === 429) {
          throw new Error("API rate limit exceeded");
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      return data.items || [];
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error && error.name === "AbortError") {
        throw new Error(`Timeout: Request exceeded ${this.settings.webSearchTimeout}ms`);
      }
      throw error;
    }
  }
  /**
   * Process and score search results
   */
  processResults(items, query) {
    if (!items || items.length === 0) {
      return [];
    }
    const queryLower = query.toLowerCase();
    const queryWords = queryLower.split(/\s+/);
    const results = items.map((item) => {
      const title = item.title || "";
      const snippet = item.snippet || "";
      const url = item.link || "";
      let date;
      if (item.pagemap?.metatags) {
        for (const meta of item.pagemap.metatags) {
          if (meta["article:published_time"]) {
            date = meta["article:published_time"].split("T")[0];
            break;
          }
        }
      }
      const relevance = this.calculateRelevance(title, snippet, queryWords);
      return {
        title,
        url,
        snippet,
        date,
        relevance
      };
    });
    results.sort((a, b) => (b.relevance || 0) - (a.relevance || 0));
    return results.filter((r) => (r.relevance || 0) >= 0.3);
  }
  /**
   * Calculate relevance score based on title and snippet match
   */
  calculateRelevance(title, snippet, queryWords) {
    const titleLower = title.toLowerCase();
    const snippetLower = snippet.toLowerCase();
    const combined = `${titleLower} ${snippetLower}`;
    let score = 0;
    let matches = 0;
    for (const word of queryWords) {
      if (combined.includes(word)) {
        matches++;
        if (titleLower.includes(word)) {
          score += 0.3;
        } else {
          score += 0.1;
        }
      }
    }
    const matchRatio = matches / queryWords.length;
    score = Math.min(score + matchRatio * 0.2, 1);
    return Math.round(score * 100) / 100;
  }
};

// src/services/NameVariantCache.ts
var NameVariantCache = class {
  cache;
  ttl;
  // Time to live in milliseconds (24 hours default)
  maxSize;
  // Maximum number of entries (0 = unlimited)
  statistics;
  constructor(ttl = 24 * 60 * 60 * 1e3, maxSize = 0) {
    this.cache = /* @__PURE__ */ new Map();
    this.ttl = ttl;
    this.maxSize = maxSize;
    this.statistics = { hits: 0, misses: 0 };
  }
  /**
   * Get cached variants for an idea name
   */
  get(ideaName) {
    const key = this.normalizeKey(ideaName);
    const entry = this.cache.get(key);
    if (!entry) {
      this.statistics.misses++;
      return null;
    }
    const now = Date.now();
    if (now - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      this.statistics.misses++;
      return null;
    }
    this.statistics.hits++;
    return entry.variants;
  }
  /**
   * Store variants in cache with optional quality score
   */
  set(ideaName, variants, quality) {
    const key = this.normalizeKey(ideaName);
    if (this.maxSize > 0 && this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.evictOldest();
    }
    this.cache.set(key, {
      variants,
      timestamp: Date.now(),
      quality
    });
  }
  /**
   * Clear expired entries
   */
  clearExpired() {
    const now = Date.now();
    let cleared = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
        cleared++;
      }
    }
    return cleared;
  }
  /**
   * Clear all cache entries
   */
  clear() {
    this.cache.clear();
    this.statistics = { hits: 0, misses: 0 };
  }
  /**
   * Get cache size
   */
  size() {
    return this.cache.size;
  }
  /**
   * Get cache statistics
   */
  getStatistics() {
    const totalRequests = this.statistics.hits + this.statistics.misses;
    const hitRate = totalRequests > 0 ? this.statistics.hits / totalRequests : 0;
    let oldestEntry = null;
    let newestEntry = null;
    for (const entry of this.cache.values()) {
      if (oldestEntry === null || entry.timestamp < oldestEntry) {
        oldestEntry = entry.timestamp;
      }
      if (newestEntry === null || entry.timestamp > newestEntry) {
        newestEntry = entry.timestamp;
      }
    }
    return {
      totalEntries: this.cache.size,
      totalHits: this.statistics.hits,
      totalMisses: this.statistics.misses,
      hitRate: Math.round(hitRate * 100) / 100,
      // Round to 2 decimal places
      oldestEntry,
      newestEntry
    };
  }
  /**
   * Reset statistics
   */
  resetStatistics() {
    this.statistics = { hits: 0, misses: 0 };
  }
  /**
   * Load cache from serialized data
   */
  loadFromData(data) {
    this.cache.clear();
    const now = Date.now();
    for (const [key, entry] of Object.entries(data)) {
      if (now - entry.timestamp <= this.ttl) {
        this.cache.set(key, entry);
      }
    }
  }
  /**
   * Serialize cache to data (for persistence)
   */
  toData() {
    const data = {};
    for (const [key, entry] of this.cache.entries()) {
      data[key] = entry;
    }
    return data;
  }
  /**
   * Evict oldest entry (used when cache is full)
   */
  evictOldest() {
    let oldestKey = null;
    let oldestTimestamp = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (entry.timestamp < oldestTimestamp) {
        oldestTimestamp = entry.timestamp;
        oldestKey = key;
      }
    }
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }
  /**
   * Normalize key for caching (lowercase, trimmed)
   */
  normalizeKey(ideaName) {
    return ideaName.toLowerCase().trim();
  }
};

// src/services/VariantFormatter.ts
function getVariantTypeLabel(type) {
  const labels = {
    "synonym": "synonym",
    "short": "short",
    "domain-hack": "domain name",
    "phonetic": "phonetic",
    "portmanteau": "portmanteau",
    "made-up": "made-up"
  };
  return labels[type] || type;
}
function formatVariantsForMarkdown(variants, maxVariants = 10) {
  if (variants.length === 0) {
    return "## Name Variants\n\n(No variants generated)";
  }
  const unique = /* @__PURE__ */ new Map();
  for (const variant of variants) {
    const key = variant.text.toLowerCase();
    if (!unique.has(key)) {
      unique.set(key, variant);
    }
  }
  const sorted = Array.from(unique.values()).sort((a, b) => a.text.localeCompare(b.text)).slice(0, maxVariants);
  const lines = sorted.map((v) => `- ${v.text} (${getVariantTypeLabel(v.type)})`);
  return `## Name Variants

${lines.join("\n")}`;
}

// src/services/NameVariantService.ts
async function extractIdeaName(ideaText, llmService, useLLM = false) {
  if (!ideaText || ideaText.trim().length === 0) {
    return "";
  }
  if (useLLM && llmService) {
    return await extractIdeaNameWithLLM(ideaText, llmService);
  }
  return extractIdeaNameRuleBased(ideaText);
}
function extractIdeaNameSync(ideaText) {
  return extractIdeaNameRuleBased(ideaText);
}
var NameVariantService = class {
  llmService;
  settings;
  cache;
  loadCacheData;
  saveCacheData;
  constructor(llmService, settings, loadCacheData, saveCacheData) {
    this.llmService = llmService;
    this.settings = settings;
    this.cache = new NameVariantCache(
      24 * 60 * 60 * 1e3,
      // 24 hour TTL
      settings.variantCacheMaxSize || 0
    );
    this.loadCacheData = loadCacheData;
    this.saveCacheData = saveCacheData;
    if (settings.variantCachePersist && loadCacheData) {
      this.loadCache().catch((err) => {
        Logger.warn("Failed to load variant cache:", err);
      });
    }
  }
  /**
   * Load cache from persistent storage
   */
  async loadCache() {
    if (!this.loadCacheData)
      return;
    try {
      const data = await this.loadCacheData();
      if (data && typeof data === "object") {
        this.cache.loadFromData(data);
      }
    } catch (error) {
      Logger.warn("Failed to load variant cache:", error);
    }
  }
  /**
   * Save cache to persistent storage
   */
  async saveCache() {
    if (!this.settings.variantCachePersist || !this.saveCacheData)
      return;
    try {
      const data = this.cache.toData();
      await this.saveCacheData(data);
    } catch (error) {
      Logger.warn("Failed to save variant cache:", error);
    }
  }
  /**
   * Get cache statistics
   */
  getCacheStatistics() {
    return this.cache.getStatistics();
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
    this.saveCache().catch((err) => {
      Logger.warn("Failed to save cache after clear:", err);
    });
  }
  async generateVariants(ideaText, ideaName) {
    const name = ideaName || await extractIdeaName(
      ideaText,
      this.llmService,
      this.settings.useLLMForNameExtraction || false
    );
    if (!name || name.trim().length === 0) {
      return [];
    }
    const cached = this.cache.get(name);
    if (cached) {
      return cached;
    }
    if (this.llmService.isAvailable()) {
      try {
        const variants = await this.generateVariantsWithLLM(name);
        if (variants.length > 0) {
          const avgQuality2 = this.calculateAverageQuality(variants);
          this.cache.set(name, variants, avgQuality2);
          if (this.settings.variantCachePersist) {
            this.saveCache().catch((err) => Logger.warn("Cache save failed:", err));
          }
          return variants;
        }
      } catch (error) {
        Logger.warn("LLM variant generation failed, using fallback:", error);
      }
    }
    const fallbackVariants = this.generateFallbackVariants(name);
    const avgQuality = this.calculateAverageQuality(fallbackVariants, false);
    this.cache.set(name, fallbackVariants, avgQuality);
    if (this.settings.variantCachePersist) {
      this.saveCache().catch((err) => Logger.warn("Cache save failed:", err));
    }
    return fallbackVariants;
  }
  isAvailable() {
    return true;
  }
  /**
   * Generate variants using LLM
   */
  async generateVariantsWithLLM(ideaName) {
    const prompt = this.constructPrompt(ideaName);
    if (this.llmService.complete && typeof this.llmService.complete === "function") {
      try {
        const response = await this.llmService.complete(prompt, {
          temperature: 0.8,
          // Higher creativity for better variants
          n_predict: 512,
          // Increased for more variants (8-12)
          stop: ["}"]
        });
        const variants = this.parseVariantResponse(response);
        if (variants.length > 0) {
          return variants;
        }
      } catch (error) {
        Logger.warn("LLM completion failed, using fallback:", error);
      }
    }
    return [];
  }
  /**
   * Parse LLM response into NameVariant array
   */
  parseVariantResponse(content) {
    try {
      const repaired = extractAndRepairJSON(content, false);
      const parsed = JSON.parse(repaired);
      if (!parsed.variants || !Array.isArray(parsed.variants)) {
        return [];
      }
      return parsed.variants.filter((v) => v.text && v.type).map((v) => ({
        text: String(v.text).trim(),
        type: this.validateVariantType(v.type),
        quality: this.calculateVariantQuality(String(v.text).trim(), this.validateVariantType(v.type))
      })).slice(0, this.settings.maxVariants || 10);
    } catch (error) {
      Logger.warn("Failed to parse variant response:", content, error);
      return [];
    }
  }
  /**
   * Validate variant type
   */
  validateVariantType(type) {
    const validTypes = ["synonym", "short", "domain-hack", "phonetic", "portmanteau", "made-up"];
    return validTypes.includes(type) ? type : "made-up";
  }
  /**
   * Construct prompt for LLM variant generation
   */
  constructPrompt(ideaName) {
    return `Generate creative, brandable name variants for: "${ideaName}"

CRITICAL REQUIREMENTS:
- Extract the CORE CONCEPT, not just use the literal text
- Focus on what makes the idea unique and memorable
- Generate names that could actually be used as product/brand names
- Prioritize creativity and memorability over literal translation

Generate 8-12 high-quality, brandable name variants. Each variant must be:
- Memorable and easy to pronounce (test: can you say it out loud naturally?)
- Distinct and creative (avoid generic words like "AI", "App", "Tool")
- Brandable (could you see this as a real product name?)
- 2-15 characters for most variants (domain hacks can be slightly longer if clever)

Variant types (use diverse mix):
1. synonym - Words capturing the idea's essence (e.g., "puzzle game" \u2192 "Riddle", "Enigma")
2. short - Concise, punchy names 3-8 chars (e.g., "notification" \u2192 "Ping", "Buzz")
3. domain-hack - TLD completes word naturally, MUST be short and clever (e.g., "find.it", "read.ly", NOT "longphrase.io")
4. phonetic - Similar sound, different spelling (e.g., "notify" \u2192 "Notifai")
5. portmanteau - Blend two relevant words (e.g., "net" + "flicks" \u2192 "Netflix")
6. made-up - Invented but pronounceable words (e.g., "Zapier", "Slack", "Figma")

STRICT RULES:
- NEVER create unpronounceable acronyms (e.g., "AGPFOIM" is BAD)
- If using acronyms, they must be 6 chars or fewer AND pronounceable (e.g., "ACME", "NASA")
- Domain hacks: Must be SHORT (under 12 chars total) and clever, not just appending .io to long phrases
- Avoid overly generic terms (e.g., "AI", "App", "Tool" alone are too generic)
- Short names: Must be meaningful words or pronounceable invented words, not random letters
- Extract the essence: For "AI puzzle with monkeys like Where's Waldo" \u2192 focus on "puzzle", "find", "monkey", "hidden", not the full description

Examples:

Input: "notification app"
Output: {
  "variants": [
    {"text": "Alert", "type": "synonym"},
    {"text": "Ping", "type": "short"},
    {"text": "Buzz", "type": "short"},
    {"text": "notif.io", "type": "domain-hack"},
    {"text": "Notifai", "type": "phonetic"},
    {"text": "Alertify", "type": "made-up"},
    {"text": "Signal", "type": "synonym"},
    {"text": "Chime", "type": "short"}
  ]
}

Input: "AI generated puzzle full of interlinked monkeys that look similar, sort of a where's waldo of monkeys"
Output: {
  "variants": [
    {"text": "MonkeyFind", "type": "portmanteau"},
    {"text": "PrimateSeek", "type": "portmanteau"},
    {"text": "FindMonkey", "type": "portmanteau"},
    {"text": "WaldoMonkey", "type": "portmanteau"},
    {"text": "SpotTheApe", "type": "portmanteau"},
    {"text": "MonkeyHunt", "type": "portmanteau"},
    {"text": "PrimatePuzzle", "type": "portmanteau"},
    {"text": "ApeSpot", "type": "short"},
    {"text": "MonkeySee", "type": "portmanteau"},
    {"text": "find.ape", "type": "domain-hack"},
    {"text": "Spotly", "type": "made-up"},
    {"text": "Primate", "type": "synonym"}
  ]
}

Input: "meditation tracker"
Output: {
  "variants": [
    {"text": "Mindful", "type": "synonym"},
    {"text": "Zen", "type": "short"},
    {"text": "Breathe", "type": "synonym"},
    {"text": "Mindspace", "type": "portmanteau"},
    {"text": "Breathly", "type": "made-up"},
    {"text": "Calmly", "type": "made-up"},
    {"text": "Zenly", "type": "made-up"}
  ]
}

Input: "task manager"
Output: {
  "variants": [
    {"text": "Organize", "type": "synonym"},
    {"text": "Tasker", "type": "short"},
    {"text": "Doable", "type": "made-up"},
    {"text": "get.done", "type": "domain-hack"},
    {"text": "Taskly", "type": "phonetic"},
    {"text": "Tackle", "type": "synonym"},
    {"text": "Action", "type": "synonym"}
  ]
}

Input: "${ideaName}"
Output: {`;
  }
  /**
   * Format variants as markdown for file body
   */
  formatVariantsForMarkdown(variants) {
    return formatVariantsForMarkdown(variants, this.settings.maxVariants || 10);
  }
  /**
   * Calculate quality score for a single variant (0-1)
   * Higher scores indicate better quality variants
   */
  calculateVariantQuality(text, type) {
    let score = 0.5;
    if (text.length >= 3 && text.length <= 15) {
      score += 0.2;
    } else if (text.length > 15 && text.length <= 25) {
      score += 0.1;
    } else if (text.length < 3 || text.length > 30) {
      score -= 0.2;
    }
    const typeScores = {
      "synonym": 0.15,
      "portmanteau": 0.15,
      "phonetic": 0.1,
      "short": 0.05,
      "domain-hack": 0.05,
      "made-up": 0
    };
    score += typeScores[type] || 0;
    if (/^[a-z]+$/i.test(text)) {
      score += 0.1;
    }
    if (text.split(/\s+/).length <= 2) {
      score += 0.05;
    }
    return Math.max(0, Math.min(1, score));
  }
  /**
   * Calculate average quality score for an array of variants
   */
  calculateAverageQuality(variants, isLLM = true) {
    if (variants.length === 0)
      return 0;
    const scores = variants.map((v) => {
      if (v.quality !== void 0) {
        return v.quality;
      }
      return this.calculateVariantQuality(v.text, v.type);
    });
    const avg = scores.reduce((sum, s) => sum + s, 0) / scores.length;
    return isLLM ? Math.min(1, avg + 0.1) : avg;
  }
  /**
   * Generate fallback variants using simple rule-based transformations
   */
  generateFallbackVariants(ideaName) {
    const variants = [];
    const words = ideaName.split(/\s+/).filter((w) => w.length > 0 && w.length <= 15);
    const cleanName = ideaName.replace(/\s+/g, "").toLowerCase();
    const meaningfulWords = words.filter((w) => {
      const lower = w.toLowerCase();
      return !["the", "a", "an", "of", "for", "with", "that", "this", "is", "are", "was", "were"].includes(lower);
    });
    const wordsToUse = meaningfulWords.length > 0 ? meaningfulWords : words;
    if (wordsToUse.length > 0) {
      const firstWord = wordsToUse[0];
      if (firstWord.length >= 3 && firstWord.length <= 12) {
        const capitalized = firstWord.charAt(0).toUpperCase() + firstWord.slice(1).toLowerCase();
        variants.push({ text: capitalized, type: "short" });
      }
    }
    if (cleanName.length > 0 && cleanName.length <= 12) {
      variants.push({ text: `${cleanName}.io`, type: "domain-hack" });
      if (cleanName.length <= 10) {
        variants.push({ text: `${cleanName}.app`, type: "domain-hack" });
      }
    }
    if (wordsToUse.length >= 2) {
      const word1 = wordsToUse[0].toLowerCase();
      const word2 = wordsToUse[1].toLowerCase();
      if (word1.length <= 8 && word2.length <= 8) {
        const portmanteau1 = word1 + word2;
        const portmanteau2 = word1.substring(0, Math.min(4, word1.length)) + word2;
        if (portmanteau1.length <= 12) {
          const capitalized = portmanteau1.charAt(0).toUpperCase() + portmanteau1.slice(1);
          variants.push({ text: capitalized, type: "portmanteau" });
        }
        if (portmanteau2.length <= 12 && portmanteau2 !== portmanteau1) {
          const capitalized = portmanteau2.charAt(0).toUpperCase() + portmanteau2.slice(1);
          variants.push({ text: capitalized, type: "portmanteau" });
        }
      }
    }
    if (wordsToUse.length >= 2 && wordsToUse.length <= 4) {
      const acronym = wordsToUse.map((w) => w[0]?.toUpperCase() || "").join("");
      if (acronym.length >= 2 && acronym.length <= 4) {
        variants.push({ text: acronym, type: "short" });
      }
    }
    const variantsWithQuality = variants.map((v) => ({
      ...v,
      quality: this.calculateVariantQuality(v.text, v.type)
    })).slice(0, this.settings.maxVariants || 8);
    return variantsWithQuality;
  }
};

// src/services/templates.ts
var categoryToTemplateMap = {
  "saas": "project",
  "tool": "project",
  "ux": "project",
  "game": "game-mechanic",
  "mechanic": "game-mechanic",
  "story": "narrative-seed",
  "ip": "narrative-seed",
  "hardware": "hardware-concept",
  "brand": "hardware-concept",
  "personal": "generic-idea",
  "": "generic-idea"
  // Fallback for empty category
};
var projectTemplate = {
  id: "project",
  name: "Project Scaffold",
  categories: ["saas", "tool", "ux"],
  sections: [
    {
      title: "Overview",
      content: "## Overview\n\n**Name**: {{ideaName}}\n\n{{ideaText}}\n\n**Category**: {{category}}\n\n**Created**: {{created}}"
    },
    {
      title: "Core Features",
      content: "## Core Features\n\n- [ ] Feature 1\n- [ ] Feature 2\n- [ ] Feature 3",
      questions: [
        "What are the core features of this project?",
        "What problems does it solve?",
        "Who is the target audience?"
      ]
    },
    {
      title: "Technical Considerations",
      content: "## Technical Considerations\n\n- Technology stack\n- Architecture decisions\n- Scalability requirements",
      questions: [
        "What technologies are needed?",
        "What are the technical challenges?",
        "What infrastructure is required?"
      ]
    },
    {
      title: "Next Steps",
      content: "## Next Steps\n\n- [ ] Research existing solutions\n- [ ] Validate market need\n- [ ] Create prototype\n- [ ] Gather feedback"
    }
  ]
};
var gameMechanicTemplate = {
  id: "game-mechanic",
  name: "Game Mechanic Scaffold",
  categories: ["game", "mechanic"],
  sections: [
    {
      title: "Overview",
      content: "## Overview\n\n**Name**: {{ideaName}}\n\n{{ideaText}}\n\n**Category**: {{category}}\n\n**Created**: {{created}}"
    },
    {
      title: "Mechanic Description",
      content: "## Mechanic Description\n\nDescribe how the mechanic works:\n\n- Core gameplay loop\n- Player interactions\n- Progression systems",
      questions: [
        "How does this mechanic work?",
        "What makes it engaging?",
        "How does it fit into the larger game?"
      ]
    },
    {
      title: "Implementation Considerations",
      content: "## Implementation Considerations\n\n- Technical requirements\n- Balance and tuning\n- Player feedback systems",
      questions: [
        "What technical challenges exist?",
        "How will this be balanced?",
        "What metrics will measure success?"
      ]
    },
    {
      title: "Next Steps",
      content: "## Next Steps\n\n- [ ] Create prototype\n- [ ] Playtest mechanic\n- [ ] Iterate based on feedback\n- [ ] Document design decisions"
    }
  ]
};
var narrativeSeedTemplate = {
  id: "narrative-seed",
  name: "Narrative Seed Scaffold",
  categories: ["story", "ip"],
  sections: [
    {
      title: "Overview",
      content: "## Overview\n\n**Name**: {{ideaName}}\n\n{{ideaText}}\n\n**Category**: {{category}}\n\n**Created**: {{created}}"
    },
    {
      title: "Core Concept",
      content: "## Core Concept\n\n- Main premise\n- Key themes\n- Unique elements",
      questions: [
        "What is the central premise?",
        "What themes does this explore?",
        "What makes this story unique?"
      ]
    },
    {
      title: "Characters and World",
      content: "## Characters and World\n\n- Main characters\n- Setting details\n- World-building elements",
      questions: [
        "Who are the main characters?",
        "Where does this take place?",
        "What are the key world-building elements?"
      ]
    },
    {
      title: "Development",
      content: "## Development\n\n- Plot structure\n- Key scenes\n- Resolution",
      questions: [
        "What is the story structure?",
        "What are the key turning points?",
        "How does it resolve?"
      ]
    }
  ]
};
var hardwareConceptTemplate = {
  id: "hardware-concept",
  name: "Hardware Concept Scaffold",
  categories: ["hardware", "brand"],
  sections: [
    {
      title: "Overview",
      content: "## Overview\n\n**Name**: {{ideaName}}\n\n{{ideaText}}\n\n**Category**: {{category}}\n\n**Created**: {{created}}"
    },
    {
      title: "Product Description",
      content: "## Product Description\n\n- Physical specifications\n- Key features\n- Design considerations",
      questions: [
        "What does this product do?",
        "What are the key features?",
        "What is the target market?"
      ]
    },
    {
      title: "Technical Requirements",
      content: "## Technical Requirements\n\n- Components needed\n- Manufacturing considerations\n- Technical challenges",
      questions: [
        "What components are required?",
        "What are the manufacturing challenges?",
        "What technical expertise is needed?"
      ]
    },
    {
      title: "Next Steps",
      content: "## Next Steps\n\n- [ ] Create detailed specifications\n- [ ] Research manufacturing options\n- [ ] Build prototype\n- [ ] Test and iterate"
    }
  ]
};
var genericIdeaTemplate = {
  id: "generic-idea",
  name: "Idea Scaffold",
  categories: ["personal", ""],
  sections: [
    {
      title: "Overview",
      content: "## Overview\n\n**Name**: {{ideaName}}\n\n{{ideaText}}\n\n**Category**: {{category}}\n\n**Created**: {{created}}"
    },
    {
      title: "Key Points",
      content: "## Key Points\n\n- Main concept\n- Important details\n- Related ideas",
      questions: [
        "What is the core idea?",
        "What are the key elements?",
        "What should be explored further?"
      ]
    },
    {
      title: "Next Steps",
      content: "## Next Steps\n\n- [ ] Research\n- [ ] Develop further\n- [ ] Take action"
    }
  ]
};
var templates = [
  projectTemplate,
  gameMechanicTemplate,
  narrativeSeedTemplate,
  hardwareConceptTemplate,
  genericIdeaTemplate
];
function selectTemplate(category) {
  const templateId = categoryToTemplateMap[category] || "generic-idea";
  return templates.find((t) => t.id === templateId) || genericIdeaTemplate;
}

// src/services/ScaffoldService.ts
var import_obsidian24 = require("obsidian");
var TEMPLATES_DIR = ".ideatr/templates";
var ScaffoldService = class {
  vault;
  customTemplates = [];
  allTemplates = [];
  constructor(vault) {
    this.vault = vault;
    this.allTemplates = [...templates];
    if (vault) {
      this.loadCustomTemplates().catch((err) => {
        Logger.warn("Failed to load custom templates:", err);
      });
    }
  }
  /**
   * Load custom templates from vault
   */
  async loadCustomTemplates() {
    if (!this.vault)
      return;
    try {
      const templatesDir = this.vault.getAbstractFileByPath(TEMPLATES_DIR);
      if (!templatesDir) {
        this.updateAllTemplates();
        return;
      }
      const files = this.vault.getFiles().filter(
        (file) => file.path.startsWith(TEMPLATES_DIR + "/") && file.extension === "json"
      );
      const loadedTemplates = [];
      for (const file of files) {
        try {
          const content = await this.vault.read(file);
          const template = JSON.parse(content);
          if (this.validateTemplate(template)) {
            loadedTemplates.push(template);
          } else {
            Logger.warn(`Invalid template structure in ${file.path}`);
          }
        } catch (error) {
          Logger.warn(`Failed to load template from ${file.path}:`, error);
        }
      }
      this.customTemplates = loadedTemplates;
      this.updateAllTemplates();
    } catch (error) {
      Logger.warn("Failed to load custom templates:", error);
      this.updateAllTemplates();
    }
  }
  /**
   * Update all templates (merge custom with defaults, custom overrides)
   */
  updateAllTemplates() {
    const templateMap = /* @__PURE__ */ new Map();
    for (const template of templates) {
      templateMap.set(template.id, template);
    }
    for (const template of this.customTemplates) {
      templateMap.set(template.id, template);
    }
    this.allTemplates = Array.from(templateMap.values());
  }
  /**
   * Validate template structure
   */
  validateTemplate(template) {
    return template && typeof template.id === "string" && typeof template.name === "string" && Array.isArray(template.categories) && Array.isArray(template.sections) && template.sections.every(
      (s) => typeof s.title === "string" && typeof s.content === "string"
    );
  }
  /**
   * Save a custom template to vault
   */
  async saveCustomTemplate(template) {
    if (!this.vault) {
      throw new Error("Vault not available for saving templates");
    }
    const templatesDir = this.vault.getAbstractFileByPath(TEMPLATES_DIR);
    if (!templatesDir) {
      await this.vault.createFolder(TEMPLATES_DIR);
    }
    const filename = `${template.id}.json`;
    const filepath = `${TEMPLATES_DIR}/${filename}`;
    const content = JSON.stringify(template, null, 2);
    const existingFile = this.vault.getAbstractFileByPath(filepath);
    if (existingFile && existingFile instanceof import_obsidian24.TFile) {
      await this.vault.modify(existingFile, content);
    } else {
      await this.vault.create(filepath, content);
    }
    await this.loadCustomTemplates();
  }
  /**
   * Delete a custom template
   */
  async deleteCustomTemplate(templateId) {
    if (!this.vault) {
      throw new Error("Vault not available for deleting templates");
    }
    const filepath = `${TEMPLATES_DIR}/${templateId}.json`;
    const file = this.vault.getAbstractFileByPath(filepath);
    if (file && file instanceof import_obsidian24.TFile) {
      await this.vault.delete(file);
      await this.loadCustomTemplates();
    }
  }
  getAvailableTemplates() {
    return this.allTemplates;
  }
  isAvailable() {
    return true;
  }
  async generateScaffold(ideaText, category, ideaName) {
    const name = ideaName || extractIdeaNameSync(ideaText);
    const template = this.selectTemplate(category);
    const variables = {
      ideaName: name,
      ideaText: ideaText || "",
      category: category || "uncategorized",
      created: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      tags: ""
      // Could extract from frontmatter if available
    };
    const sections = template.sections.map((section) => {
      let content = this.substituteVariables(section.content, variables);
      if (section.questions && section.questions.length > 0) {
        const questionsList = section.questions.map((q) => `- ${q}`).join("\n");
        content += `

### Questions to Consider

${questionsList}`;
      }
      return content;
    });
    return sections.join("\n\n");
  }
  /**
   * Select template based on category (supports custom templates)
   */
  selectTemplate(category) {
    const templateId = selectTemplate(category).id;
    return this.allTemplates.find((t) => t.id === templateId) || this.allTemplates.find((t) => t.id === "generic-idea") || this.allTemplates[0];
  }
  /**
   * Substitute variables in template content
   */
  substituteVariables(content, variables) {
    let result = content;
    for (const [key, value] of Object.entries(variables)) {
      const pattern = new RegExp(`\\{\\{${key}\\}\\}`, "g");
      result = result.replace(pattern, value || "");
    }
    return result;
  }
};

// src/services/FrontmatterParser.ts
var FrontmatterParser = class {
  /**
   * Parse frontmatter from file content
   * @param content - Full file content including frontmatter
   * @returns Parsed frontmatter or null if invalid
   */
  parseFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (!match || !match[1]) {
      return null;
    }
    const frontmatterBlock = match[1];
    const frontmatter = {};
    const lines = frontmatterBlock.split("\n");
    let type = null;
    let status = null;
    let created = null;
    let id = 0;
    let category = "";
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.startsWith("type:")) {
        type = trimmed.substring(5).trim();
      } else if (trimmed.startsWith("status:")) {
        status = trimmed.substring(7).trim();
      } else if (trimmed.startsWith("created:")) {
        created = trimmed.substring(8).trim();
      } else if (trimmed.startsWith("id:")) {
        const idValue = trimmed.substring(3).trim();
        const parsedId = parseInt(idValue, 10);
        if (!isNaN(parsedId)) {
          id = parsedId;
        }
      } else if (trimmed.startsWith("category:")) {
        category = trimmed.substring(9).trim();
      }
    }
    if (!type || !status || !created) {
      return null;
    }
    frontmatter.type = type;
    frontmatter.status = status;
    frontmatter.created = created;
    frontmatter.id = id;
    frontmatter.category = category;
    frontmatter.tags = this.parseArrayField(frontmatterBlock, "tags");
    frontmatter.related = this.parseArrayField(frontmatterBlock, "related");
    frontmatter.domains = this.parseArrayField(frontmatterBlock, "domains");
    frontmatter["existence-check"] = this.parseArrayField(frontmatterBlock, "existence-check");
    const elevatedMatch = frontmatterBlock.match(/^elevated:\s*(.+)$/m);
    const projectPathMatch = frontmatterBlock.match(/^projectPath:\s*(.+)$/m);
    const codenameMatch = frontmatterBlock.match(/^codename:\s*(.+)$/m);
    if (elevatedMatch) {
      frontmatter.elevated = elevatedMatch[1].trim();
    }
    if (projectPathMatch) {
      frontmatter.projectPath = projectPathMatch[1].trim();
    }
    if (codenameMatch) {
      frontmatter.codename = codenameMatch[1].trim();
    }
    const dismissedMatch = frontmatterBlock.match(/^dismissed:\s*(.+)$/m);
    const actedUponMatch = frontmatterBlock.match(/^actedUpon:\s*(.+)$/m);
    if (dismissedMatch) {
      frontmatter.dismissed = dismissedMatch[1].trim().toLowerCase() === "true";
    }
    if (actedUponMatch) {
      frontmatter.actedUpon = actedUponMatch[1].trim().toLowerCase() === "true";
    }
    if (!this.validateFrontmatter(frontmatter)) {
      return null;
    }
    return frontmatter;
  }
  /**
   * Parse array field from frontmatter block
   * Handles formats: [] or [item1, item2, item3]
   */
  parseArrayField(block, fieldName) {
    const regex = new RegExp(`^${fieldName}:\\s*(.+)$`, "m");
    const match = block.match(regex);
    if (!match) {
      return [];
    }
    const value = match[1].trim();
    if (value === "[]") {
      return [];
    }
    const arrayMatch = value.match(/^\[(.+)\]$/);
    if (arrayMatch) {
      const items = arrayMatch[1].split(",").map((item) => item.trim()).filter((item) => item.length > 0);
      return items;
    }
    return [];
  }
  /**
   * Parse complete idea file from file and content
   * @param file - File object with path and name
   * @param content - File content
   * @returns Complete idea file structure
   */
  parseIdeaFile(file, content) {
    const frontmatter = this.parseFrontmatter(content);
    if (!frontmatter) {
      const defaultFrontmatter = {
        type: "idea",
        status: "captured",
        created: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        id: 0,
        category: "",
        tags: [],
        related: [],
        domains: [],
        "existence-check": []
      };
      return {
        frontmatter: defaultFrontmatter,
        body: this.extractBody(content),
        filename: file.name
      };
    }
    return {
      frontmatter,
      body: this.extractBody(content),
      filename: file.name
    };
  }
  /**
   * Parse content and return frontmatter and body
   * Convenience method that combines parseFrontmatter and extractBody
   * Returns default frontmatter if parsing fails
   */
  parse(content) {
    const frontmatter = this.parseFrontmatter(content);
    const body = this.extractBody(content);
    if (!frontmatter) {
      const defaultFrontmatter = {
        type: "idea",
        status: "captured",
        created: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        id: 0,
        category: "",
        tags: [],
        related: [],
        domains: [],
        "existence-check": []
      };
      return { frontmatter: defaultFrontmatter, body };
    }
    return { frontmatter, body };
  }
  /**
   * Build complete file content from frontmatter and body
   * @param frontmatter - Frontmatter object
   * @param body - Body text
   * @returns Complete file content with frontmatter and body
   */
  build(frontmatter, body) {
    const yaml = frontmatterToYAML(frontmatter);
    return `${yaml}

${body}`;
  }
  /**
   * Extract body text from file content (remove frontmatter)
   */
  extractBody(content) {
    const frontmatterRegex = /^---\n[\s\S]*?\n---(\n\n?|\n?)/;
    const body = content.replace(frontmatterRegex, "");
    return body.trim();
  }
  /**
   * Validate frontmatter structure
   * @param frontmatter - Frontmatter object to validate
   * @returns True if valid, false otherwise
   */
  validateFrontmatter(frontmatter) {
    if (!frontmatter.type || frontmatter.type !== "idea") {
      return false;
    }
    const validStatuses = ["captured", "elevated", "archived", "validated", "promoted"];
    if (!frontmatter.status || !validStatuses.includes(frontmatter.status)) {
      return false;
    }
    if (!frontmatter.created || typeof frontmatter.created !== "string") {
      return false;
    }
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(frontmatter.created)) {
      return false;
    }
    if (frontmatter.id === void 0 || typeof frontmatter.id !== "number") {
      frontmatter.id = 0;
    }
    if (frontmatter.category !== void 0 && typeof frontmatter.category !== "string") {
      return false;
    }
    const arrayFields = ["tags", "related", "domains", "existence-check"];
    for (const field of arrayFields) {
      if (frontmatter[field] !== void 0 && !Array.isArray(frontmatter[field])) {
        return false;
      }
    }
    return true;
  }
};

// src/services/IdeaRepository.ts
var IdeaRepository = class {
  // Prevent unbounded cache growth
  constructor(vault, parser) {
    this.vault = vault;
    this.parser = parser || new FrontmatterParser();
  }
  cache = /* @__PURE__ */ new Map();
  watchers = /* @__PURE__ */ new Set();
  parser;
  MAX_CACHE_SIZE = 1e4;
  /**
   * Get all ideas from the vault
   * @returns Array of parsed idea files
   */
  async getAllIdeas() {
    const allFiles = this.vault.getMarkdownFiles();
    const ideaFiles = allFiles.filter((file) => file.path.startsWith("Ideas/"));
    const ideas = [];
    for (const file of ideaFiles) {
      try {
        const content = await this.vault.read(file);
        const idea = this.parser.parseIdeaFile(file, content);
        ideas.push(idea);
        this.cache.set(file.path, idea);
        if (this.cache.size > this.MAX_CACHE_SIZE) {
          const firstKey = this.cache.keys().next().value;
          if (firstKey) {
            this.cache.delete(firstKey);
          }
        }
      } catch (error) {
        const managementError = new ManagementError(
          `Failed to read idea file: ${file.path}`,
          "FILE_READ_ERROR" /* FILE_READ_ERROR */
        );
        Logger.warn(managementError.message, managementError);
      }
    }
    return ideas;
  }
  /**
   * Get ideas matching filter criteria
   * @param filter - Filter criteria
   * @returns Array of filtered idea files
   */
  async getIdeasByFilter(filter) {
    const allIdeas = this.cache.size > 0 ? Array.from(this.cache.values()) : await this.getAllIdeas();
    let filtered = allIdeas;
    if (filter.categories && filter.categories.length > 0) {
      filtered = filtered.filter(
        (idea) => filter.categories.includes(idea.frontmatter.category)
      );
    }
    if (filter.tags && filter.tags.length > 0) {
      filtered = filtered.filter(
        (idea) => filter.tags.some((tag) => idea.frontmatter.tags.includes(tag))
      );
    }
    if (filter.status) {
      filtered = filtered.filter((idea) => idea.frontmatter.status === filter.status);
    }
    if (filter.uncategorized) {
      filtered = filtered.filter((idea) => idea.frontmatter.category === "");
    }
    if (filter.searchText) {
      const searchLower = filter.searchText.toLowerCase();
      filtered = filtered.filter((idea) => {
        const title = idea.filename.toLowerCase();
        const body = idea.body.toLowerCase();
        const tags = idea.frontmatter.tags.join(" ").toLowerCase();
        return title.includes(searchLower) || body.includes(searchLower) || tags.includes(searchLower);
      });
    }
    if (filter.dateRange) {
      filtered = filtered.filter((idea) => {
        const createdDate = new Date(idea.frontmatter.created);
        return createdDate >= filter.dateRange.start && createdDate <= filter.dateRange.end;
      });
    }
    return filtered;
  }
  /**
   * Get a single idea by file path
   * @param path - File path relative to vault root
   * @returns Idea file or null if not found
   */
  async getIdeaByPath(path9) {
    if (!path9.startsWith("Ideas/")) {
      return null;
    }
    const file = this.vault.getAbstractFileByPath(path9);
    if (!file) {
      return null;
    }
    try {
      const content = await this.vault.read(file);
      const idea = this.parser.parseIdeaFile(file, content);
      this.cache.set(path9, idea);
      if (this.cache.size > this.MAX_CACHE_SIZE) {
        const firstKey = this.cache.keys().next().value;
        if (firstKey) {
          this.cache.delete(firstKey);
        }
      }
      return idea;
    } catch (error) {
      Logger.warn(`Failed to read idea file: ${path9}`, error);
      return null;
    }
  }
  /**
   * Watch for changes to ideas and notify callback
   * @param callback - Function called when ideas change
   * @returns Unsubscribe function
   */
  watchIdeas(callback) {
    const onFileChange = async (file) => {
      if (file.path.startsWith("Ideas/")) {
        try {
          const content = await this.vault.read(file);
          const idea = this.parser.parseIdeaFile(file, content);
          this.cache.set(file.path, idea);
        } catch (error) {
          this.cache.delete(file.path);
        }
        const allIdeas = Array.from(this.cache.values());
        callback(allIdeas);
      }
    };
    const onDelete = (file) => {
      if (file.path.startsWith("Ideas/")) {
        this.cache.delete(file.path);
        const allIdeas = Array.from(this.cache.values());
        callback(allIdeas);
      }
    };
    const unregisterModify = this.vault.on("modify", onFileChange);
    const unregisterCreate = this.vault.on("create", onFileChange);
    const unregisterDelete = this.vault.on("delete", onDelete);
    this.watchers.add(unregisterModify);
    this.watchers.add(unregisterCreate);
    this.watchers.add(unregisterDelete);
    return () => {
      unregisterModify();
      unregisterCreate();
      unregisterDelete();
      this.watchers.delete(unregisterModify);
      this.watchers.delete(unregisterCreate);
      this.watchers.delete(unregisterDelete);
    };
  }
  /**
   * Refresh the idea cache (force re-read all files)
   */
  async refresh() {
    this.cache.clear();
    await this.getAllIdeas();
  }
};

// src/services/EmbeddingService.ts
var EmbeddingService = class {
  /**
   * Check if embedding service is available
   */
  isAvailable() {
    return true;
  }
  /**
   * Generate embedding for a single text
   * For v1, this creates a "pseudo-embedding" based on text similarity
   * @param text - Text to embed
   * @returns Embedding vector (simplified representation)
   */
  async generateEmbedding(text) {
    const words = this.tokenize(text);
    const wordFreq = this.calculateWordFrequencies(words);
    const embedding = [];
    const uniqueWords = Array.from(new Set(words));
    for (let i = 0; i < 50; i++) {
      let value = 0;
      for (const word of uniqueWords) {
        const hash = this.simpleHash(word + i);
        value += hash % 100 / 100 * wordFreq[word];
      }
      embedding.push(value / uniqueWords.length);
    }
    return embedding;
  }
  /**
   * Generate embeddings for multiple texts (batch)
   * @param texts - Array of texts to embed
   * @returns Array of embedding vectors
   */
  async generateEmbeddings(texts) {
    return Promise.all(texts.map((text) => this.generateEmbedding(text)));
  }
  /**
   * Calculate similarity matrix for ideas
   * @param ideas - Array of ideas
   * @returns 2D matrix where matrix[i][j] is similarity between idea i and j
   */
  async calculateSimilarityMatrix(ideas) {
    const matrix = [];
    for (let i = 0; i < ideas.length; i++) {
      const row = [];
      const text1 = this.getIdeaText(ideas[i]);
      for (let j = 0; j < ideas.length; j++) {
        if (i === j) {
          row.push(1);
        } else {
          const text2 = this.getIdeaText(ideas[j]);
          const similarity = this.calculateSimilarity(text1, text2);
          row.push(similarity);
        }
      }
      matrix.push(row);
    }
    return matrix;
  }
  /**
   * Calculate similarity between two texts using keyword matching
   */
  calculateSimilarity(text1, text2) {
    const words1 = new Set(this.tokenize(text1.toLowerCase()));
    const words2 = new Set(this.tokenize(text2.toLowerCase()));
    if (words1.size === 0 && words2.size === 0) {
      return 1;
    }
    if (words1.size === 0 || words2.size === 0) {
      return 0;
    }
    const intersection = new Set([...words1].filter((x) => words2.has(x)));
    const union = /* @__PURE__ */ new Set([...words1, ...words2]);
    return intersection.size / union.size;
  }
  /**
   * Tokenize text into words
   */
  tokenize(text) {
    return text.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 0);
  }
  /**
   * Calculate word frequencies
   */
  calculateWordFrequencies(words) {
    const freq = {};
    for (const word of words) {
      freq[word] = (freq[word] || 0) + 1;
    }
    return freq;
  }
  /**
   * Simple hash function
   */
  simpleHash(str2) {
    let hash = 0;
    for (let i = 0; i < str2.length; i++) {
      const char = str2.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  /**
   * Get text representation of idea for similarity calculation
   */
  getIdeaText(idea) {
    const parts = [];
    if (idea.frontmatter.category) {
      parts.push(idea.frontmatter.category);
    }
    parts.push(...idea.frontmatter.tags);
    parts.push(idea.body);
    return parts.join(" ");
  }
};

// src/services/ClusteringService.ts
var ClusteringService = class {
  constructor(embeddingService, similarityThreshold = 0.3) {
    this.embeddingService = embeddingService;
    this.similarityThreshold = similarityThreshold;
  }
  /**
   * Cluster ideas based on similarity
   * @param ideas - Ideas to cluster
   * @param embeddings - Optional embeddings for each idea (if not provided, will generate)
   * @returns Array of clusters
   */
  async clusterIdeas(ideas, embeddings) {
    if (ideas.length === 0) {
      return [];
    }
    if (ideas.length === 1) {
      return [{
        id: "cluster-0",
        ideas: [ideas[0]],
        label: "Single Idea"
      }];
    }
    let similarityMatrix;
    if (embeddings) {
      similarityMatrix = this.calculateSimilarityMatrixFromEmbeddings(embeddings);
    } else {
      if (this.embeddingService instanceof EmbeddingService) {
        similarityMatrix = await this.embeddingService.calculateSimilarityMatrix(ideas);
      } else {
        const texts = ideas.map((idea) => this.getIdeaText(idea));
        const generatedEmbeddings = await this.embeddingService.generateEmbeddings(texts);
        similarityMatrix = this.calculateSimilarityMatrixFromEmbeddings(generatedEmbeddings);
      }
    }
    const clusters = this.hierarchicalClustering(ideas, similarityMatrix);
    return clusters;
  }
  /**
   * Calculate similarity between two embeddings using cosine similarity
   * @param embedding1 - First embedding
   * @param embedding2 - Second embedding
   * @returns Similarity score (0-1)
   */
  calculateSimilarity(embedding1, embedding2) {
    if (embedding1.length !== embedding2.length) {
      return 0;
    }
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    for (let i = 0; i < embedding1.length; i++) {
      dotProduct += embedding1[i] * embedding2[i];
      norm1 += embedding1[i] * embedding1[i];
      norm2 += embedding2[i] * embedding2[i];
    }
    const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);
    if (magnitude === 0) {
      return 0;
    }
    const similarity = dotProduct / magnitude;
    return (similarity + 1) / 2;
  }
  /**
   * Calculate similarity matrix from embeddings
   */
  calculateSimilarityMatrixFromEmbeddings(embeddings) {
    const matrix = [];
    for (let i = 0; i < embeddings.length; i++) {
      const row = [];
      for (let j = 0; j < embeddings.length; j++) {
        if (i === j) {
          row.push(1);
        } else {
          const similarity = this.calculateSimilarity(embeddings[i], embeddings[j]);
          row.push(similarity);
        }
      }
      matrix.push(row);
    }
    return matrix;
  }
  /**
   * Perform hierarchical clustering using agglomerative approach
   */
  hierarchicalClustering(ideas, similarityMatrix) {
    let clusters = ideas.map((idea, index) => ({
      id: `cluster-${index}`,
      ideas: [idea],
      label: this.generateClusterLabel([idea])
    }));
    while (clusters.length > 1) {
      let maxSimilarity = -1;
      let mergeIndex1 = -1;
      let mergeIndex2 = -1;
      for (let i = 0; i < clusters.length; i++) {
        for (let j = i + 1; j < clusters.length; j++) {
          const similarity = this.calculateClusterSimilarity(
            clusters[i],
            clusters[j],
            similarityMatrix,
            ideas
          );
          if (similarity > maxSimilarity) {
            maxSimilarity = similarity;
            mergeIndex1 = i;
            mergeIndex2 = j;
          }
        }
      }
      if (maxSimilarity < this.similarityThreshold) {
        break;
      }
      const mergedCluster = {
        id: `cluster-${clusters.length}`,
        ideas: [...clusters[mergeIndex1].ideas, ...clusters[mergeIndex2].ideas],
        label: this.generateClusterLabel([...clusters[mergeIndex1].ideas, ...clusters[mergeIndex2].ideas])
      };
      clusters = clusters.filter((_, index) => index !== mergeIndex1 && index !== mergeIndex2);
      clusters.push(mergedCluster);
    }
    return clusters.map((cluster, index) => ({
      ...cluster,
      id: `cluster-${index}`
    }));
  }
  /**
   * Calculate similarity between two clusters using average linkage
   */
  calculateClusterSimilarity(cluster1, cluster2, similarityMatrix, allIdeas) {
    const indices1 = cluster1.ideas.map((idea) => allIdeas.findIndex((i) => i.filename === idea.filename));
    const indices2 = cluster2.ideas.map((idea) => allIdeas.findIndex((i) => i.filename === idea.filename));
    let totalSimilarity = 0;
    let count = 0;
    for (const idx1 of indices1) {
      for (const idx2 of indices2) {
        if (idx1 >= 0 && idx2 >= 0 && idx1 < similarityMatrix.length && idx2 < similarityMatrix[idx1].length) {
          totalSimilarity += similarityMatrix[idx1][idx2];
          count++;
        }
      }
    }
    return count > 0 ? totalSimilarity / count : 0;
  }
  /**
   * Generate label for cluster based on ideas
   */
  generateClusterLabel(ideas) {
    if (ideas.length === 0) {
      return "Empty Cluster";
    }
    if (ideas.length === 1) {
      return ideas[0].frontmatter.category || "Uncategorized";
    }
    const categories = ideas.map((idea) => idea.frontmatter.category).filter((c) => c);
    if (categories.length === 0) {
      return "Mixed Ideas";
    }
    const categoryCounts = {};
    for (const category of categories) {
      categoryCounts[category] = (categoryCounts[category] || 0) + 1;
    }
    const mostCommon = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1])[0];
    return mostCommon ? `${mostCommon[0]} (${ideas.length})` : "Mixed Ideas";
  }
  /**
   * Get text representation of idea
   */
  getIdeaText(idea) {
    const parts = [];
    if (idea.frontmatter.category) {
      parts.push(idea.frontmatter.category);
    }
    parts.push(...idea.frontmatter.tags);
    parts.push(idea.body);
    return parts.join(" ");
  }
};

// src/services/GraphLayoutService.ts
var GraphLayoutService = class {
  /**
   * Generate graph layout from clusters
   * @param clusters - Clusters to layout
   * @param width - Canvas width
   * @param height - Canvas height
   * @returns Graph layout with node positions
   */
  layoutGraph(clusters, width, height) {
    if (clusters.length === 0) {
      return {
        nodes: [],
        edges: [],
        width,
        height
      };
    }
    const nodes = [];
    const edges = [];
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) * 0.3;
    let nodeIdCounter = 0;
    for (const cluster of clusters) {
      const clusterAngle = 2 * Math.PI * clusters.indexOf(cluster) / clusters.length;
      const clusterX = centerX + radius * Math.cos(clusterAngle);
      const clusterY = centerY + radius * Math.sin(clusterAngle);
      const nodesPerRow = Math.ceil(Math.sqrt(cluster.ideas.length));
      const nodeSpacing = 50;
      cluster.ideas.forEach((idea, index) => {
        const row = Math.floor(index / nodesPerRow);
        const col = index % nodesPerRow;
        const offsetX = (col - nodesPerRow / 2) * nodeSpacing;
        const offsetY = (row - nodesPerRow / 2) * nodeSpacing;
        nodes.push({
          id: `node-${nodeIdCounter++}`,
          idea,
          x: clusterX + offsetX,
          y: clusterY + offsetY,
          clusterId: cluster.id
        });
      });
    }
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        if (nodes[i].clusterId === nodes[j].clusterId) {
          const weight = this.calculateNodeSimilarity(nodes[i].idea, nodes[j].idea);
          if (weight > 0.1) {
            edges.push({
              from: nodes[i].id,
              to: nodes[j].id,
              weight
            });
          }
        }
      }
    }
    return {
      nodes,
      edges,
      width,
      height
    };
  }
  /**
   * Update layout when ideas change
   * @param layout - Current layout
   * @param changes - Changed ideas
   * @returns Updated layout
   */
  updateLayout(layout, changes) {
    if (!changes.length || !layout.nodes.length) {
      return layout;
    }
    const nodesByFilename = /* @__PURE__ */ new Map();
    for (const node of layout.nodes) {
      nodesByFilename.set(node.idea.filename, node);
    }
    const updatedNodes = [...layout.nodes];
    const updatedEdges = [...layout.edges];
    const avgX = layout.nodes.reduce((sum, node) => sum + node.x, 0) / layout.nodes.length;
    const avgY = layout.nodes.reduce((sum, node) => sum + node.y, 0) / layout.nodes.length;
    const baseClusterId = layout.nodes[0]?.clusterId ?? "cluster-0";
    let newNodeIndex = 0;
    for (const idea of changes) {
      const existingNode = nodesByFilename.get(idea.filename);
      if (existingNode) {
        existingNode.idea = idea;
        continue;
      }
      const offset = 30 + newNodeIndex * 20;
      const sign = newNodeIndex % 2 === 0 ? 1 : -1;
      const newNode = {
        id: `node-${updatedNodes.length + newNodeIndex}`,
        idea,
        x: Math.min(Math.max(avgX + sign * offset, 0), layout.width),
        y: Math.min(Math.max(avgY + sign * offset, 0), layout.height),
        clusterId: baseClusterId
      };
      updatedNodes.push(newNode);
      for (const existing of layout.nodes) {
        if (existing.clusterId !== newNode.clusterId)
          continue;
        const weight = this.calculateNodeSimilarity(existing.idea, idea);
        if (weight > 0.1) {
          updatedEdges.push({
            from: existing.id,
            to: newNode.id,
            weight
          });
        }
      }
      newNodeIndex++;
    }
    return {
      ...layout,
      nodes: updatedNodes,
      edges: updatedEdges
    };
  }
  /**
   * Calculate similarity between two ideas for edge weight
   */
  calculateNodeSimilarity(idea1, idea2) {
    let similarity = 0;
    if (idea1.frontmatter.category === idea2.frontmatter.category && idea1.frontmatter.category) {
      similarity += 0.3;
    }
    const tags1 = new Set(idea1.frontmatter.tags);
    const tags2 = new Set(idea2.frontmatter.tags);
    const tagIntersection = new Set([...tags1].filter((t) => tags2.has(t)));
    const tagUnion = /* @__PURE__ */ new Set([...tags1, ...tags2]);
    if (tagUnion.size > 0) {
      similarity += 0.2 * (tagIntersection.size / tagUnion.size);
    }
    const words1 = new Set(this.tokenize(idea1.body));
    const words2 = new Set(this.tokenize(idea2.body));
    const wordIntersection = new Set([...words1].filter((w) => words2.has(w)));
    const wordUnion = /* @__PURE__ */ new Set([...words1, ...words2]);
    if (wordUnion.size > 0) {
      similarity += 0.5 * (wordIntersection.size / wordUnion.size);
    }
    return Math.min(similarity, 1);
  }
  /**
   * Tokenize text into words
   */
  tokenize(text) {
    return text.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 2);
  }
};

// src/services/ResurfacingService.ts
var ResurfacingService = class {
  constructor(ideaRepository, settings, vault) {
    this.ideaRepository = ideaRepository;
    this.settings = settings;
    this.vault = vault;
  }
  /**
   * Identify old ideas based on age threshold
   * @param thresholdDays - Number of days since creation (default: 7)
   * @returns Array of old ideas
   */
  async identifyOldIdeas(thresholdDays) {
    const threshold = thresholdDays || this.settings.resurfacingThresholdDays || 7;
    const allIdeas = await this.ideaRepository.getAllIdeas();
    const now = /* @__PURE__ */ new Date();
    const thresholdDate = new Date(now.getTime() - threshold * 24 * 60 * 60 * 1e3);
    const oldIdeas = [];
    for (const idea of allIdeas) {
      const createdDate = new Date(idea.frontmatter.created);
      if (isNaN(createdDate.getTime())) {
        const managementError = new ManagementError(
          `Failed to parse date for idea ${idea.filename}`,
          "DATE_PARSE_ERROR" /* DATE_PARSE_ERROR */
        );
        Logger.warn(managementError.message, managementError);
        continue;
      }
      if (createdDate < thresholdDate) {
        const isDismissed = await this.isDismissedOrActedUpon(`Ideas/${idea.filename}`);
        if (!isDismissed) {
          oldIdeas.push(idea);
        }
      }
    }
    return oldIdeas;
  }
  /**
   * Generate digest for old ideas
   * @param ideas - Ideas to include in digest (optional, will identify if not provided)
   * @returns Generated digest
   */
  async generateDigest(ideas) {
    const oldIdeas = ideas || await this.identifyOldIdeas();
    oldIdeas.sort((a, b) => {
      const dateA = new Date(a.frontmatter.created).getTime();
      const dateB = new Date(b.frontmatter.created).getTime();
      return dateA - dateB;
    });
    const summary = this.generateDigestMarkdown(oldIdeas);
    return {
      id: `digest-${Date.now()}`,
      generatedAt: /* @__PURE__ */ new Date(),
      ideas: oldIdeas,
      summary
    };
  }
  /**
   * Mark idea as dismissed (exclude from future digests)
   * @param ideaPath - Path to idea file
   */
  async markAsDismissed(ideaPath) {
    if (!this.vault) {
      Logger.warn("Vault not available, cannot mark as dismissed");
      return;
    }
    const file = this.vault.getAbstractFileByPath(ideaPath);
    if (!file) {
      Logger.warn(`File not found: ${ideaPath}`);
      return;
    }
    const fileManager = new FileManager(this.vault);
    await fileManager.updateIdeaFrontmatter(file, {
      dismissed: true,
      dismissedAt: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
    });
  }
  /**
   * Mark idea as acted upon (exclude from future digests)
   * @param ideaPath - Path to idea file
   */
  async markAsActedUpon(ideaPath) {
    if (!this.vault) {
      Logger.warn("Vault not available, cannot mark as acted upon");
      return;
    }
    const file = this.vault.getAbstractFileByPath(ideaPath);
    if (!file) {
      Logger.warn(`File not found: ${ideaPath}`);
      return;
    }
    const fileManager = new FileManager(this.vault);
    await fileManager.updateIdeaFrontmatter(file, {
      actedUpon: true,
      actedUponAt: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
    });
  }
  /**
   * Check if idea is dismissed or acted upon
   * @param ideaPath - Path to idea file
   * @returns True if dismissed or acted upon
   */
  async isDismissedOrActedUpon(ideaPath) {
    const idea = await this.ideaRepository.getIdeaByPath(ideaPath);
    if (!idea) {
      return false;
    }
    const frontmatter = idea.frontmatter;
    return !!(frontmatter.dismissed || frontmatter.actedUpon);
  }
  /**
   * Generate markdown digest content
   */
  generateDigestMarkdown(ideas) {
    if (ideas.length === 0) {
      return "# Weekly Idea Digest\n\nNo old ideas found.";
    }
    const lines = [
      "# Weekly Idea Digest",
      "",
      `Generated on: ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`,
      "",
      "## Old Ideas Needing Attention",
      ""
    ];
    for (const idea of ideas) {
      const age = this.calculateAge(idea.frontmatter.created);
      const preview = idea.body.substring(0, 200);
      const truncated = idea.body.length > 200;
      lines.push(`### ${idea.filename.replace(".md", "")}`);
      lines.push("");
      lines.push(`**Category**: ${idea.frontmatter.category || "Uncategorized"}`);
      lines.push(`**Created**: ${idea.frontmatter.created}`);
      lines.push(`**Age**: ${age} days`);
      if (idea.frontmatter.tags.length > 0) {
        lines.push(`**Tags**: ${idea.frontmatter.tags.join(", ")}`);
      }
      lines.push("");
      lines.push(preview + (truncated ? "..." : ""));
      lines.push("");
      lines.push(`[Open Idea](Ideas/${idea.filename})`);
      lines.push("");
      lines.push("---");
      lines.push("");
    }
    lines.push("## Summary");
    lines.push("");
    lines.push(`- **Total Ideas**: ${ideas.length}`);
    const categoryCounts = {};
    for (const idea of ideas) {
      const category = idea.frontmatter.category || "Uncategorized";
      categoryCounts[category] = (categoryCounts[category] || 0) + 1;
    }
    const categoryBreakdown = Object.entries(categoryCounts).map(([cat, count]) => `${cat}: ${count}`).join(", ");
    lines.push(`- **By Category**: ${categoryBreakdown}`);
    lines.push("");
    return lines.join("\n");
  }
  /**
   * Calculate age of idea in days
   */
  calculateAge(createdDate) {
    try {
      const created = new Date(createdDate);
      const now = /* @__PURE__ */ new Date();
      const diffTime = Math.abs(now.getTime() - created.getTime());
      const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      return diffDays;
    } catch {
      return 0;
    }
  }
};

// src/services/ProjectElevationService.ts
var ProjectElevationService = class {
  vault;
  frontmatterParser;
  settings;
  constructor(vault, frontmatterParser, settings) {
    this.vault = vault;
    this.frontmatterParser = frontmatterParser;
    this.settings = settings;
  }
  /**
   * Get projects directory from settings
   */
  getProjectsDirectory() {
    return this.settings.elevationProjectsDirectory || "Projects";
  }
  /**
   * Get default folders from settings
   */
  getDefaultFolders() {
    const foldersStr = this.settings.elevationDefaultFolders || "docs,notes,assets";
    return foldersStr.split(",").map((f) => f.trim()).filter((f) => f.length > 0);
  }
  /**
   * Validate if an idea can be elevated
   */
  canElevate(ideaFile) {
    if (!ideaFile.frontmatter || !ideaFile.frontmatter.type || !ideaFile.frontmatter.status) {
      return false;
    }
    if (ideaFile.frontmatter.status === "elevated") {
      return false;
    }
    if (ideaFile.frontmatter.type !== "idea") {
      return false;
    }
    return true;
  }
  /**
   * Generate project name from idea
   */
  generateProjectName(ideaFile) {
    let name = extractIdeaNameRuleBased(ideaFile.body);
    if (!name || name.trim().length === 0) {
      const filenameWithoutExt = ideaFile.filename.replace(/\.md$/, "");
      const formatMatch = filenameWithoutExt.match(/^\d{4}-\d{2}-\d{2}\s+(.+)$/);
      if (formatMatch) {
        name = formatMatch[1];
      } else {
        name = filenameWithoutExt;
      }
    }
    return this.sanitizeProjectName(name);
  }
  /**
   * Sanitize project name for filesystem use
   */
  sanitizeProjectName(name) {
    let sanitized = name.toLowerCase();
    sanitized = sanitized.replace(/[^a-z0-9-]/g, "-");
    sanitized = sanitized.replace(/-+/g, "-");
    sanitized = sanitized.replace(/^-+|-+$/g, "");
    if (sanitized.length > 50) {
      sanitized = sanitized.substring(0, 50);
      sanitized = sanitized.replace(/-+$/, "");
    }
    if (sanitized.length < 1) {
      sanitized = "project";
    }
    return sanitized;
  }
  /**
   * Check if project name is available
   */
  async isProjectNameAvailable(projectName) {
    const projectPath = `${this.getProjectsDirectory()}/${projectName}`;
    const existing = this.vault.getAbstractFileByPath(projectPath);
    return existing === null;
  }
  /**
   * Elevate an idea to a project
   */
  async elevateIdea(ideaFile, projectName) {
    if (!this.canElevate(ideaFile)) {
      return {
        success: false,
        error: "Idea cannot be elevated. It may already be elevated or have invalid frontmatter."
      };
    }
    const originalPath = `Ideas/${ideaFile.filename}`;
    const originalFile = this.vault.getAbstractFileByPath(originalPath);
    if (!originalFile) {
      return {
        success: false,
        error: `Idea file not found: ${originalPath}`
      };
    }
    const baseProjectName = projectName || this.generateProjectName(ideaFile);
    const finalProjectName = await this.resolveProjectNameCollision(baseProjectName);
    const projectPath = `${this.getProjectsDirectory()}/${finalProjectName}`;
    const createdPaths = [];
    const warnings = [];
    try {
      const originalContent = await this.vault.read(originalFile);
      await this.ensureProjectsDirectory();
      await this.createProjectStructure(projectPath, createdPaths);
      const updatedContent = await this.prepareElevatedContent(originalContent, projectPath);
      await this.vault.create(`${projectPath}/README.md`, updatedContent);
      createdPaths.push(`${projectPath}/README.md`);
      try {
        await this.handleDevraIntegration(projectPath, ideaFile);
        createdPaths.push(`${projectPath}/.devra.json`);
      } catch (error) {
        warnings.push("Failed to create project metadata file (non-fatal)");
        Logger.warn("Project metadata integration failed:", error);
      }
      try {
        await this.vault.delete(originalFile);
      } catch (error) {
        warnings.push("Failed to delete original idea file (project created successfully)");
        Logger.warn("Failed to delete original file:", error);
      }
      return {
        success: true,
        projectPath,
        warnings: warnings.length > 0 ? warnings : void 0
      };
    } catch (error) {
      await this.rollback(createdPaths);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error during elevation"
      };
    }
  }
  /**
   * Resolve project name collision by adding numeric suffix
   */
  async resolveProjectNameCollision(baseName) {
    let projectName = baseName;
    let suffix = 2;
    while (!await this.isProjectNameAvailable(projectName)) {
      projectName = `${baseName}-${suffix}`;
      suffix++;
    }
    return projectName;
  }
  /**
   * Ensure Projects directory exists
   */
  async ensureProjectsDirectory() {
    const projectsDir = this.getProjectsDirectory();
    const folder = this.vault.getAbstractFileByPath(projectsDir);
    if (!folder) {
      await this.vault.createFolder(projectsDir);
    }
  }
  /**
   * Create project folder structure
   */
  async createProjectStructure(projectPath, createdPaths) {
    const folders = this.getDefaultFolders();
    await this.vault.createFolder(projectPath);
    createdPaths.push(projectPath);
    for (const folder of folders) {
      const folderPath = `${projectPath}/${folder}`;
      await this.vault.createFolder(folderPath);
      createdPaths.push(folderPath);
    }
  }
  /**
   * Prepare content for elevated project (update frontmatter)
   */
  async prepareElevatedContent(originalContent, projectPath) {
    const frontmatter = this.frontmatterParser.parseFrontmatter(originalContent);
    if (!frontmatter) {
      throw new Error("Failed to parse frontmatter from original file");
    }
    const bodyMatch = originalContent.match(/^---\n[\s\S]*?\n---(\n\n?|\n?)([\s\S]*)$/);
    const body = bodyMatch ? bodyMatch[2].trim() : "";
    const updatedFrontmatter = {
      ...frontmatter,
      status: "elevated",
      elevated: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      projectPath
    };
    const yaml = frontmatterToYAML(updatedFrontmatter);
    return `${yaml}

${body}`;
  }
  /**
   * Handle project metadata integration (stubbed)
   */
  async handleDevraIntegration(projectPath, ideaFile) {
    if (!this.settings.elevationCreateDevraMetadata) {
      return;
    }
    const devraMetadata = {
      name: this.generateProjectName(ideaFile),
      type: "project",
      source: "ideatr",
      elevated: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      ideaPath: ideaFile.filename,
      ideaCategory: ideaFile.frontmatter.category || "",
      ideaTags: ideaFile.frontmatter.tags || [],
      devraReady: false,
      devraProjectPath: null
    };
    const metadataPath = `${projectPath}/.devra.json`;
    await this.vault.adapter.write(metadataPath, JSON.stringify(devraMetadata, null, 2));
  }
  /**
   * Rollback created paths on failure
   */
  async rollback(createdPaths) {
    for (const path9 of [...createdPaths].reverse()) {
      try {
        const file = this.vault.getAbstractFileByPath(path9);
        if (file) {
          if ("extension" in file) {
            await this.vault.delete(file);
          } else {
            await this.vault.adapter.rmdir(path9, true);
          }
        }
      } catch (error) {
        Logger.warn(`Failed to rollback ${path9}:`, error);
      }
    }
  }
};

// src/services/TenuousLinkService.ts
var TenuousLinkServiceImpl = class {
  vault;
  embeddingService;
  llmService;
  MIN_SIMILARITY = 0.3;
  MAX_SIMILARITY = 0.5;
  constructor(vault, embeddingService, llmService) {
    this.vault = vault;
    this.embeddingService = embeddingService;
    this.llmService = llmService;
  }
  async findTenuousLinks(ideaText, ideaCategory, ideaTags, existingRelated) {
    const allFiles = this.vault.getMarkdownFiles();
    const ideaFiles = allFiles.filter(
      (file) => file.path.startsWith("Ideas/") && !file.path.startsWith("Ideas/Archived/")
    );
    const candidateLinks = [];
    for (const file of ideaFiles) {
      if (existingRelated.includes(file.path)) {
        continue;
      }
      try {
        const content = await this.vault.cachedRead(file);
        const bodyMatch = content.match(/^---\n[\s\S]*?\n---\n\n?([\s\S]*)$/);
        const body = bodyMatch ? bodyMatch[1].trim() : content.trim();
        if (body.length === 0) {
          continue;
        }
        const similarity = await this.calculateSimilarity(ideaText, body);
        if (similarity >= this.MIN_SIMILARITY && similarity <= this.MAX_SIMILARITY) {
          const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
          if (frontmatterMatch) {
            const frontmatter = frontmatterMatch[1];
            const categoryMatch = frontmatter.match(/^category:\s*(.+)$/m);
            const category = categoryMatch ? categoryMatch[1].trim() : "";
            if (category === ideaCategory) {
              continue;
            }
            candidateLinks.push({ file, similarity, content: body });
          }
        }
      } catch (error) {
        Logger.warn(`Failed to process ${file.path} for tenuous links:`, error);
      }
    }
    const tenuousLinks = [];
    for (const candidate of candidateLinks.slice(0, 10)) {
      try {
        const analysis = await this.analyzeConnection(
          ideaText,
          ideaCategory,
          ideaTags,
          candidate.content,
          candidate.similarity
        );
        if (analysis.relevance > 0.5) {
          tenuousLinks.push({
            idea: {
              path: candidate.file.path,
              title: candidate.file.basename,
              similarity: candidate.similarity
            },
            similarity: candidate.similarity,
            explanation: analysis.explanation,
            synergy: analysis.synergy,
            relevance: analysis.relevance
          });
        }
      } catch (error) {
        Logger.warn(`Failed to analyze connection with ${candidate.file.path}:`, error);
      }
    }
    tenuousLinks.sort((a, b) => b.relevance - a.relevance);
    return tenuousLinks;
  }
  /**
   * Calculate similarity between two texts
   * Uses EmbeddingService's similarity calculation
   */
  async calculateSimilarity(text1, text2) {
    const embedding1 = await this.embeddingService.generateEmbedding(text1);
    const embedding2 = await this.embeddingService.generateEmbedding(text2);
    return this.cosineSimilarity(embedding1, embedding2);
  }
  /**
   * Calculate cosine similarity between two embedding vectors
   */
  cosineSimilarity(vec1, vec2) {
    if (vec1.length !== vec2.length) {
      return 0;
    }
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    for (let i = 0; i < vec1.length; i++) {
      dotProduct += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    const denominator = Math.sqrt(norm1) * Math.sqrt(norm2);
    if (denominator === 0) {
      return 0;
    }
    return dotProduct / denominator;
  }
  /**
   * Use LLM to analyze a potential connection
   */
  async analyzeConnection(ideaText, ideaCategory, ideaTags, relatedIdeaText, similarity) {
    const prompt = `Analyze the connection between these two ideas, focusing on unexpected or creative connections.

Original Idea:
${ideaText}
Category: ${ideaCategory}
Tags: ${ideaTags.join(", ")}

Related Idea:
${relatedIdeaText}
Similarity: ${similarity.toFixed(2)}

CRITICAL REQUIREMENTS:
- Look beyond surface-level similarities to find deeper, more interesting connections
- Focus on unexpected or creative connections that might not be immediately obvious
- Consider how these ideas could enhance or transform each other
- Think about novel applications or combinations

Analyze and identify:

1. Unexpected Connection
   - What is the non-obvious link between these ideas?
   - What hidden relationships exist beyond the similarity score?
   - How do they relate in ways that might not be immediately apparent?
   - What shared principles, approaches, or underlying concepts connect them?

2. Combination Potential
   - How could these ideas be meaningfully combined?
   - What would a merged or hybrid version look like?
   - How could elements from one idea enhance the other?
   - What complementary strengths do they have?

3. New Possibilities
   - What novel applications emerge from this connection?
   - What new ideas or directions does this relationship suggest?
   - How could combining these ideas solve problems neither could solve alone?
   - What unique value would a combination create?

Output format (JSON only, no markdown, no code blocks):
{
  "explanation": "Clear explanation of the unexpected connection between these ideas...",
  "synergy": "Specific description of how these ideas could be combined and what the result would be...",
  "relevance": 0.0-1.0
}

Response:`;
    if (!this.llmService.complete) {
      return {
        explanation: `Similarity: ${similarity.toFixed(2)}`,
        relevance: similarity
      };
    }
    try {
      const response = await this.llmService.complete(prompt, {
        temperature: 0.7,
        n_predict: 500
      });
      const repaired = extractAndRepairJSON(response, false);
      const analysis = JSON.parse(repaired);
      return {
        explanation: analysis.explanation || "",
        synergy: analysis.synergy,
        relevance: analysis.relevance || 0.5
      };
    } catch (error) {
      Logger.warn("Failed to parse LLM analysis:", error);
    }
    return {
      explanation: `Similarity: ${similarity.toFixed(2)}`,
      relevance: similarity
    };
  }
};

// src/services/ExportService.ts
var ExportService = class {
  vault;
  frontmatterParser;
  constructor(vault) {
    this.vault = vault;
    this.frontmatterParser = new FrontmatterParser();
  }
  /**
   * Export all ideas to specified format
   */
  async exportIdeas(format) {
    const allFiles = this.vault.getMarkdownFiles();
    const ideaFiles = allFiles.filter(
      (file) => file.path.startsWith("Ideas/") && !file.path.startsWith("Ideas/Archived/")
    );
    const ideas = [];
    for (const file of ideaFiles) {
      try {
        const content = await this.vault.read(file);
        const parsed = this.frontmatterParser.parse(content);
        const title = file.basename.replace(/^\d{4}-\d{2}-\d{2}-/, "").replace(/-/g, " ");
        ideas.push({
          ...parsed.frontmatter,
          title,
          body: parsed.body,
          filename: file.name,
          path: file.path
        });
      } catch (error) {
        Logger.warn(`Failed to export ${file.path}:`, error);
      }
    }
    const exportData = {
      version: "1.0",
      exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
      totalIdeas: ideas.length,
      ideas
    };
    switch (format) {
      case "json":
        return this.exportJSON(exportData);
      case "csv":
        return this.exportCSV(exportData);
      case "markdown":
        return this.exportMarkdown(exportData);
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }
  exportJSON(data) {
    return JSON.stringify(data, null, 2);
  }
  exportCSV(data) {
    const rows = [];
    rows.push("title,created,category,tags,status,body,related,domains,existence-check");
    for (const idea of data.ideas) {
      const row = [
        this.escapeCSV(idea.title),
        idea.created,
        idea.category || "",
        idea.tags.join(";"),
        idea.status,
        this.escapeCSV(idea.body.replace(/\n/g, " ")),
        idea.related.join(";"),
        idea.domains.join(";"),
        idea["existence-check"].join(";")
      ];
      rows.push(row.join(","));
    }
    return rows.join("\n");
  }
  exportMarkdown(data) {
    const lines = [];
    lines.push(`# Ideas Export`);
    lines.push(`Exported: ${data.exportedAt}`);
    lines.push(`Total Ideas: ${data.totalIdeas}`);
    lines.push("");
    for (const idea of data.ideas) {
      lines.push(`## ${idea.title}`);
      lines.push(`- Created: ${idea.created}`);
      lines.push(`- Category: ${idea.category || "none"}`);
      lines.push(`- Status: ${idea.status}`);
      lines.push(`- Tags: ${idea.tags.join(", ") || "none"}`);
      lines.push("");
      lines.push(idea.body);
      lines.push("");
      lines.push("---");
      lines.push("");
    }
    return lines.join("\n");
  }
  escapeCSV(value) {
    if (value.includes(",") || value.includes('"') || value.includes("\n")) {
      return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
  }
};

// src/services/ImportService.ts
var ImportService = class {
  vault;
  frontmatterParser;
  constructor(vault) {
    this.vault = vault;
    this.frontmatterParser = new FrontmatterParser();
  }
  /**
   * Import ideas from specified format
   */
  async importIdeas(content, format) {
    const result = {
      total: 0,
      imported: 0,
      failed: 0,
      errors: []
    };
    let items = [];
    try {
      switch (format) {
        case "json":
          items = this.parseJSON(content);
          break;
        case "csv":
          items = this.parseCSV(content);
          break;
        case "markdown":
          items = this.parseMarkdown(content);
          break;
        default:
          throw new Error(`Unsupported import format: ${format}`);
      }
    } catch (error) {
      result.errors.push({
        item: "parse",
        error: error instanceof Error ? error.message : "Unknown error"
      });
      return result;
    }
    result.total = items.length;
    for (const item of items) {
      try {
        await this.importIdea(item);
        result.imported++;
      } catch (error) {
        result.failed++;
        result.errors.push({
          item: item.title || "unknown",
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    return result;
  }
  async importIdea(item) {
    const frontmatter = buildFrontmatter({
      text: item.body,
      timestamp: item.created ? new Date(item.created) : /* @__PURE__ */ new Date()
    });
    const merged = {
      ...frontmatter,
      ...item,
      type: "idea",
      status: item.status || "captured",
      created: item.created || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      id: typeof item.id === "number" ? item.id : 0,
      category: item.category || "",
      tags: item.tags || [],
      related: item.related || [],
      domains: item.domains || [],
      "existence-check": item["existence-check"] || []
    };
    const createdDate = item.created ? new Date(item.created) : /* @__PURE__ */ new Date();
    const filename = generateFilename(item.title || item.body, createdDate);
    const yaml = this.frontmatterParser.build(merged, item.body);
    const content = `${yaml}

${item.body}`;
    const path9 = `Ideas/${filename}`;
    await this.vault.create(path9, content);
  }
  parseJSON(content) {
    const data = JSON.parse(content);
    if (data.ideas && Array.isArray(data.ideas)) {
      return data.ideas;
    }
    throw new Error("Invalid JSON format: missing ideas array");
  }
  parseCSV(content) {
    const lines = content.split("\n");
    if (lines.length < 2) {
      throw new Error("Invalid CSV: no data rows");
    }
    lines[0].split(",");
    const items = [];
    for (let i = 1; i < lines.length; i++) {
      const values = this.parseCSVLine(lines[i]);
      const item = {
        title: values[0] || "Untitled",
        created: values[1] || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        category: values[2] || "",
        tags: values[3] ? values[3].split(";").filter((t) => t) : [],
        status: values[4] || "captured",
        body: values[5] || "",
        related: values[6] ? values[6].split(";").filter((r) => r) : [],
        domains: values[7] ? values[7].split(";").filter((d) => d) : [],
        "existence-check": values[8] ? values[8].split(";").filter((e) => e) : []
      };
      items.push(item);
    }
    return items;
  }
  parseCSVLine(line) {
    const values = [];
    let current = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        if (inQuotes && line[i + 1] === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (char === "," && !inQuotes) {
        values.push(current);
        current = "";
      } else {
        current += char;
      }
    }
    values.push(current);
    return values;
  }
  parseMarkdown(content) {
    const items = [];
    const sections = content.split(/^## /m);
    for (let i = 1; i < sections.length; i++) {
      const section = sections[i];
      const lines = section.split("\n");
      const title = lines[0].trim();
      const metadata = {};
      let bodyStart = 0;
      for (let j = 1; j < lines.length; j++) {
        const line = lines[j];
        if (line.match(/^- /)) {
          const match = line.match(/^- (\w+): (.+)$/);
          if (match) {
            metadata[match[1].toLowerCase()] = match[2];
          }
        } else if (line.trim() === "") {
          bodyStart = j + 1;
          break;
        }
      }
      const body = lines.slice(bodyStart).join("\n").trim();
      items.push({
        title,
        body,
        created: metadata.created || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        category: metadata.category || "",
        status: metadata.status || "captured",
        tags: metadata.tags ? metadata.tags.split(",").map((t) => t.trim()) : []
      });
    }
    return items;
  }
};

// src/services/providers/ProviderAdapter.ts
var ProviderAdapter = class {
  provider;
  constructor(provider) {
    this.provider = provider;
  }
  async classify(text) {
    return await this.provider.classify(text);
  }
  isAvailable() {
    return this.provider.isAvailable();
  }
  /**
   * Ensure the LLM service is ready
   * For cloud providers, this just verifies configuration
   */
  async ensureReady() {
    if (!this.provider.isAvailable()) {
      return false;
    }
    return true;
  }
  /**
   * Generic completion method - delegates to provider if available
   * Note: Most cloud providers don't implement this yet, so this will throw for cloud providers
   * Local LLM (LlamaService) supports this
   */
  async complete(prompt, options) {
    if (this.provider.complete && typeof this.provider.complete === "function") {
      return await this.provider.complete(prompt, options);
    }
    throw new Error("Provider does not support generic completions. Use local LLM or a provider with complete() method.");
  }
  /**
   * Get the underlying provider (for logging/debugging)
   */
  getProvider() {
    return this.provider;
  }
};

// src/services/ErrorLogService.ts
var DEFAULT_ERROR_LOG_SETTINGS = {
  enabled: true,
  maxEntries: 50,
  retentionDays: 7
};
var ErrorLogService = class {
  logs = [];
  settings;
  constructor(settings) {
    this.settings = { ...DEFAULT_ERROR_LOG_SETTINGS, ...settings };
  }
  /**
   * Log an error entry
   */
  logError(error, context, userAction, metadata) {
    if (!this.settings.enabled) {
      return;
    }
    const errorMessage = error instanceof Error ? error.message : error;
    const stack = error instanceof Error ? error.stack : void 0;
    const entry = {
      timestamp: /* @__PURE__ */ new Date(),
      error: errorMessage,
      stack,
      context,
      userAction,
      metadata
    };
    this.logs.push(entry);
    if (this.logs.length > this.settings.maxEntries) {
      this.logs = this.logs.slice(-this.settings.maxEntries);
    }
    this.cleanOldEntries();
  }
  /**
   * Get recent error logs
   */
  getRecentLogs(limit2) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.settings.retentionDays);
    const recentLogs = this.logs.filter((log) => log.timestamp >= cutoffDate);
    if (limit2) {
      return recentLogs.slice(-limit2);
    }
    return recentLogs;
  }
  /**
   * Get all error logs
   */
  getAllLogs() {
    return [...this.logs];
  }
  /**
   * Clear all error logs
   */
  clearLogs() {
    this.logs = [];
  }
  /**
   * Sanitize error logs for submission
   */
  sanitizeLogs(logs) {
    const sanitized = logs.map((log) => {
      let sanitizedError = this.sanitizeString(log.error);
      let sanitizedStack = log.stack ? this.sanitizeString(log.stack) : void 0;
      let sanitizedMetadata = log.metadata ? this.sanitizeMetadata(log.metadata) : void 0;
      return {
        ...log,
        error: sanitizedError,
        stack: sanitizedStack,
        metadata: sanitizedMetadata
      };
    });
    return JSON.stringify(sanitized, null, 2);
  }
  /**
   * Format error logs as markdown for GitHub issue
   */
  formatLogsForIssue(logs) {
    if (logs.length === 0) {
      return "No error logs available.";
    }
    const entries = logs.map((log) => {
      let sanitizedError = this.sanitizeString(log.error);
      let sanitizedStack = log.stack ? this.sanitizeString(log.stack) : void 0;
      let entry = `**${log.timestamp.toISOString()}**`;
      if (log.context) {
        entry += ` - Context: ${this.sanitizeString(log.context)}`;
      }
      if (log.userAction) {
        entry += ` - Action: ${this.sanitizeString(log.userAction)}`;
      }
      entry += `
\`\`\`
${sanitizedError}
\`\`\``;
      if (sanitizedStack) {
        const stackLines = sanitizedStack.split("\n");
        const truncatedStack = stackLines.slice(-20).join("\n");
        entry += `

Stack trace (last 20 lines):
\`\`\`
${truncatedStack}
\`\`\``;
      }
      return entry;
    }).join("\n\n---\n\n");
    return `## Error Logs

${entries}`;
  }
  /**
   * Sanitize a string to remove sensitive information
   */
  sanitizeString(str2) {
    str2 = str2.replace(/\/Users\/[^\/]+/g, "[USER_HOME]");
    str2 = str2.replace(/\/home\/[^\/]+/g, "[USER_HOME]");
    str2 = str2.replace(/C:\\Users\\[^\\]+/gi, "[USER_HOME]");
    str2 = str2.replace(/[A-Z]:\\[^:]+/g, "[DRIVE_PATH]");
    str2 = str2.replace(/sk-[a-zA-Z0-9]{20,}/g, "[API_KEY_REDACTED]");
    str2 = str2.replace(/[a-zA-Z0-9]{32,}/g, (match) => {
      if (match.length > 40) {
        return "[API_KEY_REDACTED]";
      }
      return match;
    });
    str2 = str2.replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, "[EMAIL_REDACTED]");
    str2 = str2.replace(/\.obsidian[^"'\s]*/g, "[OBSIDIAN_CONFIG]");
    str2 = str2.replace(/Ideas\/[^"'\s]*/g, "[IDEA_FILE]");
    str2 = str2.replace(/Projects\/[^"'\s]*/g, "[PROJECT_FILE]");
    return str2;
  }
  /**
   * Sanitize metadata object
   */
  sanitizeMetadata(metadata) {
    const sanitized = {};
    for (const [key, value] of Object.entries(metadata)) {
      if (typeof value === "string") {
        sanitized[key] = this.sanitizeString(value);
      } else if (typeof value === "object" && value !== null) {
        sanitized[key] = this.sanitizeMetadata(value);
      } else {
        sanitized[key] = value;
      }
    }
    return sanitized;
  }
  /**
   * Clean old entries beyond retention period
   */
  cleanOldEntries() {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.settings.retentionDays);
    this.logs = this.logs.filter((log) => log.timestamp >= cutoffDate);
  }
  /**
   * Update settings
   */
  updateSettings(settings) {
    this.settings = { ...this.settings, ...settings };
    this.cleanOldEntries();
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
};

// src/utils/fileOrganization.ts
var FileOrganizer = class {
  vault;
  settings;
  ARCHIVE_DIR = "Ideas/Archived/";
  constructor(vault, settings) {
    this.vault = vault;
    this.settings = settings;
  }
  /**
   * Move file to archive directory
   */
  async moveToArchive(file) {
    if (!this.settings.moveArchivedToFolder) {
      return;
    }
    await this.ensureDirectoryExists(this.ARCHIVE_DIR);
    if (file.path.startsWith(this.ARCHIVE_DIR)) {
      return;
    }
    const newPath = `${this.ARCHIVE_DIR}${file.name}`;
    const existingFile = this.vault.getAbstractFileByPath(newPath);
    if (existingFile) {
      const timestamp = Date.now();
      const nameWithoutExt = file.basename;
      const ext = file.extension;
      const newName = `${nameWithoutExt}-${timestamp}.${ext}`;
      await this.vault.rename(file, `${this.ARCHIVE_DIR}${newName}`);
    } else {
      await this.vault.rename(file, newPath);
    }
  }
  /**
   * Move file from archive back to Ideas/ root
   */
  async moveFromArchive(file) {
    if (!file.path.startsWith(this.ARCHIVE_DIR)) {
      return;
    }
    const newPath = `Ideas/${file.name}`;
    const existingFile = this.vault.getAbstractFileByPath(newPath);
    if (existingFile) {
      const timestamp = Date.now();
      const nameWithoutExt = file.basename;
      const ext = file.extension;
      const newName = `${nameWithoutExt}-${timestamp}.${ext}`;
      await this.vault.rename(file, `Ideas/${newName}`);
    } else {
      await this.vault.rename(file, newPath);
    }
  }
  /**
   * Ensure directory exists, create if it doesn't
   */
  async ensureDirectoryExists(path9) {
    const dir = this.vault.getAbstractFileByPath(path9);
    if (!dir) {
      await this.vault.createFolder(path9);
    }
  }
};

// src/commands/base/CommandContext.ts
var CommandContext = class {
  constructor(app, plugin, settings, fileManager, classificationService, duplicateDetector, domainService, webSearchService, nameVariantService, scaffoldService, frontmatterParser, ideaRepository, embeddingService, clusteringService, graphLayoutService, resurfacingService, projectElevationService, tenuousLinkService, exportService, importService, searchService, llmService, errorLogService, fileOrganizer) {
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.fileManager = fileManager;
    this.classificationService = classificationService;
    this.duplicateDetector = duplicateDetector;
    this.domainService = domainService;
    this.webSearchService = webSearchService;
    this.nameVariantService = nameVariantService;
    this.scaffoldService = scaffoldService;
    this.frontmatterParser = frontmatterParser;
    this.ideaRepository = ideaRepository;
    this.embeddingService = embeddingService;
    this.clusteringService = clusteringService;
    this.graphLayoutService = graphLayoutService;
    this.resurfacingService = resurfacingService;
    this.projectElevationService = projectElevationService;
    this.tenuousLinkService = tenuousLinkService;
    this.exportService = exportService;
    this.importService = importService;
    this.searchService = searchService;
    this.llmService = llmService;
    this.errorLogService = errorLogService;
    this.fileOrganizer = fileOrganizer;
  }
};

// src/core/PluginContext.ts
var PluginContext = class {
  constructor(app, plugin, settings, fileManager, classificationService, duplicateDetector, domainService, webSearchService, nameVariantService, scaffoldService, frontmatterParser, ideaRepository, embeddingService, clusteringService, graphLayoutService, resurfacingService, projectElevationService, tenuousLinkService, exportService, importService, searchService, llmService, errorLogService, fileOrganizer) {
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.fileManager = fileManager;
    this.classificationService = classificationService;
    this.duplicateDetector = duplicateDetector;
    this.domainService = domainService;
    this.webSearchService = webSearchService;
    this.nameVariantService = nameVariantService;
    this.scaffoldService = scaffoldService;
    this.frontmatterParser = frontmatterParser;
    this.ideaRepository = ideaRepository;
    this.embeddingService = embeddingService;
    this.clusteringService = clusteringService;
    this.graphLayoutService = graphLayoutService;
    this.resurfacingService = resurfacingService;
    this.projectElevationService = projectElevationService;
    this.tenuousLinkService = tenuousLinkService;
    this.exportService = exportService;
    this.importService = importService;
    this.searchService = searchService;
    this.llmService = llmService;
    this.errorLogService = errorLogService;
    this.fileOrganizer = fileOrganizer;
    this.commandContext = new CommandContext(
      app,
      plugin,
      settings,
      fileManager,
      classificationService,
      duplicateDetector,
      domainService,
      webSearchService,
      nameVariantService,
      scaffoldService,
      frontmatterParser,
      ideaRepository,
      embeddingService,
      clusteringService,
      graphLayoutService,
      resurfacingService,
      projectElevationService,
      tenuousLinkService,
      exportService,
      importService,
      searchService,
      llmService,
      errorLogService,
      fileOrganizer
    );
  }
  commandContext;
};

// src/core/ServiceInitializer.ts
var ServiceInitializer = class {
  /**
   * Initialize all services and return plugin context
   */
  static async initialize(app, plugin, settings) {
    const fileManager = new FileManager(app.vault);
    const fileOrganizer = new FileOrganizer(app.vault, settings);
    const errorLogService = new ErrorLogService({
      enabled: settings.errorLoggingEnabled,
      maxEntries: settings.errorLogMaxEntries,
      retentionDays: settings.errorLogRetentionDays
    });
    const { localLLMService, llmService } = await this.initializeLLMServices(
      app,
      plugin,
      settings
    );
    const searchService = new SearchService(app.vault);
    const classificationService = new ClassificationService(llmService, searchService);
    const duplicateDetector = new DuplicateDetector(searchService);
    const prospectrService = new ProspectrService(
      settings.prospectrUrl,
      settings.domainCheckTimeout
    );
    const domainService = new DomainService(prospectrService);
    const webSearchService = new WebSearchService(settings);
    const nameVariantService = new NameVariantService(
      llmService,
      settings,
      async () => {
        const data = await plugin.loadData();
        return data?.variantCache || {};
      },
      async (cacheData) => {
        const data = await plugin.loadData();
        await plugin.saveData({
          ...data,
          variantCache: cacheData
        });
      }
    );
    const scaffoldService = new ScaffoldService(app.vault);
    const frontmatterParser = new FrontmatterParser();
    const ideaRepository = new IdeaRepository(app.vault, frontmatterParser);
    const embeddingService = new EmbeddingService();
    const clusteringService = new ClusteringService(
      embeddingService,
      settings.clusteringSimilarityThreshold || 0.3
    );
    const graphLayoutService = new GraphLayoutService();
    const resurfacingService = new ResurfacingService(
      ideaRepository,
      settings,
      app.vault
    );
    const projectElevationService = new ProjectElevationService(
      app.vault,
      frontmatterParser,
      settings
    );
    const tenuousLinkService = new TenuousLinkServiceImpl(
      app.vault,
      embeddingService,
      llmService
    );
    const exportService = new ExportService(app.vault);
    const importService = new ImportService(app.vault);
    const context = new PluginContext(
      app,
      plugin,
      settings,
      fileManager,
      classificationService,
      duplicateDetector,
      domainService,
      webSearchService,
      nameVariantService,
      scaffoldService,
      frontmatterParser,
      ideaRepository,
      embeddingService,
      clusteringService,
      graphLayoutService,
      resurfacingService,
      projectElevationService,
      tenuousLinkService,
      exportService,
      importService,
      searchService,
      llmService,
      errorLogService,
      fileOrganizer
    );
    return { context, localLLMService };
  }
  /**
   * Initialize LLM services (local and cloud)
   */
  static async initializeLLMServices(app, plugin, settings) {
    const vaultBasePath = app.vault.adapter.basePath || app.vault.configDir;
    const configDir = path7.isAbsolute(app.vault.configDir) ? app.vault.configDir : path7.join(vaultBasePath, app.vault.configDir);
    const pluginDir = path7.resolve(path7.join(configDir, "plugins", plugin.manifest.id));
    Logger.debug("Plugin directory:", pluginDir);
    const localLLMService = LlamaService.getInstance(settings, pluginDir);
    let cloudLLM = null;
    if (settings.cloudProvider !== "none" && settings.cloudProvider !== "custom" && settings.cloudProvider !== "custom-model") {
      const apiKey = settings.cloudApiKeys && settings.cloudProvider in settings.cloudApiKeys ? (settings.cloudApiKeys[settings.cloudProvider] || "").trim() : "";
      if (apiKey.length > 0) {
        try {
          const provider = ProviderFactory.createProvider(
            settings.cloudProvider,
            apiKey,
            {
              openRouterModel: settings.openRouterModel,
              customEndpointUrl: settings.customEndpointUrl
            }
          );
          cloudLLM = new ProviderAdapter(provider);
          Logger.info("Cloud AI provider initialized:", provider.name);
        } catch (error) {
          Logger.warn("Failed to initialize cloud provider:", error);
          new import_obsidian25.Notice("Failed to initialize cloud AI provider. Using local AI only.");
        }
      }
    } else if (settings.cloudProvider === "custom-model") {
      if (settings.customModelProvider && settings.customModel) {
        const apiKey = settings.cloudApiKeys && settings.customModelProvider in settings.cloudApiKeys ? (settings.cloudApiKeys[settings.customModelProvider] || "").trim() : "";
        if (apiKey.length > 0) {
          try {
            const provider = ProviderFactory.createProvider(
              "custom-model",
              apiKey,
              {
                customModelProvider: settings.customModelProvider,
                customModel: settings.customModel
              }
            );
            cloudLLM = new ProviderAdapter(provider);
            Logger.info("Custom model provider initialized:", provider.name, settings.customModel);
          } catch (error) {
            Logger.warn("Failed to initialize custom model provider:", error);
            new import_obsidian25.Notice("Failed to initialize custom model provider. Using local AI only.");
          }
        }
      }
    } else if (settings.cloudProvider === "custom") {
      if (settings.customEndpointUrl && settings.customEndpointUrl.trim().length > 0) {
        try {
          const provider = ProviderFactory.createProvider(
            "custom",
            "",
            {
              customEndpointUrl: settings.customEndpointUrl
            }
          );
          cloudLLM = new ProviderAdapter(provider);
          Logger.info("Cloud AI provider initialized:", provider.name);
        } catch (error) {
          Logger.warn("Failed to initialize custom endpoint:", error);
          new import_obsidian25.Notice("Failed to initialize custom endpoint. Using local AI only.");
        }
      }
    }
    const llmService = new HybridLLM(
      localLLMService,
      cloudLLM,
      settings.preferCloud
    );
    if (settings.preloadOnStartup && llmService.isAvailable()) {
      llmService.ensureReady?.().then((ready) => {
        if (!ready) {
          Logger.debug("LLM not ready for preload (paths not configured or model not downloaded)");
        }
      }).catch((error) => {
        Logger.warn("Failed to preload LLM on startup:", error);
      });
    }
    return { localLLMService, llmService };
  }
};

// src/commands/CommandRegistry.ts
var import_obsidian66 = require("obsidian");

// src/commands/base/BaseCommand.ts
var import_obsidian26 = require("obsidian");

// src/utils/errors.ts
var UserFacingError = class extends Error {
  userMessage;
  constructor(message, userMessage) {
    super(message);
    this.name = "UserFacingError";
    this.userMessage = userMessage;
  }
};

// src/commands/base/BaseCommand.ts
var BaseCommand = class {
  constructor(context) {
    this.context = context;
  }
  /**
   * Handle errors consistently across all commands
   */
  handleError(error, context, userAction) {
    Logger.error(`Failed to ${context || "execute command"}:`, error);
    if (this.context.errorLogService) {
      const errorObj = error instanceof Error ? error : new Error(String(error));
      this.context.errorLogService.logError(errorObj, context, userAction);
    }
    if (error instanceof UserFacingError) {
      new import_obsidian26.Notice(error.userMessage);
    } else {
      const message = context ? `Failed to ${context}. Please try again or check console for details.` : "Failed to execute command. Please try again or check console for details.";
      new import_obsidian26.Notice(message);
    }
  }
  /**
   * Show a notice to the user
   */
  showNotice(message) {
    new import_obsidian26.Notice(message);
  }
  /**
   * Log debug message
   */
  debug(message, ...args) {
    Logger.debug(message, ...args);
  }
  /**
   * Log info message
   */
  info(message, ...args) {
    Logger.info(message, ...args);
  }
  /**
   * Log warning message
   */
  warn(message, ...args) {
    Logger.warn(message, ...args);
  }
};

// src/commands/capture/CaptureCommand.ts
var CaptureCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      new CaptureModal(
        this.context.app,
        this.context.fileManager,
        this.context.classificationService,
        this.context.duplicateDetector,
        this.context.settings,
        this.context.domainService,
        this.context.webSearchService,
        this.context.nameVariantService,
        this.context.llmService
      ).open();
    } catch (error) {
      this.handleError(error, "open capture modal", "capture-idea");
    }
  }
};

// src/commands/validation/ExistenceSearchCommand.ts
var import_obsidian28 = require("obsidian");

// src/commands/base/IdeaFileCommand.ts
var import_obsidian27 = require("obsidian");
var IdeaFileCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  /**
   * Execute the command with file validation
   */
  async execute() {
    try {
      const file = await this.getActiveIdeaFile();
      if (!file) {
        return;
      }
      const { frontmatter, body, content } = await this.readIdeaContent(file);
      const ideaText = body.trim();
      if (!ideaText || ideaText.length === 0) {
        new import_obsidian27.Notice("No idea text found in file.");
        return;
      }
      await this.executeWithFile(file, { frontmatter, body, content, ideaText });
    } catch (error) {
      this.handleError(error, this.getCommandName());
    }
  }
  /**
   * Get active idea file or show error
   */
  async getActiveIdeaFile() {
    const file = this.context.app.workspace.getActiveFile();
    if (!file) {
      this.debug("No active file found");
      new import_obsidian27.Notice("No active note. Please open an idea file.");
      return null;
    }
    if (!file.path.startsWith("Ideas/")) {
      new import_obsidian27.Notice("This command works best with idea files in the Ideas/ directory.");
    }
    return file;
  }
  /**
   * Read idea content and parse frontmatter
   */
  async readIdeaContent(file) {
    const content = await this.context.app.vault.read(file);
    const parsed = this.context.frontmatterParser.parse(content);
    return {
      frontmatter: parsed.frontmatter,
      body: parsed.body,
      content
    };
  }
  /**
   * Update idea frontmatter with new values
   */
  async updateIdeaFrontmatter(file, updates) {
    const content = await this.context.app.vault.read(file);
    const parsed = this.context.frontmatterParser.parse(content);
    const updated = { ...parsed.frontmatter, ...updates };
    const newContent = this.context.frontmatterParser.build(updated, parsed.body);
    await this.context.app.vault.modify(file, newContent);
  }
  /**
   * Check service availability and show notice if unavailable
   */
  checkServiceAvailability(service, serviceName) {
    if (!service.isAvailable()) {
      new import_obsidian27.Notice(`${serviceName} is not configured. Please set it up in settings.`);
      return false;
    }
    return true;
  }
  /**
   * Check if LLM service is available
   */
  checkLLMAvailability() {
    if (!this.context.llmService.isAvailable()) {
      this.debug("LLM service not available");
      new import_obsidian27.Notice("AI service is not configured. Please set up AI in settings.");
      return false;
    }
    return true;
  }
};

// src/commands/validation/ExistenceSearchCommand.ts
var ExistenceSearchCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "search existence";
  }
  async executeWithFile(file, content) {
    if (!this.checkServiceAvailability(this.context.webSearchService, "Web search")) {
      return;
    }
    const category = content.frontmatter.category || "";
    new import_obsidian28.Notice("Searching for similar ideas...");
    const results = await this.context.webSearchService.search(content.ideaText, category);
    if (results.length === 0) {
      new import_obsidian28.Notice("No similar ideas found.");
      return;
    }
    const summaries = results.map(
      (r) => `${r.title}: ${r.snippet} (${r.url})`
    );
    await this.updateIdeaFrontmatter(file, { "existence-check": summaries });
    new import_obsidian28.Notice(`Search complete: Found ${results.length} similar idea${results.length > 1 ? "s" : ""}`);
  }
};

// src/commands/validation/DuplicateCheckCommand.ts
var import_obsidian30 = require("obsidian");

// src/views/DuplicateResultsModal.ts
var import_obsidian29 = require("obsidian");
var DuplicateResultsModal = class extends import_obsidian29.Modal {
  duplicates;
  onLink;
  selected = /* @__PURE__ */ new Set();
  constructor(app, duplicates, onLink) {
    super(app);
    this.duplicates = duplicates;
    this.onLink = onLink;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Duplicate Ideas Found" });
    const description = contentEl.createEl("p", {
      text: `Found ${this.duplicates.length} potential duplicate${this.duplicates.length > 1 ? "s" : ""}. Select which ones to link in frontmatter:`
    });
    description.addClass("ideatr-modal-description");
    const listContainer = contentEl.createDiv("ideatr-duplicate-list");
    this.duplicates.forEach((duplicate) => {
      const item = listContainer.createDiv("ideatr-duplicate-item");
      const checkbox = item.createEl("input", {
        type: "checkbox",
        attr: { checked: "true" }
        // All selected by default
      });
      this.selected.add(duplicate.path);
      checkbox.addEventListener("change", (e) => {
        const target = e.target;
        if (target.checked) {
          this.selected.add(duplicate.path);
        } else {
          this.selected.delete(duplicate.path);
        }
      });
      const label = item.createDiv("ideatr-duplicate-label");
      label.createEl("strong", { text: duplicate.title });
      label.createEl("div", {
        text: duplicate.path,
        cls: "ideatr-duplicate-path"
      });
      if (duplicate.similarity !== void 0) {
        label.createEl("div", {
          text: `Similarity: ${(duplicate.similarity * 100).toFixed(0)}%`,
          cls: "ideatr-duplicate-similarity"
        });
      }
    });
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    const linkButton = buttonContainer.createEl("button", {
      text: "Link Selected",
      cls: "mod-cta"
    });
    linkButton.addEventListener("click", () => {
      const selected = this.duplicates.filter((d) => this.selected.has(d.path));
      if (this.onLink) {
        this.onLink(selected);
      }
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/validation/DuplicateCheckCommand.ts
var DuplicateCheckCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "check duplicates";
  }
  async executeWithFile(file, content) {
    new import_obsidian30.Notice("Checking for duplicates...");
    const result = await this.context.duplicateDetector.checkDuplicate(content.ideaText);
    if (!result.isDuplicate || result.duplicates.length === 0) {
      new import_obsidian30.Notice("No duplicates found.");
      return;
    }
    new DuplicateResultsModal(
      this.context.app,
      result.duplicates,
      async (selected) => {
        const relatedPaths = selected.map((d) => d.path);
        await this.updateIdeaFrontmatter(file, { related: relatedPaths });
        new import_obsidian30.Notice(`Linked ${selected.length} duplicate${selected.length > 1 ? "s" : ""} in frontmatter.`);
      }
    ).open();
  }
};

// src/commands/validation/RelatedNotesCommand.ts
var import_obsidian32 = require("obsidian");

// src/views/RelatedNotesModal.ts
var import_obsidian31 = require("obsidian");
var RelatedNotesModal = class extends import_obsidian31.Modal {
  relatedNotes;
  existingRelated;
  onSelect;
  selected = /* @__PURE__ */ new Set();
  constructor(app, relatedNotes, existingRelated, onSelect) {
    super(app);
    this.relatedNotes = relatedNotes;
    this.existingRelated = existingRelated;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Related Notes" });
    const description = contentEl.createEl("p", {
      text: `Found ${this.relatedNotes.length} related note${this.relatedNotes.length > 1 ? "s" : ""}. Select which ones to link in frontmatter:`
    });
    description.addClass("ideatr-modal-description");
    const listContainer = contentEl.createDiv("ideatr-related-list");
    this.relatedNotes.forEach((note) => {
      const item = listContainer.createDiv("ideatr-related-item");
      const checkbox = item.createEl("input", {
        type: "checkbox",
        attr: {
          checked: this.existingRelated.includes(note.path) ? "true" : null
        }
      });
      if (this.existingRelated.includes(note.path)) {
        this.selected.add(note.path);
      }
      checkbox.addEventListener("change", (e) => {
        const target = e.target;
        if (target.checked) {
          this.selected.add(note.path);
        } else {
          this.selected.delete(note.path);
        }
      });
      const label = item.createDiv("ideatr-related-label");
      label.createEl("strong", { text: note.title });
      label.createEl("div", {
        text: note.path,
        cls: "ideatr-related-path"
      });
      if (note.similarity !== void 0) {
        label.createEl("div", {
          text: `Similarity: ${(note.similarity * 100).toFixed(0)}%`,
          cls: "ideatr-related-similarity"
        });
      }
      if (this.existingRelated.includes(note.path)) {
        label.createEl("div", {
          text: "(Already linked)",
          cls: "ideatr-related-existing"
        });
      }
    });
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    const linkButton = buttonContainer.createEl("button", {
      text: "Link Selected",
      cls: "mod-cta"
    });
    linkButton.addEventListener("click", () => {
      const selected = this.relatedNotes.filter((n) => this.selected.has(n.path));
      if (this.onSelect) {
        this.onSelect(selected);
      }
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/validation/RelatedNotesCommand.ts
var RelatedNotesCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "find related notes";
  }
  async executeWithFile(file, content) {
    new import_obsidian32.Notice("Finding related notes...");
    const relatedNotes = await this.context.searchService.findRelatedNotes(content.ideaText, 10);
    if (relatedNotes.length === 0) {
      new import_obsidian32.Notice("No related notes found.");
      return;
    }
    new RelatedNotesModal(
      this.context.app,
      relatedNotes,
      content.frontmatter.related || [],
      async (selected) => {
        const relatedPaths = selected.map((n) => n.path);
        await this.updateIdeaFrontmatter(file, { related: relatedPaths });
        new import_obsidian32.Notice(`Linked ${selected.length} related note${selected.length > 1 ? "s" : ""} in frontmatter.`);
      }
    ).open();
  }
};

// src/commands/validation/QuickValidateCommand.ts
var import_obsidian33 = require("obsidian");
var QuickValidateCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "run validations";
  }
  async executeWithFile(file, content) {
    new import_obsidian33.Notice("Running all validations...");
    const results = await Promise.allSettled([
      this.context.domainService.checkDomains(content.ideaText).catch((e) => {
        console.error("Domain check failed:", e);
        return [];
      }),
      this.context.webSearchService.isAvailable() ? this.context.webSearchService.search(content.ideaText, content.frontmatter.category).catch((e) => {
        console.error("Web search failed:", e);
        return [];
      }) : Promise.resolve([]),
      this.context.duplicateDetector.checkDuplicate(content.ideaText).catch((e) => {
        console.error("Duplicate check failed:", e);
        return { isDuplicate: false, duplicates: [], threshold: 0.75 };
      })
    ]);
    const domainResults = results[0].status === "fulfilled" ? results[0].value : [];
    const searchResults = results[1].status === "fulfilled" ? results[1].value : [];
    const duplicateResult = results[2].status === "fulfilled" ? results[2].value : { isDuplicate: false, duplicates: [], threshold: 0.75 };
    const updates = {};
    if (domainResults.length > 0) {
      const domainStrings = domainResults.map(
        (r) => r.available ? `${r.domain}: available` : `${r.domain}: unavailable${r.error ? ` (${r.error})` : ""}`
      );
      updates.domains = domainStrings;
    }
    if (searchResults.length > 0) {
      const summaries = searchResults.map(
        (r) => `${r.title}: ${r.snippet} (${r.url})`
      );
      updates["existence-check"] = summaries;
    }
    if (duplicateResult.isDuplicate && duplicateResult.duplicates.length > 0) {
      new import_obsidian33.Notice(`Found ${duplicateResult.duplicates.length} potential duplicate${duplicateResult.duplicates.length > 1 ? "s" : ""}. Use "check-duplicates" command to review.`);
    }
    if (Object.keys(updates).length > 0) {
      await this.updateIdeaFrontmatter(file, updates);
    }
    const summary = [
      `Domains: ${domainResults.length} checked`,
      `Search: ${searchResults.length} found`,
      `Duplicates: ${duplicateResult.isDuplicate ? duplicateResult.duplicates.length + " found" : "none"}`
    ].join(", ");
    new import_obsidian33.Notice(`Validation complete: ${summary}`);
  }
};

// src/commands/transformation/NameVariantCommand.ts
var import_obsidian34 = require("obsidian");
var NameVariantCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "generate name variants";
  }
  async executeWithFile(file, content) {
    new import_obsidian34.Notice("Generating name variants...");
    const variants = await this.context.nameVariantService.generateVariants(content.ideaText);
    if (variants.length === 0) {
      new import_obsidian34.Notice("No name variants could be generated.");
      return;
    }
    const formatted = this.context.nameVariantService.formatVariantsForMarkdown(variants);
    await this.context.fileManager.appendToFileBody(file, "Name Variants", formatted);
    new import_obsidian34.Notice(`Name variants generated and added to note.`);
  }
};

// src/commands/transformation/ScaffoldCommand.ts
var import_obsidian35 = require("obsidian");
var ScaffoldCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "generate scaffold";
  }
  async executeWithFile(file, content) {
    let category = "";
    const frontmatterMatch = content.content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      const categoryMatch = frontmatterMatch[1].match(/^category:\s*(.+)$/m);
      if (categoryMatch) {
        const categoryValue = categoryMatch[1].trim();
        category = categoryValue;
      }
    }
    new import_obsidian35.Notice("Generating scaffold...");
    const scaffold = await this.context.scaffoldService.generateScaffold(content.ideaText, category);
    const action = this.context.settings.scaffoldDefaultAction || "append";
    if (action === "append") {
      await this.context.fileManager.appendToFileBody(file, "Scaffold", scaffold);
      new import_obsidian35.Notice("Scaffold generated and added to note.");
    } else {
      await this.context.fileManager.appendToFileBody(file, "Scaffold", scaffold);
      new import_obsidian35.Notice("Scaffold generated and added to note.");
    }
  }
};

// src/commands/transformation/MutationCommand.ts
var import_obsidian38 = require("obsidian");

// src/views/MutationSelectionModal.ts
var import_obsidian36 = require("obsidian");
var MutationSelectionModal = class extends import_obsidian36.Modal {
  mutations;
  onSelect;
  selected = /* @__PURE__ */ new Set();
  constructor(app, mutations, onSelect) {
    super(app);
    this.mutations = mutations;
    this.onSelect = onSelect;
    mutations.forEach((_, index) => this.selected.add(index));
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Idea Mutations" });
    const description = contentEl.createEl("p", {
      text: `Generated ${this.mutations.length} mutation${this.mutations.length > 1 ? "s" : ""}. Select which ones to save:`
    });
    description.addClass("ideatr-modal-description");
    const listContainer = contentEl.createDiv("ideatr-mutation-list");
    this.mutations.forEach((mutation, index) => {
      const item = listContainer.createDiv("ideatr-mutation-item");
      const checkbox = item.createEl("input", {
        type: "checkbox",
        attr: { checked: "true" }
      });
      checkbox.addEventListener("change", (e) => {
        const target = e.target;
        if (target.checked) {
          this.selected.add(index);
        } else {
          this.selected.delete(index);
        }
      });
      const label = item.createDiv("ideatr-mutation-label");
      label.createEl("strong", { text: mutation.title });
      label.createEl("div", {
        text: mutation.description,
        cls: "ideatr-mutation-description"
      });
      if (mutation.differences.length > 0) {
        const diffList = label.createEl("ul", { cls: "ideatr-mutation-differences" });
        mutation.differences.forEach((diff) => {
          diffList.createEl("li", { text: diff });
        });
      }
    });
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    const saveButton = buttonContainer.createEl("button", {
      text: "Save as New Ideas",
      cls: "mod-cta"
    });
    saveButton.addEventListener("click", () => {
      const selected = this.mutations.filter((_, index) => this.selected.has(index));
      if (this.onSelect) {
        this.onSelect(selected, "save");
      }
      this.close();
    });
    const appendButton = buttonContainer.createEl("button", {
      text: "Append to Current Note"
    });
    appendButton.addEventListener("click", () => {
      const selected = this.mutations.filter((_, index) => this.selected.has(index));
      if (this.onSelect) {
        this.onSelect(selected, "append");
      }
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/transformation/MutationCommand.ts
var MutationCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "generate mutations";
  }
  async executeWithFile(file, content) {
    if (!this.checkLLMAvailability()) {
      return;
    }
    new import_obsidian38.Notice("Generating mutations...");
    if (!this.context.llmService.generateMutations) {
      new import_obsidian38.Notice("Mutation generation is not supported by the current AI provider.");
      return;
    }
    let mutations;
    try {
      mutations = await this.context.llmService.generateMutations(content.ideaText, {
        category: content.frontmatter.category,
        tags: content.frontmatter.tags,
        count: 8
      });
    } catch (error) {
      const { MutationErrorModal: MutationErrorModal2 } = await Promise.resolve().then(() => (init_MutationErrorModal(), MutationErrorModal_exports));
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      const errorWithDetails = error;
      const responseLength = errorWithDetails.responseLength ?? (errorMessage.includes("empty response") ? 0 : void 0);
      const responsePreview = errorWithDetails.responsePreview;
      new MutationErrorModal2(
        this.context.app,
        {
          message: errorMessage,
          responseLength,
          responsePreview: responsePreview?.substring(0, 500),
          canRetry: true
        },
        async () => {
          await this.execute();
        }
      ).open();
      return;
    }
    if (mutations.length === 0) {
      new import_obsidian38.Notice("No mutations could be generated.");
      return;
    }
    new MutationSelectionModal(
      this.context.app,
      mutations,
      async (selected, action) => {
        if (action === "save") {
          for (const mutation of selected) {
            const newContent = `---
type: idea
status: captured
created: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}
id: 0
category: ${content.frontmatter.category || ""}
tags: ${JSON.stringify(content.frontmatter.tags || [])}
related: ${JSON.stringify([file.path])}
domains: []
existence-check: []
---

# ${mutation.title}

${mutation.description}

## Key Differences
${mutation.differences.map((d) => `- ${d}`).join("\n")}
`;
            const newPath = `Ideas/${generateFilename(mutation.title, /* @__PURE__ */ new Date())}`;
            await this.context.app.vault.create(newPath, newContent);
          }
          new import_obsidian38.Notice(`Created ${selected.length} new idea${selected.length > 1 ? "s" : ""} from mutations.`);
        } else {
          const mutationsText = selected.map(
            (m) => `## ${m.title}

${m.description}

**Key Differences:**
${m.differences.map((d) => `- ${d}`).join("\n")}`
          ).join("\n\n---\n\n");
          await this.context.fileManager.appendToFileBody(file, "Mutations", mutationsText);
          new import_obsidian38.Notice(`Added ${selected.length} mutation${selected.length > 1 ? "s" : ""} to note.`);
        }
      }
    ).open();
  }
};

// src/commands/transformation/ExpandCommand.ts
var import_obsidian40 = require("obsidian");

// src/views/ExpansionPreviewModal.ts
var import_obsidian39 = require("obsidian");
var ExpansionPreviewModal = class extends import_obsidian39.Modal {
  expansion;
  onAction;
  constructor(app, expansion, onAction) {
    super(app);
    this.expansion = expansion;
    this.onAction = onAction;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Expanded Idea Preview" });
    const description = contentEl.createEl("p", {
      text: "Review the expanded idea content below. Choose to append or replace the current content:"
    });
    description.addClass("ideatr-modal-description");
    const previewContainer = contentEl.createDiv("ideatr-expansion-preview");
    previewContainer.style.maxHeight = "400px";
    previewContainer.style.overflowY = "auto";
    previewContainer.style.padding = "10px";
    previewContainer.style.border = "1px solid var(--background-modifier-border)";
    previewContainer.style.borderRadius = "4px";
    const preview = previewContainer.createDiv("ideatr-expansion-content");
    preview.innerHTML = this.expansion.expandedText.replace(/\n/g, "<br>");
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    const appendButton = buttonContainer.createEl("button", {
      text: "Append to Note",
      cls: "mod-cta"
    });
    appendButton.addEventListener("click", () => {
      if (this.onAction) {
        this.onAction("append");
      }
      this.close();
    });
    const replaceButton = buttonContainer.createEl("button", {
      text: "Replace Content"
    });
    replaceButton.addEventListener("click", () => {
      if (this.onAction) {
        this.onAction("replace");
      }
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/transformation/ExpandCommand.ts
var ExpandCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "expand idea";
  }
  async executeWithFile(file, content) {
    if (!this.checkLLMAvailability()) {
      return;
    }
    new import_obsidian40.Notice("Expanding idea...");
    if (!this.context.llmService.expandIdea) {
      this.debug("LLM service does not support expandIdea");
      new import_obsidian40.Notice("Idea expansion is not supported by the current AI provider.");
      return;
    }
    const expansion = await this.context.llmService.expandIdea(content.ideaText, {
      category: content.frontmatter.category,
      tags: content.frontmatter.tags,
      detailLevel: "detailed"
    });
    new ExpansionPreviewModal(
      this.context.app,
      expansion,
      async (action) => {
        if (action === "append") {
          await this.context.fileManager.appendToFileBody(file, "Expanded Idea", expansion.expandedText);
          new import_obsidian40.Notice("Expanded content added to note.");
        } else if (action === "replace") {
          const parsed = this.context.frontmatterParser.parse(content.content);
          const newContent = this.context.frontmatterParser.build(parsed.frontmatter, expansion.expandedText);
          await this.context.app.vault.modify(file, newContent);
          new import_obsidian40.Notice("Idea content replaced with expanded version.");
        }
      }
    ).open();
  }
};

// src/commands/transformation/ReorganizeCommand.ts
var import_obsidian42 = require("obsidian");

// src/views/ReorganizationPreviewModal.ts
var import_obsidian41 = require("obsidian");
var ReorganizationPreviewModal = class extends import_obsidian41.Modal {
  originalText;
  reorganization;
  onAction;
  constructor(app, originalText, reorganization, onAction) {
    super(app);
    this.originalText = originalText;
    this.reorganization = reorganization;
    this.onAction = onAction;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Reorganized Idea Preview" });
    const description = contentEl.createEl("p", {
      text: "Review the reorganized idea below. A backup file has been created. Choose to accept or reject the changes:"
    });
    description.addClass("ideatr-modal-description");
    const changesSummary = contentEl.createDiv("ideatr-reorganization-changes");
    if (this.reorganization.changes.sectionsAdded.length > 0) {
      changesSummary.createEl("div", {
        text: `Sections added: ${this.reorganization.changes.sectionsAdded.join(", ")}`,
        cls: "ideatr-change-added"
      });
    }
    if (this.reorganization.changes.sectionsRemoved.length > 0) {
      changesSummary.createEl("div", {
        text: `Sections removed: ${this.reorganization.changes.sectionsRemoved.join(", ")}`,
        cls: "ideatr-change-removed"
      });
    }
    if (this.reorganization.changes.sectionsReorganized.length > 0) {
      changesSummary.createEl("div", {
        text: `Sections reorganized: ${this.reorganization.changes.sectionsReorganized.join(", ")}`,
        cls: "ideatr-change-reorganized"
      });
    }
    const tabContainer = contentEl.createDiv("ideatr-reorganization-tabs");
    const beforeTab = tabContainer.createEl("button", {
      text: "Before",
      cls: "ideatr-tab-button"
    });
    const afterTab = tabContainer.createEl("button", {
      text: "After",
      cls: "ideatr-tab-button mod-cta"
    });
    const previewContainer = contentEl.createDiv("ideatr-reorganization-preview");
    previewContainer.style.maxHeight = "400px";
    previewContainer.style.overflowY = "auto";
    previewContainer.style.padding = "10px";
    previewContainer.style.border = "1px solid var(--background-modifier-border)";
    previewContainer.style.borderRadius = "4px";
    previewContainer.style.marginTop = "10px";
    let currentView = "after";
    const updateView = () => {
      previewContainer.empty();
      const text = currentView === "before" ? this.originalText : this.reorganization.reorganizedText;
      const preview = previewContainer.createDiv("ideatr-reorganization-content");
      preview.innerHTML = text.replace(/\n/g, "<br>");
      beforeTab.classList.toggle("mod-cta", currentView === "before");
      afterTab.classList.toggle("mod-cta", currentView === "after");
    };
    beforeTab.addEventListener("click", () => {
      currentView = "before";
      updateView();
    });
    afterTab.addEventListener("click", () => {
      currentView = "after";
      updateView();
    });
    updateView();
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    const acceptButton = buttonContainer.createEl("button", {
      text: "Accept Changes",
      cls: "mod-cta"
    });
    acceptButton.addEventListener("click", () => {
      if (this.onAction) {
        this.onAction("accept");
      }
      this.close();
    });
    const rejectButton = buttonContainer.createEl("button", {
      text: "Reject"
    });
    rejectButton.addEventListener("click", () => {
      if (this.onAction) {
        this.onAction("reject");
      }
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/transformation/ReorganizeCommand.ts
var ReorganizeCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "reorganize idea";
  }
  async executeWithFile(file, content) {
    if (!this.checkLLMAvailability()) {
      return;
    }
    new import_obsidian42.Notice("Reorganizing idea...");
    if (!this.context.llmService.reorganizeIdea) {
      new import_obsidian42.Notice("Idea reorganization is not supported by the current AI provider.");
      return;
    }
    const backupPath = file.path.replace(/\.md$/, ".backup.md");
    try {
      await this.context.app.vault.create(backupPath, content.content);
    } catch (error) {
      Logger.warn("Failed to create backup file:", error);
    }
    const reorganization = await this.context.llmService.reorganizeIdea(content.ideaText, {
      category: content.frontmatter.category,
      tags: content.frontmatter.tags
    });
    new ReorganizationPreviewModal(
      this.context.app,
      content.ideaText,
      reorganization,
      async (action) => {
        if (action === "accept") {
          const parsed = this.context.frontmatterParser.parse(content.content);
          const newContent = this.context.frontmatterParser.build(parsed.frontmatter, reorganization.reorganizedText);
          await this.context.app.vault.modify(file, newContent);
          new import_obsidian42.Notice("Idea reorganized successfully.");
        } else if (action === "reject") {
          new import_obsidian42.Notice("Reorganization cancelled.");
        }
      }
    ).open();
  }
};

// src/commands/transformation/GuidedIdeationCommand.ts
var import_obsidian44 = require("obsidian");

// src/services/GuidedIdeationService.ts
var GuidedIdeationService = class {
  llmService;
  constructor(llmService) {
    this.llmService = llmService;
  }
  /**
   * Analyze user prompt to determine transformation intent
   */
  async analyzeIntent(userPrompt, noteContent, frontmatter) {
    const prompt = this.buildIntentAnalysisPrompt(userPrompt, noteContent, frontmatter);
    try {
      if (!this.llmService.complete) {
        throw new Error("LLM service does not support completion");
      }
      const response = await this.llmService.complete(prompt, {
        temperature: 0.3,
        // Lower temperature for more consistent classification
        n_predict: 1e3,
        stop: ["}"]
      });
      const plan = this.parseIntentResponse(response);
      return plan;
    } catch (error) {
      Logger.warn("Intent analysis failed:", error);
      return {
        intent: "custom",
        operations: [{
          type: "transform",
          target: "body",
          action: userPrompt
        }],
        description: `Apply transformation: ${userPrompt}`,
        requiresBodyModification: true
      };
    }
  }
  /**
   * Execute transformation based on plan
   */
  async executeTransformation(userPrompt, transformationPlan, noteContent, frontmatter, _body, currentFilename) {
    const prompt = this.buildExecutionPrompt(
      userPrompt,
      transformationPlan,
      noteContent,
      frontmatter,
      currentFilename
    );
    try {
      if (!this.llmService.complete) {
        throw new Error("LLM service does not support completion");
      }
      const response = await this.llmService.complete(prompt, {
        temperature: 0.7,
        // Higher temperature for more creative transformations
        n_predict: 4e3,
        stop: ["}"]
      });
      const result = this.parseExecutionResponse(response);
      return result;
    } catch (error) {
      Logger.error("Transformation execution failed:", error);
      throw new Error(`Failed to execute transformation: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Build intent analysis prompt
   */
  buildIntentAnalysisPrompt(userPrompt, noteContent, frontmatter) {
    const frontmatterStr = JSON.stringify(frontmatter, null, 2);
    const contentPreview = noteContent.substring(0, 2e3);
    return `Analyze this user request and determine what transformation to perform on an idea note.

User Request: "${userPrompt}"

Current Note Content (preview):
${contentPreview}

Frontmatter:
${frontmatterStr}

Available Operations:
- organize: Sort, group, or structure content (e.g., "sort alphabetically", "group by category")
- expand: Add content, examples, or variations (e.g., "add 3 alternatives", "include examples")
- transform: Rename, reformat, or restructure (e.g., "rename to X", "make it shorter", "convert to list")
- analyze: Extract insights or identify issues (e.g., "find problems", "list assumptions")
- restructure: Move, split, or combine sections (e.g., "move section X to top", "split into 3 parts")

Determine:
1. Primary intent (one of the operations above)
2. Specific action to take
3. What parts of the note to modify
4. Expected outcome

Respond in JSON format (no markdown, no code blocks, just JSON):
{
  "intent": "organize|expand|transform|analyze|restructure|custom",
  "action": "specific action description",
  "target": "what to modify (e.g., 'list in body', 'frontmatter fields', 'section X')",
  "expectedOutcome": "what the result should look like",
  "requiresFileRename": false,
  "requiresFrontmatterUpdate": false,
  "requiresBodyModification": true,
  "description": "human-readable description of what will happen"
}

Response: {`;
  }
  /**
   * Build execution prompt
   */
  buildExecutionPrompt(userPrompt, transformationPlan, noteContent, frontmatter, currentFilename) {
    const frontmatterStr = JSON.stringify(frontmatter, null, 2);
    const filenameInfo = currentFilename ? `
Current Filename: ${currentFilename}` : "";
    const intentInstructions = this.getIntentInstructions(transformationPlan.intent);
    const firstOp = transformationPlan.operations[0];
    const action = firstOp?.action || transformationPlan.description;
    const target = firstOp?.target || "body";
    const expectedOutcome = transformationPlan.description;
    return `Transform this idea note according to the user's request.

User Request: "${userPrompt}"

Transformation Plan:
- Intent: ${transformationPlan.intent}
- Action: ${action}
- Target: ${target}
- Expected Outcome: ${expectedOutcome}

Current Note Content:
${noteContent}${filenameInfo}

Frontmatter:
${frontmatterStr}

Instructions:
${intentInstructions}

Critical Rules:
1. Preserve ALL important information unless explicitly asked to remove it
2. Maintain valid YAML frontmatter structure
3. Preserve markdown formatting
4. Keep the original intent and meaning of the content
5. Only make changes that align with the user's request

Generate the transformed content. If no changes are needed to a section, return it as-is.

Output format (JSON only, no markdown, no code blocks):
{
  "newFilename": "new-filename.md" (if rename needed, else null),
  "frontmatter": { ... updated frontmatter as JSON object ... },
  "body": "transformed body content as string",
  "summary": "brief description of changes made"
}

Response: {`;
  }
  /**
   * Get intent-specific instructions
   */
  getIntentInstructions(intent) {
    const instructions = {
      organize: `- Organize content logically (sort, group, structure)
- Maintain all original content
- Use clear headings and structure
- Preserve relationships between items`,
      expand: `- Add new content that enhances the idea
- Maintain consistency with existing content
- Add content in appropriate locations
- Use markdown formatting for new content`,
      transform: `- Transform content format or structure
- Preserve meaning while changing presentation
- Update references if renaming
- Maintain valid markdown`,
      analyze: `- Extract insights from the content
- Identify patterns, problems, or assumptions
- Add analysis as a new section or append to existing
- Use clear headings for analysis results`,
      restructure: `- Reorganize sections or content
- Maintain all information
- Update section order logically
- Preserve content within sections`,
      custom: `- Follow the user's specific request
- Make reasonable interpretations
- Preserve important information
- Apply changes as requested`
    };
    return instructions[intent] || instructions.custom;
  }
  /**
   * Parse intent analysis response
   */
  parseIntentResponse(response) {
    try {
      const repaired = extractAndRepairJSON(response, true);
      const parsed = JSON.parse(repaired);
      const intent = this.validateIntent(parsed.intent || "custom");
      return {
        intent,
        operations: [{
          type: parsed.action || "transform",
          target: parsed.target || "body",
          action: parsed.action || "custom transformation",
          parameters: {}
        }],
        description: parsed.description || `Apply ${intent} transformation`,
        requiresFileRename: parsed.requiresFileRename === true,
        requiresFrontmatterUpdate: parsed.requiresFrontmatterUpdate === true,
        requiresBodyModification: parsed.requiresBodyModification !== false
      };
    } catch (error) {
      Logger.warn("Failed to parse intent response:", error);
      return {
        intent: "custom",
        operations: [{
          type: "transform",
          target: "body",
          action: "custom transformation"
        }],
        description: "Apply custom transformation",
        requiresBodyModification: true
      };
    }
  }
  /**
   * Parse execution response
   */
  parseExecutionResponse(response) {
    try {
      const repaired = extractAndRepairJSON(response, true);
      const parsed = JSON.parse(repaired);
      return {
        newFilename: parsed.newFilename || null,
        frontmatter: parsed.frontmatter || void 0,
        body: parsed.body || void 0,
        summary: parsed.summary || "Transformation applied"
      };
    } catch (error) {
      Logger.warn("Failed to parse execution response:", error);
      const bodyMatch = response.match(/"body"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
      if (bodyMatch) {
        return {
          body: bodyMatch[1].replace(/\\n/g, "\n").replace(/\\"/g, '"'),
          summary: "Transformation applied (partial parsing)"
        };
      }
      throw new Error("Failed to parse transformation result");
    }
  }
  /**
   * Validate intent type
   */
  validateIntent(intent) {
    const validIntents = [
      "organize",
      "expand",
      "transform",
      "analyze",
      "restructure",
      "custom"
    ];
    return validIntents.includes(intent) ? intent : "custom";
  }
  /**
   * Check if service is available
   */
  isAvailable() {
    return this.llmService.isAvailable();
  }
};

// src/views/GuidedIdeationModal.ts
var import_obsidian43 = require("obsidian");
var GuidedIdeationModal = class extends import_obsidian43.Modal {
  inputEl;
  statusEl;
  previewContainer;
  buttonContainer;
  service;
  noteContent;
  frontmatter;
  body;
  currentFilename;
  transformationResult;
  transformationPlan;
  onAccept;
  isProcessing = false;
  constructor(app, service, noteContent, frontmatter, body, currentFilename, onAccept) {
    super(app);
    this.service = service;
    this.noteContent = noteContent;
    this.frontmatter = frontmatter;
    this.body = body;
    this.currentFilename = currentFilename;
    this.onAccept = onAccept;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ideatr-guided-ideation-modal");
    contentEl.createEl("h2", { text: "Ideatr: Transform" });
    const description = contentEl.createEl("p", {
      text: 'Describe the transformation you want to apply to this idea. Examples: "Organize this list alphabetically", "Add three alternatives", "Rename to Project Goodspring"'
    });
    description.addClass("ideatr-modal-description");
    this.inputEl = contentEl.createEl("textarea", {
      attr: {
        placeholder: "Enter your transformation request...",
        rows: "4"
      }
    });
    this.inputEl.addClass("ideatr-input");
    this.inputEl.style.width = "100%";
    this.inputEl.style.marginBottom = "10px";
    this.statusEl = contentEl.createDiv("ideatr-status");
    this.statusEl.style.display = "none";
    this.previewContainer = contentEl.createDiv("ideatr-preview-container");
    this.previewContainer.style.display = "none";
    this.previewContainer.style.maxHeight = "400px";
    this.previewContainer.style.overflowY = "auto";
    this.previewContainer.style.padding = "10px";
    this.previewContainer.style.border = "1px solid var(--background-modifier-border)";
    this.previewContainer.style.borderRadius = "4px";
    this.previewContainer.style.marginTop = "10px";
    this.previewContainer.style.marginBottom = "10px";
    this.buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    this.buttonContainer.style.marginTop = "10px";
    const transformButton = this.buttonContainer.createEl("button", {
      text: "Transform",
      cls: "mod-cta"
    });
    transformButton.addEventListener("click", () => this.handleTransform());
    const cancelButton = this.buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    this.inputEl.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "Enter") {
        e.preventDefault();
        if (!this.isProcessing) {
          this.handleTransform();
        }
      }
    });
    this.inputEl.focus();
  }
  async handleTransform() {
    const prompt = this.inputEl.value.trim();
    if (!prompt) {
      new import_obsidian43.Notice("Please enter a transformation request.");
      return;
    }
    if (this.isProcessing) {
      return;
    }
    this.isProcessing = true;
    this.showStatus("Analyzing intent...");
    try {
      const plan = await this.service.analyzeIntent(prompt, this.noteContent, this.frontmatter);
      this.transformationPlan = plan;
      this.showStatus("Generating transformation...");
      const result = await this.service.executeTransformation(
        prompt,
        plan,
        this.noteContent,
        this.frontmatter,
        this.body,
        this.currentFilename
      );
      this.transformationResult = result;
      this.showPreview(result, plan);
      this.showAcceptButton();
    } catch (error) {
      this.showError(error instanceof Error ? error.message : "Failed to transform idea.");
      console.error("Transformation failed:", error);
    } finally {
      this.isProcessing = false;
    }
  }
  showStatus(message) {
    this.statusEl.empty();
    this.statusEl.style.display = "block";
    this.statusEl.createEl("p", { text: message });
    this.previewContainer.style.display = "none";
    this.hideAcceptButton();
  }
  showError(message) {
    this.statusEl.empty();
    this.statusEl.style.display = "block";
    this.statusEl.addClass("ideatr-error");
    this.statusEl.createEl("p", { text: message });
    this.previewContainer.style.display = "none";
    this.hideAcceptButton();
  }
  showPreview(result, plan) {
    this.statusEl.style.display = "none";
    this.previewContainer.empty();
    this.previewContainer.style.display = "block";
    const planEl = this.previewContainer.createDiv("ideatr-plan-description");
    planEl.createEl("strong", { text: "Transformation: " });
    planEl.createEl("span", { text: plan.description });
    if (result.summary) {
      const summaryEl = this.previewContainer.createDiv("ideatr-summary");
      summaryEl.createEl("strong", { text: "Summary: " });
      summaryEl.createEl("span", { text: result.summary });
    }
    if (result.newFilename && result.newFilename !== this.currentFilename) {
      const filenameEl = this.previewContainer.createDiv("ideatr-filename-change");
      filenameEl.createEl("strong", { text: "Filename: " });
      filenameEl.createEl("span", { text: `${this.currentFilename} \u2192 ${result.newFilename}` });
    }
    if (result.body) {
      const bodyLabel = this.previewContainer.createEl("strong", { text: "Body Preview:" });
      bodyLabel.style.display = "block";
      bodyLabel.style.marginTop = "10px";
      bodyLabel.style.marginBottom = "5px";
      const bodyPreview = this.previewContainer.createDiv("ideatr-body-preview");
      bodyPreview.style.whiteSpace = "pre-wrap";
      bodyPreview.style.fontFamily = "var(--font-monospace)";
      bodyPreview.style.fontSize = "0.9em";
      bodyPreview.style.padding = "10px";
      bodyPreview.style.backgroundColor = "var(--background-secondary)";
      bodyPreview.style.borderRadius = "4px";
      bodyPreview.textContent = result.body.substring(0, 2e3);
      if (result.body.length > 2e3) {
        bodyPreview.textContent += "\n\n... (content truncated for preview)";
      }
    }
    if (result.frontmatter) {
      const fmLabel = this.previewContainer.createEl("strong", { text: "Frontmatter Changes:" });
      fmLabel.style.display = "block";
      fmLabel.style.marginTop = "10px";
      fmLabel.style.marginBottom = "5px";
      const fmPreview = this.previewContainer.createDiv("ideatr-frontmatter-preview");
      fmPreview.style.whiteSpace = "pre-wrap";
      fmPreview.style.fontFamily = "var(--font-monospace)";
      fmPreview.style.fontSize = "0.9em";
      fmPreview.style.padding = "10px";
      fmPreview.style.backgroundColor = "var(--background-secondary)";
      fmPreview.style.borderRadius = "4px";
      fmPreview.textContent = JSON.stringify(result.frontmatter, null, 2);
    }
  }
  showAcceptButton() {
    const existingAccept = this.buttonContainer.querySelector(".ideatr-accept-button");
    if (existingAccept) {
      existingAccept.remove();
    }
    const acceptButton = this.buttonContainer.createEl("button", {
      text: "Accept Changes",
      cls: "mod-cta ideatr-accept-button"
    });
    acceptButton.style.marginLeft = "10px";
    acceptButton.addEventListener("click", async () => {
      if (this.transformationResult && this.transformationPlan && this.onAccept) {
        try {
          await this.onAccept(this.transformationResult, this.transformationPlan);
          this.close();
        } catch (error) {
          new import_obsidian43.Notice(`Failed to apply changes: ${error instanceof Error ? error.message : String(error)}`);
          console.error("Failed to apply transformation:", error);
        }
      }
    });
  }
  hideAcceptButton() {
    const acceptButton = this.buttonContainer.querySelector(".ideatr-accept-button");
    if (acceptButton) {
      acceptButton.remove();
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/transformation/GuidedIdeationCommand.ts
var GuidedIdeationCommand = class extends IdeaFileCommand {
  service;
  constructor(context) {
    super(context);
    this.service = new GuidedIdeationService(context.llmService);
  }
  getCommandName() {
    return "Transform";
  }
  async executeWithFile(file, content) {
    if (!this.checkLLMAvailability()) {
      return;
    }
    new GuidedIdeationModal(
      this.context.app,
      this.service,
      content.content,
      content.frontmatter,
      content.body,
      file.basename,
      async (result, plan) => {
        await this.applyTransformation(file, result, plan, content);
      }
    ).open();
  }
  /**
   * Apply transformation result to file
   */
  async applyTransformation(file, result, plan, originalContent) {
    try {
      const backupPath = file.path.replace(/\.md$/, ".backup.md");
      try {
        await this.context.app.vault.create(backupPath, originalContent.content);
      } catch (error) {
        Logger.warn("Failed to create backup file:", error);
      }
      let targetFile = file;
      if (result.newFilename) {
        let newFilename = result.newFilename.split("/").pop() || result.newFilename;
        const newBasename = newFilename.replace(/\.md$/, "");
        if (newBasename !== file.basename) {
          if (!newFilename.endsWith(".md")) {
            newFilename = `${newFilename}.md`;
          }
          const newPath = file.path.replace(file.name, newFilename);
          try {
            await this.context.app.vault.rename(file, newPath);
            targetFile = this.context.app.vault.getAbstractFileByPath(newPath);
            if (!targetFile) {
              throw new Error("File rename succeeded but could not find renamed file");
            }
            new import_obsidian44.Notice(`File renamed to ${newFilename}`);
          } catch (error) {
            Logger.error("Failed to rename file:", error);
            new import_obsidian44.Notice("Failed to rename file. Other changes will still be applied.");
          }
        }
      }
      if (result.frontmatter && plan.requiresFrontmatterUpdate) {
        await this.context.fileManager.updateIdeaFrontmatter(targetFile, result.frontmatter);
      }
      if (result.body && plan.requiresBodyModification) {
        await this.updateFileBody(targetFile, result.body);
      }
      new import_obsidian44.Notice("Transformation applied successfully!");
    } catch (error) {
      Logger.error("Failed to apply transformation:", error);
      throw error;
    }
  }
  /**
   * Update file body content
   */
  async updateFileBody(file, newBody) {
    await this.context.app.vault.process(file, (content) => {
      const frontmatterRegex = /^---\n([\s\S]*?)\n---(\n\n?|\n?)/;
      const match = content.match(frontmatterRegex);
      if (match) {
        return match[0] + newBody;
      } else {
        return newBody;
      }
    });
  }
};

// src/commands/lifecycle/StatusCommand.ts
var import_obsidian46 = require("obsidian");

// src/views/StatusPickerModal.ts
var import_obsidian45 = require("obsidian");
var StatusPickerModal = class extends import_obsidian45.Modal {
  currentStatus;
  onSelect;
  selectedStatus = null;
  constructor(app, currentStatus, onSelect) {
    super(app);
    this.currentStatus = currentStatus;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Change Idea Status" });
    const description = contentEl.createEl("p", {
      text: `Current status: ${this.currentStatus}. Select a new status:`
    });
    description.addClass("ideatr-modal-description");
    const statusContainer = contentEl.createDiv("ideatr-status-list");
    const statuses = [
      { value: "captured", label: "Captured", description: "Newly captured idea" },
      { value: "validated", label: "Validated", description: "Idea has been validated" },
      { value: "promoted", label: "Promoted", description: "Idea has been promoted" },
      { value: "archived", label: "Archived", description: "Archived idea" }
    ];
    statuses.forEach((status) => {
      const item = statusContainer.createDiv("ideatr-status-item");
      const radio = item.createEl("input", {
        type: "radio",
        attr: {
          name: "status",
          value: status.value,
          checked: this.currentStatus === status.value ? "true" : null
        }
      });
      if (this.currentStatus === status.value) {
        this.selectedStatus = status.value;
      }
      radio.addEventListener("change", (e) => {
        const target = e.target;
        if (target.checked) {
          this.selectedStatus = status.value;
        }
      });
      const label = item.createDiv("ideatr-status-label");
      label.createEl("strong", { text: status.label });
      label.createEl("div", {
        text: status.description,
        cls: "ideatr-status-description"
      });
    });
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    const applyButton = buttonContainer.createEl("button", {
      text: "Apply",
      cls: "mod-cta"
    });
    applyButton.addEventListener("click", () => {
      if (this.selectedStatus && this.onSelect) {
        this.onSelect(this.selectedStatus);
      }
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/lifecycle/StatusCommand.ts
var StatusCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "change status";
  }
  async executeWithFile(file, content) {
    const currentStatusStr = content.frontmatter.status || "captured";
    new StatusPickerModal(
      this.context.app,
      currentStatusStr,
      async (newStatus) => {
        await this.updateIdeaFrontmatter(file, { status: newStatus });
        const prevStatus = content.frontmatter.status;
        const wasArchived = prevStatus === "archived";
        const isNowArchived = newStatus === "archived";
        if (isNowArchived) {
          await this.context.fileOrganizer.moveToArchive(file);
        } else if (wasArchived && !isNowArchived) {
          await this.context.fileOrganizer.moveFromArchive(file);
        }
        new import_obsidian46.Notice(`Status changed to ${newStatus}`);
      }
    ).open();
  }
};

// src/commands/lifecycle/ArchiveCommand.ts
var import_obsidian47 = require("obsidian");
var ArchiveCommand = class extends IdeaFileCommand {
  constructor(context, isArchive) {
    super(context);
    this.isArchive = isArchive;
  }
  getCommandName() {
    return this.isArchive ? "archive idea" : "unarchive idea";
  }
  async executeWithFile(file, content) {
    if (this.isArchive) {
      await this.updateIdeaFrontmatter(file, { status: "archived" });
      await this.context.fileOrganizer.moveToArchive(file);
      new import_obsidian47.Notice("Idea archived successfully.");
    } else {
      const previousStatus = content.frontmatter.status === "archived" ? "captured" : content.frontmatter.status || "captured";
      await this.updateIdeaFrontmatter(file, { status: previousStatus });
      await this.context.fileOrganizer.moveFromArchive(file);
      new import_obsidian47.Notice("Idea unarchived successfully.");
    }
  }
};

// src/commands/lifecycle/CodenameCommand.ts
var import_obsidian48 = require("obsidian");
var CodenameCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "generate codename";
  }
  async executeWithFile(file, content) {
    if (!this.context.llmService?.isAvailable() || !this.context.llmService.complete) {
      new import_obsidian48.Notice("LLM service is not available. Cannot generate codename.");
      return;
    }
    const ideaName = extractIdeaNameRuleBased(content.body);
    const ideaText = ideaName ? `${ideaName}

${content.body}` : content.body;
    new import_obsidian48.Notice("Generating codename...");
    const codename = await this.generateCodename(ideaText);
    if (!codename) {
      new import_obsidian48.Notice("Failed to generate codename. Please try again.");
      return;
    }
    await this.updateIdeaFrontmatter(file, {
      codename: codename.trim()
    });
    const sanitizedCodename = sanitizeTitle(codename.trim());
    const newFilename = `${sanitizedCodename}.md`;
    const currentFilename = file.name;
    if (currentFilename !== newFilename) {
      const directory = file.path.substring(0, file.path.lastIndexOf("/") + 1);
      const newPath = directory + newFilename;
      await this.context.app.vault.rename(file, newPath);
    }
    new import_obsidian48.Notice(`Codename "${codename}" generated successfully.`);
  }
  async generateCodename(ideaText) {
    if (!this.context.llmService?.complete) {
      return null;
    }
    const prompt = `Generate a memorable, brandable codename for this idea.

Idea: "${ideaText.substring(0, 500)}"

CRITICAL REQUIREMENTS:
- Extract the CORE CONCEPT, not just use the literal text
- Focus on what makes the idea unique or memorable
- Create a codename that could work as a project/product name
- Prioritize memorability and pronounceability over literal accuracy

Requirements:
- 1-3 words maximum (prefer 1-2 words)
- Easy to remember and pronounce (test: can you say it naturally?)
- Captures the idea's essence in a creative way
- Professional but distinctive
- Suitable for filenames (alphanumeric, hyphens, spaces only)
- 2-20 characters total (shorter is usually better)
- IMPORTANT: Avoid unpronounceable acronyms longer than 6 characters. If using acronyms, they must be pronounceable (e.g., "ACME" is fine, "AGPFOIM" is not)

Codename strategies:
- Portmanteau: Blend key words (e.g., "net" + "flicks" \u2192 "Netflix")
- Compound: Combine two relevant words (e.g., "VolumeBand", "SoundSense")
- Single word: Use a powerful, relevant word (e.g., "Zen", "Ping", "Alert")
- Short acronym: Only if pronounceable and 6 chars or fewer (e.g., "NASA", "ACME")

Examples:
- "bracelet that measures room volume" \u2192 "VolumeBand", "SoundSense", "EchoBand"
- "AI writing assistant" \u2192 "WriteBot", "TextCraft", "WordSmith"
- "social network for developers" \u2192 "DevNet", "CodeConnect", "DevHub"
- "AI generated puzzle full of interlinked monkeys that look similar, sort of a where's waldo of monkeys" \u2192 "MonkeyFind", "PrimateSeek", "ApeSpot", "FindMonkey"
- "task manager for remote teams" \u2192 "TaskFlow", "TeamSync", "RemoteTask"

Return ONLY the codename. No quotes, no explanation, no prefixes like "Codename:" or "Name:". Just the name itself:`;
    try {
      const response = await this.context.llmService.complete(prompt, {
        temperature: 0.8,
        n_predict: 50,
        stop: ["\n", ".", "!", "?", '"', "'"]
      });
      let codename = response.trim();
      codename = codename.replace(/^["']|["']$/g, "");
      codename = codename.substring(0, 30).trim();
      codename = codename.replace(/[^a-zA-Z0-9\s-]/g, "");
      if (codename.length < 2) {
        return null;
      }
      return codename;
    } catch (error) {
      console.error("Codename generation failed:", error);
      throw error;
    }
  }
};

// src/commands/views/DashboardCommand.ts
var DashboardCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const leaf = this.context.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: "ideatr-dashboard",
        active: true
      });
    } catch (error) {
      this.handleError(error, "open dashboard");
    }
  }
};

// src/commands/views/GraphViewCommand.ts
var GraphViewCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const leaf = this.context.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: "ideatr-graph",
        active: true
      });
    } catch (error) {
      this.handleError(error, "open graph view");
    }
  }
};

// src/commands/views/OpenTutorialsCommand.ts
init_TutorialService();
var OpenTutorialsCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const tutorialService = new TutorialService(this.context.app);
      await tutorialService.openIndex();
    } catch (error) {
      this.handleError(error, "open tutorials", "Opening tutorials");
    }
  }
};

// src/commands/management/ClassifyCurrentNoteCommand.ts
var import_obsidian49 = require("obsidian");
var ClassifyCurrentNoteCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "classify note";
  }
  async executeWithFile(file, content) {
    if (!this.checkServiceAvailability(this.context.classificationService, "AI classification")) {
      return;
    }
    new import_obsidian49.Notice("Classifying idea...");
    const classification = await this.context.classificationService.classifyIdea(content.ideaText);
    const parsed = this.context.frontmatterParser.parse(content.content);
    parsed.frontmatter.category = classification.category;
    parsed.frontmatter.tags = classification.tags;
    if (classification.related.length > 0) {
      parsed.frontmatter.related = classification.related;
    }
    const updatedContent = this.context.frontmatterParser.build(parsed.frontmatter, parsed.body);
    await this.context.app.vault.modify(file, updatedContent);
    new import_obsidian49.Notice("Classification complete!");
  }
};

// src/commands/management/RefreshIdeaCommand.ts
var import_obsidian50 = require("obsidian");
var RefreshIdeaCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "refresh idea";
  }
  async executeWithFile(file, content) {
    new import_obsidian50.Notice("Refreshing idea...");
    const updates = {};
    if (this.context.classificationService.isAvailable()) {
      try {
        const classification = await this.context.classificationService.classifyIdea(content.ideaText);
        updates.category = classification.category;
        updates.tags = classification.tags;
      } catch (error) {
        Logger.warn("Failed to re-classify:", error);
      }
    }
    try {
      const related = await this.context.searchService.findRelatedNotes(content.ideaText, 5);
      updates.related = related.map((r) => r.path);
    } catch (error) {
      Logger.warn("Failed to refresh related notes:", error);
    }
    if (this.context.settings.enableNameVariants && this.context.nameVariantService.isAvailable()) {
      try {
        const variants = await this.context.nameVariantService.generateVariants(content.ideaText);
        if (variants.length > 0) {
          const variantsText = this.context.nameVariantService.formatVariantsForMarkdown(variants);
          await this.context.fileManager.appendToFileBody(file, "Name Variants", variantsText);
        }
      } catch (error) {
        Logger.warn("Failed to regenerate name variants:", error);
      }
    }
    if (Object.keys(updates).length > 0) {
      await this.updateIdeaFrontmatter(file, updates);
    }
    new import_obsidian50.Notice("Idea refreshed successfully.");
  }
};

// src/commands/management/ExportCommand.ts
var import_obsidian51 = require("obsidian");
var ExportCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const format = "json";
      new import_obsidian51.Notice("Exporting ideas...");
      const exportContent = await this.context.exportService.exportIdeas(format);
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const filename = `Ideatr-Export-${timestamp}.${format === "json" ? "json" : format === "csv" ? "csv" : "md"}`;
      const path9 = `Ideas/${filename}`;
      await this.context.app.vault.create(path9, exportContent);
      new import_obsidian51.Notice(`Exported ${filename} successfully.`);
    } catch (error) {
      this.handleError(error, "export ideas");
    }
  }
};

// src/commands/management/ImportCommand.ts
var import_obsidian54 = require("obsidian");

// src/views/ImportFilePickerModal.ts
var import_obsidian52 = require("obsidian");
var ImportFilePickerModal = class extends import_obsidian52.SuggestModal {
  onSelect;
  allowedExtensions;
  constructor(app, allowedExtensions = ["json", "csv", "md"], onSelect) {
    super(app);
    this.onSelect = onSelect;
    this.allowedExtensions = allowedExtensions;
    this.setPlaceholder("Type to search for import files...");
  }
  getSuggestions(query) {
    const allFiles = this.app.vault.getFiles();
    const importableFiles = allFiles.filter((file) => {
      const ext = file.extension.toLowerCase();
      return this.allowedExtensions.includes(ext);
    });
    if (!query) {
      return importableFiles.slice(0, 50);
    }
    const queryLower = query.toLowerCase();
    return importableFiles.filter(
      (file) => file.name.toLowerCase().includes(queryLower) || file.path.toLowerCase().includes(queryLower)
    ).slice(0, 50);
  }
  renderSuggestion(file, el) {
    el.createEl("div", {
      text: file.name,
      attr: { style: "font-weight: bold;" }
    });
    el.createEl("div", {
      text: file.path,
      attr: {
        style: "font-size: 12px; color: var(--text-muted); margin-top: 2px;"
      }
    });
    if (file.stat && file.stat.size) {
      const sizeKB = (file.stat.size / 1024).toFixed(1);
      el.createEl("div", {
        text: `${sizeKB} KB`,
        attr: {
          style: "font-size: 11px; color: var(--text-faint); margin-top: 2px;"
        }
      });
    }
  }
  onChooseSuggestion(file, _evt) {
    this.onSelect(file);
  }
};

// src/views/ProgressModal.ts
var import_obsidian53 = require("obsidian");
var ProgressModal = class extends import_obsidian53.Modal {
  onCancel;
  cancelled = false;
  progressContainer;
  statusContainer;
  errorContainer;
  cancelButton = null;
  title;
  constructor(app, title, onCancel) {
    super(app);
    this.onCancel = onCancel;
    this.title = title;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.title });
    this.progressContainer = contentEl.createDiv("ideatr-progress-container");
    const progressBar = this.progressContainer.createDiv("ideatr-progress-bar");
    progressBar.style.width = "100%";
    progressBar.style.height = "20px";
    progressBar.style.backgroundColor = "var(--background-modifier-border)";
    progressBar.style.borderRadius = "4px";
    progressBar.style.overflow = "hidden";
    const progressFill = progressBar.createDiv("ideatr-progress-fill");
    progressFill.style.width = "0%";
    progressFill.style.height = "100%";
    progressFill.style.backgroundColor = "var(--interactive-accent)";
    progressFill.style.transition = "width 0.3s ease";
    progressBar.fill = progressFill;
    this.statusContainer = contentEl.createDiv("ideatr-progress-status");
    this.statusContainer.style.marginTop = "10px";
    this.statusContainer.style.fontSize = "14px";
    this.statusContainer.style.color = "var(--text-muted)";
    this.errorContainer = contentEl.createDiv("ideatr-progress-errors");
    this.errorContainer.style.marginTop = "10px";
    this.errorContainer.style.maxHeight = "200px";
    this.errorContainer.style.overflowY = "auto";
    this.errorContainer.style.display = "none";
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    buttonContainer.style.marginTop = "20px";
    this.cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-cta"
    });
    this.cancelButton.addEventListener("click", () => {
      this.cancelled = true;
      if (this.onCancel) {
        this.onCancel();
      }
      this.close();
    });
    this.progressFill = progressFill;
    this.progressBar = progressBar;
  }
  updateProgress(update) {
    const progressFill = this.progressFill;
    if (!progressFill)
      return;
    const percentage = update.total > 0 ? update.current / update.total * 100 : 0;
    progressFill.style.width = `${percentage}%`;
    this.statusContainer.empty();
    if (update.currentItem) {
      this.statusContainer.createEl("div", {
        text: `Processing: ${update.currentItem}`,
        cls: "ideatr-progress-current-item"
      });
    }
    this.statusContainer.createEl("div", {
      text: `${update.current} / ${update.total} completed`,
      cls: "ideatr-progress-count"
    });
    if (update.errors && update.errors.length > 0) {
      this.errorContainer.style.display = "block";
      this.errorContainer.empty();
      this.errorContainer.createEl("strong", { text: "Errors:" });
      update.errors.forEach((error) => {
        const errorItem = this.errorContainer.createEl("div", {
          text: error,
          cls: "ideatr-progress-error"
        });
        errorItem.style.color = "var(--text-error)";
        errorItem.style.marginTop = "5px";
      });
    }
    if (update.status === "completed") {
      this.statusContainer.createEl("div", {
        text: "\u2713 Completed",
        cls: "ideatr-progress-completed"
      });
      if (this.cancelButton) {
        this.cancelButton.textContent = "Close";
      }
    } else if (update.status === "cancelled") {
      this.statusContainer.createEl("div", {
        text: "\u2717 Cancelled",
        cls: "ideatr-progress-cancelled"
      });
    }
  }
  isCancelled() {
    return this.cancelled;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.cancelled = false;
  }
};

// src/commands/management/ImportCommand.ts
var ImportCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      if (!this.context.importService) {
        new import_obsidian54.Notice("Import service is not available.");
        return;
      }
      new ImportFilePickerModal(
        this.context.app,
        ["json", "csv", "md"],
        async (importFile) => {
          let format = "json";
          const ext = importFile.extension?.toLowerCase() || "";
          if (ext === "json") {
            format = "json";
          } else if (ext === "csv") {
            format = "csv";
          } else if (ext === "md" || ext === "markdown") {
            format = "markdown";
          } else {
            new import_obsidian54.Notice(`Unsupported file format: ${ext}. Please use JSON, CSV, or Markdown files.`);
            return;
          }
          try {
            const content = await this.context.app.vault.read(importFile);
            const progressModal = new ProgressModal(this.context.app, "Importing Ideas");
            progressModal.open();
            progressModal.updateProgress({
              current: 0,
              total: 1,
              currentItem: `Parsing ${importFile.name}...`,
              status: "processing"
            });
            const result = await this.context.importService.importIdeas(content, format);
            progressModal.updateProgress({
              current: result.total,
              total: result.total,
              status: result.failed === 0 ? "completed" : "completed",
              errors: result.errors.length > 0 ? result.errors.map((e) => `${e.item}: ${e.error}`) : void 0
            });
            if (result.imported > 0) {
              new import_obsidian54.Notice(`Import complete: ${result.imported} imported, ${result.failed} failed${result.errors.length > 0 ? ". Check console for details." : "."}`);
            } else {
              new import_obsidian54.Notice(`Import failed: ${result.failed} failed. Check console for details.`);
            }
            setTimeout(() => {
              progressModal.close();
            }, 2e3);
          } catch (error) {
            console.error("Failed to import ideas:", error);
            new import_obsidian54.Notice("Failed to import ideas. Please try again or check console for details.");
          }
        }
      ).open();
    } catch (error) {
      this.handleError(error, "show import file picker");
    }
  }
};

// src/commands/management/DigestCommand.ts
var import_obsidian55 = require("obsidian");
var DigestCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      new import_obsidian55.Notice("Generating digest...");
      const digest = await this.context.resurfacingService.generateDigest();
      const digestContent = digest.summary;
      const digestPath = `Ideas/.ideatr-digest-${Date.now()}.md`;
      await this.context.app.vault.create(digestPath, digestContent);
      new import_obsidian55.Notice(`Digest generated: ${digest.ideas.length} ideas`);
      const file = this.context.app.vault.getAbstractFileByPath(digestPath);
      if (file) {
        await this.context.app.workspace.openLinkText(digestPath, "", false);
      }
    } catch (error) {
      this.handleError(error, "generate digest");
    }
  }
};

// src/commands/management/ElevateToProjectCommand.ts
var import_obsidian56 = require("obsidian");
var ElevateToProjectCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const activeFile = this.context.app.workspace.getActiveFile();
      if (!activeFile) {
        new import_obsidian56.Notice("No active note. Please open an idea file.");
        return;
      }
      if (!activeFile.path.startsWith("Ideas/")) {
        new import_obsidian56.Notice("This command works with idea files in the Ideas/ directory.");
        return;
      }
      const content = await this.context.app.vault.read(activeFile);
      const ideaFile = this.context.frontmatterParser.parseIdeaFile(
        { path: activeFile.path, name: activeFile.name },
        content
      );
      if (!this.context.projectElevationService.canElevate(ideaFile)) {
        new import_obsidian56.Notice("This idea cannot be elevated. It may already be elevated or have invalid frontmatter.");
        return;
      }
      const projectName = this.context.projectElevationService.generateProjectName(ideaFile);
      const confirmed = confirm(
        `Elevate idea to project?

Project name: ${projectName}

The idea file will be moved to Projects/${projectName}/README.md
Original file will be deleted.`
      );
      if (!confirmed) {
        return;
      }
      new import_obsidian56.Notice("Elevating idea to project...");
      const result = await this.context.projectElevationService.elevateIdea(ideaFile);
      if (result.success) {
        new import_obsidian56.Notice(`Idea elevated to project: ${result.projectPath}`);
        await this.context.ideaRepository.refresh();
        const projectReadme = this.context.app.vault.getAbstractFileByPath(`${result.projectPath}/README.md`);
        if (projectReadme) {
          await this.context.app.workspace.openLinkText(`${result.projectPath}/README.md`, "", false);
        }
      } else {
        new import_obsidian56.Notice(`Failed to elevate idea: ${result.error || "Unknown error"}`);
        if (result.warnings && result.warnings.length > 0) {
          Logger.warn("Elevation warnings:", result.warnings);
        }
      }
    } catch (error) {
      this.handleError(error, "elevate idea to project", "elevate-idea");
    }
  }
};

// src/commands/batch/ReclassifyAllCommand.ts
var import_obsidian57 = require("obsidian");
var ReclassifyAllCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const allFiles = this.context.app.vault.getMarkdownFiles();
      const ideaFiles = allFiles.filter(
        (file) => file.path.startsWith("Ideas/") && !file.path.startsWith("Ideas/Archived/")
      );
      if (ideaFiles.length === 0) {
        new import_obsidian57.Notice("No idea files found in Ideas/ directory.");
        return;
      }
      if (!this.context.classificationService.isAvailable()) {
        new import_obsidian57.Notice("Classification service is not available. Please configure AI in settings.");
        return;
      }
      const progressModal = new ProgressModal(
        this.context.app,
        "Reclassifying Ideas"
      );
      progressModal.open();
      let completed = 0;
      let failed = 0;
      const errors = [];
      for (let i = 0; i < ideaFiles.length; i++) {
        if (progressModal.isCancelled()) {
          break;
        }
        const file = ideaFiles[i];
        progressModal.updateProgress({
          current: i + 1,
          total: ideaFiles.length,
          currentItem: file.name,
          status: "processing"
        });
        try {
          const content = await this.context.app.vault.read(file);
          const parsed = this.context.frontmatterParser.parse(content);
          const ideaText = parsed.body.trim();
          if (ideaText.length === 0) {
            errors.push(`${file.name}: No content to classify`);
            failed++;
            continue;
          }
          const classification = await this.context.classificationService.classifyIdea(ideaText);
          const updated = { ...parsed.frontmatter, ...classification };
          const newContent = this.context.frontmatterParser.build(updated, parsed.body);
          await this.context.app.vault.modify(file, newContent);
          completed++;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          errors.push(`${file.name}: ${errorMessage}`);
          failed++;
        }
      }
      progressModal.updateProgress({
        current: ideaFiles.length,
        total: ideaFiles.length,
        status: progressModal.isCancelled() ? "cancelled" : "completed",
        errors: errors.length > 0 ? errors : void 0
      });
      if (!progressModal.isCancelled()) {
        new import_obsidian57.Notice(`Reclassification complete: ${completed} updated, ${failed} failed`);
      }
    } catch (error) {
      this.handleError(error, "reclassify all ideas");
    }
  }
};

// src/commands/batch/FindAllDuplicatesCommand.ts
var import_obsidian59 = require("obsidian");

// src/views/DuplicatePairsModal.ts
var import_obsidian58 = require("obsidian");
var DuplicatePairsModal = class extends import_obsidian58.Modal {
  pairs;
  selected = /* @__PURE__ */ new Set();
  onBulkAction;
  onLink;
  onArchive;
  onMerge;
  constructor(app, pairs, options) {
    super(app);
    this.pairs = pairs;
    this.onBulkAction = options?.onBulkAction;
    this.onLink = options?.onLink;
    this.onArchive = options?.onArchive;
    this.onMerge = options?.onMerge;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Duplicate Pairs Found" });
    const description = contentEl.createEl("p", {
      text: `Found ${this.pairs.length} duplicate pair${this.pairs.length > 1 ? "s" : ""}. Select pairs and choose an action:`
    });
    description.addClass("ideatr-modal-description");
    const listContainer = contentEl.createDiv("ideatr-duplicate-pairs-list");
    listContainer.style.maxHeight = "400px";
    listContainer.style.overflowY = "auto";
    listContainer.style.marginBottom = "20px";
    this.pairs.forEach((pair, index) => {
      const item = listContainer.createDiv("ideatr-duplicate-pair-item");
      item.style.marginBottom = "15px";
      item.style.padding = "10px";
      item.style.border = "1px solid var(--background-modifier-border)";
      item.style.borderRadius = "4px";
      const checkbox = item.createEl("input", {
        type: "checkbox",
        attr: { checked: "true" }
      });
      this.selected.add(index);
      checkbox.style.marginRight = "10px";
      checkbox.style.marginBottom = "10px";
      checkbox.addEventListener("change", (e) => {
        const target = e.target;
        if (target.checked) {
          this.selected.add(index);
        } else {
          this.selected.delete(index);
        }
      });
      const pairInfo = item.createDiv("ideatr-duplicate-pair-info");
      const similarity = pairInfo.createEl("div", {
        text: `Similarity: ${(pair.similarity * 100).toFixed(1)}%`,
        cls: "ideatr-duplicate-pair-similarity"
      });
      similarity.style.fontWeight = "bold";
      similarity.style.marginBottom = "8px";
      similarity.style.color = "var(--text-accent)";
      const file1Div = pairInfo.createDiv("ideatr-duplicate-pair-file");
      file1Div.createEl("strong", { text: "File 1: " });
      file1Div.createEl("span", { text: pair.file1.name });
      file1Div.style.marginBottom = "4px";
      const file2Div = pairInfo.createDiv("ideatr-duplicate-pair-file");
      file2Div.createEl("strong", { text: "File 2: " });
      file2Div.createEl("span", { text: pair.file2.name });
      file2Div.style.marginBottom = "8px";
      const pairActions = item.createDiv("ideatr-duplicate-pair-actions");
      pairActions.style.marginTop = "8px";
      pairActions.style.display = "flex";
      pairActions.style.gap = "8px";
      const linkBtn = pairActions.createEl("button", {
        text: "Link",
        attr: { style: "font-size: 11px; padding: 4px 8px;" }
      });
      linkBtn.addEventListener("click", () => {
        if (this.onLink) {
          this.onLink(pair);
        }
      });
      const archiveBtn = pairActions.createEl("button", {
        text: "Archive",
        attr: { style: "font-size: 11px; padding: 4px 8px;" }
      });
      archiveBtn.addEventListener("click", () => {
        if (this.onArchive) {
          this.onArchive(pair);
        }
      });
      const mergeBtn = pairActions.createEl("button", {
        text: "Merge",
        attr: { style: "font-size: 11px; padding: 4px 8px;" }
      });
      mergeBtn.addEventListener("click", () => {
        if (this.onMerge) {
          this.onMerge(pair);
        }
      });
    });
    const bulkSection = contentEl.createDiv("ideatr-duplicate-bulk-actions");
    bulkSection.style.marginTop = "20px";
    bulkSection.style.paddingTop = "20px";
    bulkSection.style.borderTop = "1px solid var(--background-modifier-border)";
    bulkSection.createEl("h3", {
      text: "Bulk Actions",
      attr: { style: "margin-bottom: 10px;" }
    });
    bulkSection.createEl("p", {
      text: `Apply action to ${this.selected.size} selected pair${this.selected.size > 1 ? "s" : ""}:`,
      attr: { style: "font-size: 12px; color: var(--text-muted); margin-bottom: 10px;" }
    });
    const bulkButtonContainer = bulkSection.createDiv("ideatr-modal-buttons");
    bulkButtonContainer.style.display = "flex";
    bulkButtonContainer.style.gap = "10px";
    const bulkLinkButton = bulkButtonContainer.createEl("button", {
      text: "Link Selected",
      cls: "mod-cta"
    });
    bulkLinkButton.addEventListener("click", () => {
      const selectedPairs = this.pairs.filter((_, i) => this.selected.has(i));
      if (this.onBulkAction) {
        this.onBulkAction(selectedPairs, "link");
      }
    });
    const bulkArchiveButton = bulkButtonContainer.createEl("button", {
      text: "Archive Selected"
    });
    bulkArchiveButton.addEventListener("click", () => {
      const selectedPairs = this.pairs.filter((_, i) => this.selected.has(i));
      if (this.onBulkAction) {
        this.onBulkAction(selectedPairs, "archive");
      }
    });
    const bulkMergeButton = bulkButtonContainer.createEl("button", {
      text: "Merge Selected"
    });
    bulkMergeButton.addEventListener("click", () => {
      const selectedPairs = this.pairs.filter((_, i) => this.selected.has(i));
      if (this.onBulkAction) {
        this.onBulkAction(selectedPairs, "merge");
      }
    });
    const cancelButton = bulkButtonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/batch/FindAllDuplicatesCommand.ts
var FindAllDuplicatesCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const allFiles = this.context.app.vault.getMarkdownFiles();
      const ideaFiles = allFiles.filter(
        (file) => file.path.startsWith("Ideas/") && !file.path.startsWith("Ideas/Archived/")
      );
      if (ideaFiles.length < 2) {
        new import_obsidian59.Notice("Need at least 2 idea files to find duplicates.");
        return;
      }
      new import_obsidian59.Notice("Scanning for duplicates... This may take a while.");
      const duplicatePairs = [];
      for (let i = 0; i < ideaFiles.length; i++) {
        for (let j = i + 1; j < ideaFiles.length; j++) {
          const file1 = ideaFiles[i];
          const file2 = ideaFiles[j];
          try {
            const content1 = await this.context.app.vault.read(file1);
            const content2 = await this.context.app.vault.read(file2);
            const parsed1 = this.context.frontmatterParser.parse(content1);
            const parsed2 = this.context.frontmatterParser.parse(content2);
            const body1 = parsed1.body;
            const body2 = parsed2.body;
            const similarity = this.context.searchService.calculateSimilarity(body1, body2);
            if (similarity > 0.75) {
              duplicatePairs.push({
                file1,
                file2,
                similarity
              });
            }
          } catch (error) {
            Logger.warn(`Failed to compare ${file1.name} and ${file2.name}:`, error);
          }
        }
      }
      if (duplicatePairs.length === 0) {
        new import_obsidian59.Notice("No duplicates found.");
        return;
      }
      const modal = new DuplicatePairsModal(
        this.context.app,
        duplicatePairs,
        {
          onBulkAction: async (pairs, action) => {
            for (const pair of pairs) {
              try {
                if (action === "link") {
                  await this.linkDuplicatePair(pair);
                } else if (action === "archive") {
                  await this.archiveDuplicatePair(pair);
                } else if (action === "merge") {
                  await this.mergeDuplicatePair(pair);
                }
              } catch (error) {
                console.error(`Failed to ${action} pair:`, error);
              }
            }
            new import_obsidian59.Notice(`Applied ${action} to ${pairs.length} pair${pairs.length > 1 ? "s" : ""}.`);
            modal.close();
          },
          onLink: async (pair) => {
            await this.linkDuplicatePair(pair);
            new import_obsidian59.Notice("Duplicates linked in frontmatter.");
          },
          onArchive: async (pair) => {
            await this.archiveDuplicatePair(pair);
            new import_obsidian59.Notice("Duplicate archived.");
          },
          onMerge: async (pair) => {
            await this.mergeDuplicatePair(pair);
            new import_obsidian59.Notice("Duplicates merged.");
          }
        }
      );
      modal.open();
    } catch (error) {
      this.handleError(error, "find all duplicates");
    }
  }
  async linkDuplicatePair(pair) {
    const content1 = await this.context.app.vault.read(pair.file1);
    const content2 = await this.context.app.vault.read(pair.file2);
    const parsed1 = this.context.frontmatterParser.parse(content1);
    const parsed2 = this.context.frontmatterParser.parse(content2);
    const related1 = Array.isArray(parsed1.frontmatter.related) ? [...parsed1.frontmatter.related] : [];
    const related2 = Array.isArray(parsed2.frontmatter.related) ? [...parsed2.frontmatter.related] : [];
    if (!related1.includes(pair.file2.path)) {
      related1.push(pair.file2.path);
    }
    if (!related2.includes(pair.file1.path)) {
      related2.push(pair.file1.path);
    }
    const updated1 = { ...parsed1.frontmatter, related: related1 };
    const updated2 = { ...parsed2.frontmatter, related: related2 };
    const newContent1 = this.context.frontmatterParser.build(updated1, parsed1.body);
    const newContent2 = this.context.frontmatterParser.build(updated2, parsed2.body);
    await this.context.app.vault.modify(pair.file1, newContent1);
    await this.context.app.vault.modify(pair.file2, newContent2);
  }
  async archiveDuplicatePair(pair) {
    await this.context.fileOrganizer.moveToArchive(pair.file2);
    const content = await this.context.app.vault.read(pair.file2);
    const parsed = this.context.frontmatterParser.parse(content);
    const updated = { ...parsed.frontmatter, status: "archived" };
    const newContent = this.context.frontmatterParser.build(updated, parsed.body);
    await this.context.app.vault.modify(pair.file2, newContent);
  }
  async mergeDuplicatePair(pair) {
    const content1 = await this.context.app.vault.read(pair.file1);
    const content2 = await this.context.app.vault.read(pair.file2);
    const parsed1 = this.context.frontmatterParser.parse(content1);
    const parsed2 = this.context.frontmatterParser.parse(content2);
    const mergedBody = `${parsed1.body}

---

Merged from: ${pair.file2.name}

${parsed2.body}`;
    const mergedTags = [
      ...Array.isArray(parsed1.frontmatter.tags) ? parsed1.frontmatter.tags : [],
      ...Array.isArray(parsed2.frontmatter.tags) ? parsed2.frontmatter.tags : []
    ];
    const uniqueTags = Array.from(new Set(mergedTags));
    const mergedRelated = [
      ...Array.isArray(parsed1.frontmatter.related) ? parsed1.frontmatter.related : [],
      ...Array.isArray(parsed2.frontmatter.related) ? parsed2.frontmatter.related : [],
      pair.file2.path
    ];
    const uniqueRelated = Array.from(new Set(mergedRelated));
    const updatedFrontmatter = {
      ...parsed1.frontmatter,
      tags: uniqueTags,
      related: uniqueRelated
    };
    const updatedContent = this.context.frontmatterParser.build(updatedFrontmatter, mergedBody);
    await this.context.app.vault.modify(pair.file1, updatedContent);
    await this.context.app.vault.delete(pair.file2);
  }
};

// src/commands/batch/RefreshRelatedNotesCommand.ts
var import_obsidian60 = require("obsidian");
var RefreshRelatedNotesCommand = class extends BaseCommand {
  constructor(context) {
    super(context);
  }
  async execute() {
    try {
      const allFiles = this.context.app.vault.getMarkdownFiles();
      const ideaFiles = allFiles.filter(
        (file) => file.path.startsWith("Ideas/") && !file.path.startsWith("Ideas/Archived/")
      );
      if (ideaFiles.length === 0) {
        new import_obsidian60.Notice("No idea files found in Ideas/ directory.");
        return;
      }
      const progressModal = new ProgressModal(
        this.context.app,
        "Refreshing Related Notes"
      );
      progressModal.open();
      let completed = 0;
      let failed = 0;
      const errors = [];
      for (let i = 0; i < ideaFiles.length; i++) {
        if (progressModal.isCancelled()) {
          break;
        }
        const file = ideaFiles[i];
        progressModal.updateProgress({
          current: i + 1,
          total: ideaFiles.length,
          currentItem: file.name,
          status: "processing"
        });
        try {
          const content = await this.context.app.vault.read(file);
          const parsed = this.context.frontmatterParser.parse(content);
          const ideaText = parsed.body.trim();
          if (ideaText.length === 0) {
            errors.push(`${file.name}: No content to search`);
            failed++;
            continue;
          }
          const related = await this.context.searchService.findRelatedNotes(ideaText, 5);
          const relatedPaths = related.map((r) => r.path);
          const updated = { ...parsed.frontmatter, related: relatedPaths };
          const newContent = this.context.frontmatterParser.build(updated, parsed.body);
          await this.context.app.vault.modify(file, newContent);
          completed++;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          errors.push(`${file.name}: ${errorMessage}`);
          failed++;
        }
      }
      progressModal.updateProgress({
        current: ideaFiles.length,
        total: ideaFiles.length,
        status: progressModal.isCancelled() ? "cancelled" : "completed",
        errors: errors.length > 0 ? errors : void 0
      });
      if (!progressModal.isCancelled()) {
        new import_obsidian60.Notice(`Refresh complete: ${completed} updated, ${failed} failed`);
      }
    } catch (error) {
      this.handleError(error, "refresh all related notes");
    }
  }
};

// src/commands/analysis/TenuousLinksCommand.ts
var import_obsidian62 = require("obsidian");

// src/views/TenuousLinksModal.ts
var import_obsidian61 = require("obsidian");
var TenuousLinksModal = class extends import_obsidian61.Modal {
  links;
  onLink;
  onCloseCallback;
  constructor(app, links, onLink, onClose) {
    super(app);
    this.links = links;
    this.onLink = onLink;
    this.onCloseCallback = onClose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Tenuous Links" });
    const description = contentEl.createEl("p", {
      text: `Found ${this.links.length} unexpected connection${this.links.length > 1 ? "s" : ""}. These are ideas with lower similarity but interesting potential connections:`
    });
    description.addClass("ideatr-modal-description");
    const listContainer = contentEl.createDiv("ideatr-tenuous-links-list");
    this.links.forEach((link) => {
      const item = listContainer.createDiv("ideatr-tenuous-link-item");
      item.style.marginBottom = "20px";
      item.style.padding = "10px";
      item.style.border = "1px solid var(--background-modifier-border)";
      item.style.borderRadius = "4px";
      item.createEl("strong", { text: link.idea.title });
      item.createEl("div", {
        text: `Similarity: ${(link.similarity * 100).toFixed(1)}% | Relevance: ${(link.relevance * 100).toFixed(1)}%`,
        cls: "ideatr-tenuous-link-meta",
        attr: { style: "font-size: 12px; color: var(--text-muted); margin-top: 5px;" }
      });
      item.createEl("div", {
        text: link.explanation,
        cls: "ideatr-tenuous-link-explanation",
        attr: { style: "margin-top: 10px; font-style: italic;" }
      });
      if (link.synergy) {
        item.createEl("div", {
          text: `\u{1F4A1} Synergy: ${link.synergy}`,
          cls: "ideatr-tenuous-link-synergy",
          attr: { style: "margin-top: 10px; color: var(--text-accent);" }
        });
      }
      const buttonContainer = item.createDiv("ideatr-modal-buttons");
      buttonContainer.style.marginTop = "10px";
      const linkButton = buttonContainer.createEl("button", {
        text: "Link Ideas",
        cls: "mod-cta"
      });
      linkButton.addEventListener("click", () => {
        if (this.onLink) {
          this.onLink(link, "link");
        }
      });
      const combineButton = buttonContainer.createEl("button", {
        text: "Create Combined Idea"
      });
      combineButton.addEventListener("click", () => {
        if (this.onLink) {
          this.onLink(link, "combine");
        }
      });
    });
    const closeButton = contentEl.createDiv("ideatr-modal-buttons").createEl("button", {
      text: "Close"
    });
    closeButton.addEventListener("click", () => {
      if (this.onCloseCallback) {
        this.onCloseCallback();
      }
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.onCloseCallback) {
      this.onCloseCallback();
    }
  }
};

// src/commands/analysis/TenuousLinksCommand.ts
var TenuousLinksCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "find tenuous links";
  }
  async executeWithFile(file, content) {
    if (!this.context.tenuousLinkService) {
      new import_obsidian62.Notice("Tenuous link service is not available.");
      return;
    }
    new import_obsidian62.Notice("Finding tenuous links... This may take a moment.");
    const links = await this.context.tenuousLinkService.findTenuousLinks(
      content.ideaText,
      content.frontmatter.category || "",
      content.frontmatter.tags || [],
      content.frontmatter.related || []
    );
    if (links.length === 0) {
      new import_obsidian62.Notice("No tenuous links found.");
      return;
    }
    new TenuousLinksModal(
      this.context.app,
      links,
      async (link, action) => {
        if (action === "link") {
          const currentRelated = content.frontmatter.related || [];
          if (!currentRelated.includes(link.idea.path)) {
            await this.updateIdeaFrontmatter(file, {
              related: [...currentRelated, link.idea.path]
            });
            new import_obsidian62.Notice(`Linked to ${link.idea.title}`);
          }
        } else if (action === "combine") {
          const combinedContent = `---
type: idea
status: captured
created: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}
category: ${content.frontmatter.category || ""}
tags: ${JSON.stringify([...content.frontmatter.tags || [], "combined"])}
related: ${JSON.stringify([file.path, link.idea.path])}
domains: []
existence-check: []
---

# Combined Idea

## Original Idea
${content.ideaText}

## Linked Idea
${link.explanation}

## Synergy
${link.synergy || "Potential combination of these ideas"}
`;
          const newPath = `Ideas/${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}-combined-idea.md`;
          await this.context.app.vault.create(newPath, combinedContent);
          new import_obsidian62.Notice("Created combined idea.");
        }
      }
    ).open();
  }
};

// src/commands/analysis/ClusterAnalysisCommand.ts
var import_obsidian64 = require("obsidian");

// src/views/ClusterAnalysisModal.ts
var import_obsidian63 = require("obsidian");
var ClusterAnalysisModal = class extends import_obsidian63.Modal {
  cluster;
  onOpenIdea;
  constructor(app, cluster, onOpenIdea) {
    super(app);
    this.cluster = cluster;
    this.onOpenIdea = onOpenIdea;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Cluster Analysis" });
    const header = contentEl.createDiv("ideatr-cluster-header");
    header.createEl("h3", {
      text: this.cluster.label || "Unnamed Cluster",
      attr: { style: "margin-bottom: 10px;" }
    });
    header.createEl("p", {
      text: `${this.cluster.ideas.length} idea${this.cluster.ideas.length > 1 ? "s" : ""} in this cluster`,
      attr: { style: "color: var(--text-muted); margin-bottom: 20px;" }
    });
    if (this.cluster.statistics) {
      const statsSection = contentEl.createDiv("ideatr-cluster-stats");
      statsSection.style.marginBottom = "20px";
      statsSection.style.padding = "10px";
      statsSection.style.backgroundColor = "var(--background-secondary)";
      statsSection.style.borderRadius = "4px";
      statsSection.createEl("h4", {
        text: "Statistics",
        attr: { style: "margin-bottom: 10px;" }
      });
      const statsList = statsSection.createEl("ul", {
        attr: { style: "margin: 0; padding-left: 20px;" }
      });
      if (this.cluster.statistics.averageAge !== void 0) {
        statsList.createEl("li", {
          text: `Average age: ${Math.round(this.cluster.statistics.averageAge)} days`
        });
      }
      if (this.cluster.statistics.statusDistribution) {
        const statusItems = Object.entries(this.cluster.statistics.statusDistribution).map(([status, count]) => `${status}: ${count}`).join(", ");
        statsList.createEl("li", {
          text: `Status distribution: ${statusItems}`
        });
      }
    }
    if (this.cluster.commonTags && this.cluster.commonTags.length > 0) {
      const tagsSection = contentEl.createDiv("ideatr-cluster-tags");
      tagsSection.style.marginBottom = "20px";
      tagsSection.createEl("h4", {
        text: "Common Tags",
        attr: { style: "margin-bottom: 10px;" }
      });
      const tagsContainer = tagsSection.createDiv("ideatr-cluster-tags-list");
      tagsContainer.style.display = "flex";
      tagsContainer.style.flexWrap = "wrap";
      tagsContainer.style.gap = "5px";
      this.cluster.commonTags.forEach((tag) => {
        tagsContainer.createEl("span", {
          text: tag,
          attr: {
            style: "background: var(--background-modifier-border); padding: 2px 8px; border-radius: 12px; font-size: 12px;"
          }
        });
      });
    }
    if (this.cluster.commonThemes && this.cluster.commonThemes.length > 0) {
      const themesSection = contentEl.createDiv("ideatr-cluster-themes");
      themesSection.style.marginBottom = "20px";
      themesSection.createEl("h4", {
        text: "Common Themes",
        attr: { style: "margin-bottom: 10px;" }
      });
      const themesList = themesSection.createEl("ul", {
        attr: { style: "margin: 0; padding-left: 20px;" }
      });
      this.cluster.commonThemes.forEach((theme) => {
        themesList.createEl("li", { text: theme });
      });
    }
    const membersSection = contentEl.createDiv("ideatr-cluster-members");
    membersSection.style.marginBottom = "20px";
    membersSection.createEl("h4", {
      text: "Cluster Members",
      attr: { style: "margin-bottom: 10px;" }
    });
    const membersList = membersSection.createDiv("ideatr-cluster-members-list");
    membersList.style.maxHeight = "300px";
    membersList.style.overflowY = "auto";
    membersList.style.border = "1px solid var(--background-modifier-border)";
    membersList.style.borderRadius = "4px";
    membersList.style.padding = "10px";
    this.cluster.ideas.forEach((idea) => {
      const memberItem = membersList.createDiv("ideatr-cluster-member-item");
      memberItem.style.marginBottom = "8px";
      memberItem.style.padding = "8px";
      memberItem.style.cursor = "pointer";
      memberItem.style.borderRadius = "4px";
      memberItem.style.transition = "background-color 0.2s";
      memberItem.addEventListener("mouseenter", () => {
        memberItem.style.backgroundColor = "var(--background-modifier-hover)";
      });
      memberItem.addEventListener("mouseleave", () => {
        memberItem.style.backgroundColor = "transparent";
      });
      memberItem.addEventListener("click", () => {
        if (this.onOpenIdea) {
          this.onOpenIdea(`Ideas/${idea.filename}`);
        }
      });
      memberItem.createEl("strong", { text: idea.filename });
      if (idea.frontmatter?.category) {
        memberItem.createEl("div", {
          text: `Category: ${idea.frontmatter.category}`,
          attr: { style: "font-size: 12px; color: var(--text-muted); margin-top: 4px;" }
        });
      }
    });
    if (this.cluster.relatedClusters && this.cluster.relatedClusters.length > 0) {
      const relatedSection = contentEl.createDiv("ideatr-cluster-related");
      relatedSection.style.marginBottom = "20px";
      relatedSection.createEl("h4", {
        text: "Related Clusters",
        attr: { style: "margin-bottom: 10px;" }
      });
      const relatedList = relatedSection.createEl("ul", {
        attr: { style: "margin: 0; padding-left: 20px;" }
      });
      this.cluster.relatedClusters.forEach((cluster) => {
        const listItem = relatedList.createEl("li", {
          attr: { style: "margin-bottom: 8px;" }
        });
        listItem.createEl("strong", {
          text: `${cluster.label} (similarity: ${(cluster.similarity * 100).toFixed(1)}%)`
        });
        if (cluster.explanation) {
          listItem.createEl("div", {
            text: cluster.explanation,
            attr: {
              style: "font-size: 12px; color: var(--text-muted); margin-top: 4px; font-style: italic;"
            }
          });
        }
      });
    }
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    buttonContainer.style.marginTop = "20px";
    const closeButton = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/analysis/ClusterAnalysisCommand.ts
var ClusterAnalysisCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "analyze idea cluster";
  }
  async executeWithFile(file, _content) {
    if (!this.context.clusteringService) {
      new import_obsidian64.Notice("Clustering service is not available.");
      return;
    }
    new import_obsidian64.Notice("Analyzing cluster...");
    const allFiles = this.context.app.vault.getMarkdownFiles();
    const ideaFiles = allFiles.filter(
      (f) => f.path.startsWith("Ideas/") && !f.path.startsWith("Ideas/Archived/")
    );
    if (ideaFiles.length === 0) {
      new import_obsidian64.Notice("No idea files found.");
      return;
    }
    const ideas = [];
    for (const ideaFile of ideaFiles) {
      try {
        const fileContent = await this.context.app.vault.read(ideaFile);
        const parsed = this.context.frontmatterParser.parseIdeaFile(
          { path: ideaFile.path, name: ideaFile.name },
          fileContent
        );
        ideas.push(parsed);
      } catch (error) {
        Logger.warn(`Failed to parse ${ideaFile.path}:`, error);
      }
    }
    const clusters = await this.context.clusteringService.clusterIdeas(ideas);
    const currentCluster = clusters.find(
      (c) => c.ideas.some((i) => i.filename === file.name || `Ideas/${i.filename}` === file.path)
    );
    if (!currentCluster) {
      new import_obsidian64.Notice("Could not find cluster for this idea.");
      return;
    }
    const allTags = /* @__PURE__ */ new Map();
    currentCluster.ideas.forEach((idea) => {
      const tags = idea.frontmatter?.tags || [];
      tags.forEach((tag) => {
        allTags.set(tag, (allTags.get(tag) || 0) + 1);
      });
    });
    const commonTags = Array.from(allTags.entries()).filter(([_, count]) => count >= 2).sort((a, b) => b[1] - a[1]).map(([tag]) => tag).slice(0, 10);
    const ages = currentCluster.ideas.map((idea) => {
      const created = idea.frontmatter?.created ? new Date(idea.frontmatter.created).getTime() : Date.now();
      return Math.floor((Date.now() - created) / (1e3 * 60 * 60 * 24));
    });
    const averageAge = ages.reduce((a, b) => a + b, 0) / ages.length;
    const statusDistribution = {};
    currentCluster.ideas.forEach((idea) => {
      const status = idea.frontmatter?.status || "unknown";
      statusDistribution[status] = (statusDistribution[status] || 0) + 1;
    });
    const relatedClusters = await Promise.all(
      clusters.filter((c) => c !== currentCluster).map(async (otherCluster) => {
        let totalSimilarity = 0;
        let comparisons = 0;
        for (const idea1 of currentCluster.ideas) {
          for (const idea2 of otherCluster.ideas) {
            const body1 = idea1.body || idea1.filename || "";
            const body2 = idea2.body || idea2.filename || "";
            if (body1 && body2) {
              const similarity = this.context.searchService.calculateSimilarity(body1, body2);
              totalSimilarity += similarity;
              comparisons++;
            }
          }
        }
        const avgSimilarity = comparisons > 0 ? totalSimilarity / comparisons : 0;
        return {
          label: otherCluster.label,
          similarity: avgSimilarity,
          cluster: otherCluster
        };
      })
    );
    const filteredRelated = relatedClusters.filter((c) => c.similarity > 0.3).sort((a, b) => b.similarity - a.similarity).slice(0, 5).map((c) => ({
      label: c.label,
      similarity: c.similarity
    }));
    let commonThemes = [];
    let relationshipExplanations = /* @__PURE__ */ new Map();
    if (this.context.llmService.isAvailable() && this.context.llmService.complete) {
      try {
        const clusterIdeasForAnalysis = currentCluster.ideas.map((idea) => ({
          title: idea.filename.replace(".md", ""),
          text: idea.body || "",
          category: idea.frontmatter?.category || "",
          tags: idea.frontmatter?.tags || []
        }));
        const analysisPrompt = PROMPTS.clusterAnalysis({
          clusterIdeas: clusterIdeasForAnalysis
        });
        const analysisResponse = await this.context.llmService.complete(analysisPrompt, {
          temperature: 0.7,
          n_predict: 500
        });
        try {
          const repaired = extractAndRepairJSON(analysisResponse, false);
          const analysis = JSON.parse(repaired);
          commonThemes = analysis.commonThemes || [];
        } catch (error) {
          Logger.warn("Failed to parse cluster analysis JSON:", error);
        }
        for (const relatedCluster of filteredRelated.slice(0, 3)) {
          const otherCluster = relatedClusters.find((c) => c.label === relatedCluster.label)?.cluster;
          if (otherCluster) {
            const otherClusterIdeas = otherCluster.ideas.map((idea) => ({
              title: idea.filename.replace(".md", ""),
              text: idea.body || "",
              category: idea.frontmatter?.category || "",
              tags: idea.frontmatter?.tags || []
            }));
            const relationshipPrompt = PROMPTS.clusterAnalysis({
              clusterIdeas: clusterIdeasForAnalysis,
              otherClusterIdeas,
              similarity: relatedCluster.similarity
            });
            const relationshipResponse = await this.context.llmService.complete(relationshipPrompt, {
              temperature: 0.7,
              n_predict: 300
            });
            try {
              const repaired = extractAndRepairJSON(relationshipResponse, false);
              const relationshipAnalysis = JSON.parse(repaired);
              if (relatedCluster.label) {
                relationshipExplanations.set(
                  relatedCluster.label,
                  relationshipAnalysis.relationshipToOtherCluster || ""
                );
              }
            } catch (error) {
              Logger.warn("Failed to parse relationship analysis JSON:", error);
            }
          }
        }
      } catch (error) {
        Logger.warn("Failed to analyze cluster with LLM:", error);
      }
    }
    const clusterInfo = {
      label: currentCluster.label || "Unnamed Cluster",
      ideas: currentCluster.ideas,
      commonTags,
      commonThemes: commonThemes.length > 0 ? commonThemes : void 0,
      statistics: {
        totalIdeas: currentCluster.ideas.length,
        averageAge,
        statusDistribution
      },
      relatedClusters: filteredRelated.map((c) => ({
        label: c.label || "Unnamed Cluster",
        similarity: c.similarity,
        explanation: relationshipExplanations.get(c.label || "")
      })).filter((c) => c.label !== "Unnamed Cluster" || c.similarity > 0)
    };
    new ClusterAnalysisModal(
      this.context.app,
      clusterInfo,
      async (path9) => {
        const targetFile = this.context.app.vault.getAbstractFileByPath(path9 || "");
        if (targetFile) {
          await this.context.app.workspace.openLinkText(path9 || "", "", true);
        }
      }
    ).open();
  }
};

// src/views/IdeaStatsModal.ts
var import_obsidian65 = require("obsidian");
var IdeaStatsModal = class extends import_obsidian65.Modal {
  stats;
  constructor(app, stats) {
    super(app);
    this.stats = stats;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Idea Statistics" });
    const statsGrid = contentEl.createDiv("ideatr-stats-grid");
    statsGrid.style.display = "grid";
    statsGrid.style.gridTemplateColumns = "1fr 1fr";
    statsGrid.style.gap = "15px";
    statsGrid.style.marginBottom = "20px";
    this.createStatCard(statsGrid, "Age", `${this.stats.age} day${this.stats.age !== 1 ? "s" : ""}`);
    this.createStatCard(statsGrid, "Status", this.stats.status || "unknown");
    this.createStatCard(statsGrid, "Category", this.stats.category || "none");
    this.createStatCard(statsGrid, "Related Notes", this.stats.relatedCount.toString());
    this.createStatCard(statsGrid, "Tags", this.stats.tagsCount.toString());
    this.createStatCard(statsGrid, "Domains", this.stats.domainsCount.toString());
    const datesSection = contentEl.createDiv("ideatr-stats-dates");
    datesSection.style.marginBottom = "20px";
    datesSection.style.padding = "10px";
    datesSection.style.backgroundColor = "var(--background-secondary)";
    datesSection.style.borderRadius = "4px";
    datesSection.createEl("h4", {
      text: "Dates",
      attr: { style: "margin-bottom: 10px;" }
    });
    const datesList = datesSection.createEl("ul", {
      attr: { style: "margin: 0; padding-left: 20px;" }
    });
    datesList.createEl("li", {
      text: `Created: ${this.stats.created.toLocaleDateString()}`
    });
    datesList.createEl("li", {
      text: `Last modified: ${this.stats.lastModified.toLocaleDateString()}`
    });
    if (this.stats.frontmatter) {
      const additionalSection = contentEl.createDiv("ideatr-stats-additional");
      additionalSection.style.marginBottom = "20px";
      if (this.stats.frontmatter.tags && this.stats.frontmatter.tags.length > 0) {
        const tagsSection = additionalSection.createDiv("ideatr-stats-tags");
        tagsSection.style.marginBottom = "10px";
        tagsSection.createEl("h4", {
          text: "Tags",
          attr: { style: "margin-bottom: 10px;" }
        });
        const tagsContainer = tagsSection.createDiv("ideatr-stats-tags-list");
        tagsContainer.style.display = "flex";
        tagsContainer.style.flexWrap = "wrap";
        tagsContainer.style.gap = "5px";
        this.stats.frontmatter.tags.forEach((tag) => {
          tagsContainer.createEl("span", {
            text: tag,
            attr: {
              style: "background: var(--background-modifier-border); padding: 2px 8px; border-radius: 12px; font-size: 12px;"
            }
          });
        });
      }
      if (this.stats.frontmatter.related && this.stats.frontmatter.related.length > 0) {
        const relatedSection = additionalSection.createDiv("ideatr-stats-related");
        relatedSection.style.marginBottom = "10px";
        relatedSection.createEl("h4", {
          text: "Related Notes",
          attr: { style: "margin-bottom: 10px;" }
        });
        const relatedList = relatedSection.createEl("ul", {
          attr: { style: "margin: 0; padding-left: 20px; max-height: 150px; overflow-y: auto;" }
        });
        this.stats.frontmatter.related.forEach((path9) => {
          relatedList.createEl("li", {
            text: path9,
            attr: { style: "font-size: 12px;" }
          });
        });
      }
    }
    const buttonContainer = contentEl.createDiv("ideatr-modal-buttons");
    buttonContainer.style.marginTop = "20px";
    const closeButton = buttonContainer.createEl("button", {
      text: "Close",
      cls: "mod-cta"
    });
    closeButton.addEventListener("click", () => {
      this.close();
    });
  }
  createStatCard(container, label, value) {
    const card = container.createDiv("ideatr-stat-card");
    card.style.padding = "10px";
    card.style.backgroundColor = "var(--background-secondary)";
    card.style.borderRadius = "4px";
    card.style.border = "1px solid var(--background-modifier-border)";
    card.createEl("div", {
      text: label,
      attr: {
        style: "font-size: 12px; color: var(--text-muted); margin-bottom: 5px;"
      }
    });
    card.createEl("div", {
      text: value,
      attr: {
        style: "font-size: 16px; font-weight: bold;"
      }
    });
    return card;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/commands/analysis/IdeaStatsCommand.ts
var IdeaStatsCommand = class extends IdeaFileCommand {
  constructor(context) {
    super(context);
  }
  getCommandName() {
    return "show idea stats";
  }
  async executeWithFile(file, content) {
    const created = content.frontmatter.created ? new Date(content.frontmatter.created) : new Date(file.stat.mtime);
    const age = Math.floor((Date.now() - created.getTime()) / (1e3 * 60 * 60 * 24));
    const relatedCount = (content.frontmatter.related || []).length;
    const tagsCount = (content.frontmatter.tags || []).length;
    const domainsCount = (content.frontmatter.domains || []).length;
    const lastModified = new Date(file.stat.mtime);
    const stats = {
      age,
      status: content.frontmatter.status || "unknown",
      category: content.frontmatter.category || "none",
      relatedCount,
      tagsCount,
      domainsCount,
      lastModified,
      created,
      frontmatter: content.frontmatter
    };
    new IdeaStatsModal(this.context.app, stats).open();
  }
};

// src/commands/CommandRegistry.ts
var CommandRegistry = class _CommandRegistry {
  /**
   * Create a command callback that safely executes a command
   * Obsidian supports both sync and async callbacks
   */
  static createCommandCallback(commandName, operation) {
    const callback = async () => {
      console.log(`[Ideatr] Callback invoked for: ${commandName}`);
      Logger.info(`Callback invoked for: ${commandName}`);
      Logger.debug(`Callback stack trace:`, new Error().stack);
      try {
        Logger.debug(`About to call operation for: ${commandName}`);
        await _CommandRegistry.safeExecute(commandName, operation);
        Logger.debug(`Operation completed for: ${commandName}`);
      } catch (error) {
        console.error(`[Ideatr] Callback error for ${commandName}:`, error);
        Logger.error(`Callback error for ${commandName}:`, error);
      }
    };
    if (typeof callback !== "function") {
      console.error(`[Ideatr] ERROR: Callback for ${commandName} is not a function! Type: ${typeof callback}`);
      Logger.error(`Callback for ${commandName} is not a function! Type: ${typeof callback}`);
    }
    return callback;
  }
  /**
   * Safely execute a command with error handling
   */
  static async safeExecute(commandName, operation) {
    console.log(`[Ideatr] Starting command: ${commandName}`);
    Logger.info(`Starting command: ${commandName}`);
    let loadingNotice = null;
    try {
      loadingNotice = new import_obsidian66.Notice(`\u23F3 Processing ${commandName}...`, 0);
      console.log(`[Ideatr] Created loading notice for: ${commandName}`);
      Logger.debug(`Created loading notice for: ${commandName}`);
      try {
        const noticeEl = loadingNotice.noticeEl;
        if (noticeEl) {
          const spinnerSpan = noticeEl.createSpan({ cls: "ideatr-loading-spinner" });
          spinnerSpan.textContent = "\u23F3";
          spinnerSpan.style.marginRight = "6px";
          spinnerSpan.style.display = "inline-block";
        }
      } catch (spinnerError) {
        Logger.debug(`Could not add spinner to notice (non-critical):`, spinnerError);
      }
    } catch (noticeError) {
      console.error(`[Ideatr] Failed to create loading notice for ${commandName}:`, noticeError);
      Logger.error(`Failed to create loading notice for ${commandName}:`, noticeError);
    }
    try {
      Logger.debug(`Executing operation for: ${commandName}`);
      await operation();
      console.log(`[Ideatr] Finished command: ${commandName}`);
      Logger.info(`Finished command: ${commandName}`);
      if (loadingNotice) {
        loadingNotice.hide();
      }
      new import_obsidian66.Notice(`\u2713 ${commandName} completed`, 2e3);
    } catch (error) {
      console.error(`[Ideatr] Command '${commandName}' failed:`, error);
      Logger.error(`Command '${commandName}' failed:`, error);
      if (loadingNotice) {
        loadingNotice.hide();
      }
    }
  }
  /**
   * Register all commands with the plugin
   */
  static registerAll(plugin, context) {
    console.log("[Ideatr] Registering commands...");
    const captureCallback = _CommandRegistry.createCommandCallback("Capture Idea", () => new CaptureCommand(context).execute());
    plugin.addCommand({
      id: "capture-idea",
      name: "Capture Idea",
      callback: captureCallback
    });
    console.log("[Ideatr] Registered: Capture Idea");
    plugin.addCommand({
      id: "search-existence",
      name: "Search Existence",
      callback: _CommandRegistry.createCommandCallback("Search Existence", () => new ExistenceSearchCommand(context).execute())
    });
    plugin.addCommand({
      id: "check-duplicates",
      name: "Check Duplicates",
      callback: _CommandRegistry.createCommandCallback("Check Duplicates", () => new DuplicateCheckCommand(context).execute())
    });
    plugin.addCommand({
      id: "find-related-notes",
      name: "Find Related Notes",
      callback: _CommandRegistry.createCommandCallback("Find Related Notes", () => new RelatedNotesCommand(context).execute())
    });
    plugin.addCommand({
      id: "quick-validate",
      name: "Quick Validate",
      callback: _CommandRegistry.createCommandCallback("Quick Validate", () => new QuickValidateCommand(context).execute())
    });
    const nameVariantCallback = _CommandRegistry.createCommandCallback("Generate Name Variants", () => new NameVariantCommand(context).execute());
    Logger.debug("Created nameVariantCallback, type:", typeof nameVariantCallback);
    plugin.addCommand({
      id: "generate-name-variants",
      name: "Generate Name Variants",
      callback: nameVariantCallback
    });
    Logger.debug("Registered: Generate Name Variants");
    plugin.addCommand({
      id: "generate-scaffold",
      name: "Generate Scaffold",
      callback: _CommandRegistry.createCommandCallback("Generate Scaffold", () => new ScaffoldCommand(context).execute())
    });
    plugin.addCommand({
      id: "generate-mutations",
      name: "Generate Mutations",
      callback: _CommandRegistry.createCommandCallback("Generate Mutations", () => new MutationCommand(context).execute())
    });
    const expandCallback = _CommandRegistry.createCommandCallback("Expand Idea", () => new ExpandCommand(context).execute());
    Logger.debug("Created expandCallback, type:", typeof expandCallback, "is function:", typeof expandCallback === "function");
    plugin.addCommand({
      id: "expand-idea",
      name: "Expand Idea",
      callback: expandCallback
    });
    Logger.debug("Registered: Expand Idea, callback stored:", typeof expandCallback);
    console.log("[Ideatr] Registered: Expand Idea");
    plugin.addCommand({
      id: "reorganize-idea",
      name: "Reorganize Idea",
      callback: _CommandRegistry.createCommandCallback("Reorganize Idea", () => new ReorganizeCommand(context).execute())
    });
    plugin.addCommand({
      id: "guided-ideation",
      name: "Transform",
      callback: _CommandRegistry.createCommandCallback("Transform", () => new GuidedIdeationCommand(context).execute())
    });
    plugin.addCommand({
      id: "change-status",
      name: "Change Status",
      callback: _CommandRegistry.createCommandCallback("Change Status", () => new StatusCommand(context).execute())
    });
    plugin.addCommand({
      id: "archive-idea",
      name: "Archive Idea",
      callback: _CommandRegistry.createCommandCallback("Archive Idea", () => new ArchiveCommand(context, true).execute())
    });
    plugin.addCommand({
      id: "unarchive-idea",
      name: "Unarchive Idea",
      callback: _CommandRegistry.createCommandCallback("Unarchive Idea", () => new ArchiveCommand(context, false).execute())
    });
    plugin.addCommand({
      id: "add-codename",
      name: "Generate Codename",
      callback: _CommandRegistry.createCommandCallback("Generate Codename", () => new CodenameCommand(context).execute())
    });
    plugin.addCommand({
      id: "open-dashboard",
      name: "Open Dashboard",
      callback: _CommandRegistry.createCommandCallback("Open Dashboard", () => new DashboardCommand(context).execute())
    });
    plugin.addCommand({
      id: "open-graph",
      name: "Open Graph View",
      callback: _CommandRegistry.createCommandCallback("Open Graph View", () => new GraphViewCommand(context).execute())
    });
    plugin.addCommand({
      id: "open-tutorials",
      name: "Open Tutorials",
      callback: _CommandRegistry.createCommandCallback("Open Tutorials", () => new OpenTutorialsCommand(context).execute())
    });
    plugin.addCommand({
      id: "classify-current-note",
      name: "Classify Current Note",
      callback: _CommandRegistry.createCommandCallback("Classify Current Note", () => new ClassifyCurrentNoteCommand(context).execute())
    });
    plugin.addCommand({
      id: "refresh-idea",
      name: "Refresh Idea",
      callback: _CommandRegistry.createCommandCallback("Refresh Idea", () => new RefreshIdeaCommand(context).execute())
    });
    plugin.addCommand({
      id: "export-ideas",
      name: "Export Ideas",
      callback: _CommandRegistry.createCommandCallback("Export Ideas", () => new ExportCommand(context).execute())
    });
    plugin.addCommand({
      id: "import-ideas",
      name: "Import Ideas",
      callback: _CommandRegistry.createCommandCallback("Import Ideas", () => new ImportCommand(context).execute())
    });
    plugin.addCommand({
      id: "generate-digest",
      name: "Generate Weekly Digest",
      callback: _CommandRegistry.createCommandCallback("Generate Weekly Digest", () => new DigestCommand(context).execute())
    });
    plugin.addCommand({
      id: "elevate-to-project",
      name: "Elevate to Project",
      callback: _CommandRegistry.createCommandCallback("Elevate to Project", () => new ElevateToProjectCommand(context).execute())
    });
    plugin.addCommand({
      id: "reclassify-all-ideas",
      name: "Reclassify All Ideas",
      callback: _CommandRegistry.createCommandCallback("Reclassify All Ideas", () => new ReclassifyAllCommand(context).execute())
    });
    plugin.addCommand({
      id: "find-all-duplicates",
      name: "Find All Duplicates",
      callback: _CommandRegistry.createCommandCallback("Find All Duplicates", () => new FindAllDuplicatesCommand(context).execute())
    });
    plugin.addCommand({
      id: "refresh-all-related-notes",
      name: "Refresh All Related Notes",
      callback: _CommandRegistry.createCommandCallback("Refresh All Related Notes", () => new RefreshRelatedNotesCommand(context).execute())
    });
    plugin.addCommand({
      id: "find-tenuous-links",
      name: "Find Tenuous Links",
      callback: _CommandRegistry.createCommandCallback("Find Tenuous Links", () => new TenuousLinksCommand(context).execute())
    });
    plugin.addCommand({
      id: "analyze-idea-cluster",
      name: "Analyze Idea Cluster",
      callback: _CommandRegistry.createCommandCallback("Analyze Idea Cluster", () => new ClusterAnalysisCommand(context).execute())
    });
    plugin.addCommand({
      id: "show-idea-stats",
      name: "Show Idea Statistics",
      callback: _CommandRegistry.createCommandCallback("Show Idea Statistics", () => new IdeaStatsCommand(context).execute())
    });
    if (Logger.isDebugEnabled()) {
      const debugCallback = _CommandRegistry.createCommandCallback("Ideatr Debug (Registry)", async () => {
        console.log("[Ideatr DEBUG REGISTRY] Command operation executed!");
        Logger.info("DEBUG REGISTRY: Command executed successfully");
        new import_obsidian66.Notice("Ideatr Debug (Registry) command executed - check console");
      });
      Logger.debug("Debug registry callback type:", typeof debugCallback);
      plugin.addCommand({
        id: "ideatr-debug-registry",
        name: "Ideatr Debug (Registry)",
        callback: debugCallback
      });
      Logger.debug("Registered debug command via CommandRegistry");
    }
  }
};

// src/utils/MemoryMonitor.ts
var MemoryMonitor = class {
  snapshots = [];
  maxSnapshots = 100;
  monitoringInterval = null;
  /**
   * Start monitoring memory usage
   * @param intervalMs - Interval between snapshots in milliseconds (default: 30 seconds)
   */
  startMonitoring(intervalMs = 3e4) {
    if (this.monitoringInterval) {
      Logger.warn("Memory monitoring already started");
      return;
    }
    Logger.debug("Starting memory monitoring");
    this.takeSnapshot();
    this.monitoringInterval = setInterval(() => {
      this.takeSnapshot();
      this.checkForLeaks();
    }, intervalMs);
  }
  /**
   * Stop monitoring
   */
  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
      Logger.debug("Stopped memory monitoring");
    }
  }
  /**
   * Take a memory snapshot
   */
  takeSnapshot() {
    const usage = process.memoryUsage();
    const snapshot = {
      timestamp: Date.now(),
      heapUsedMB: usage.heapUsed / 1024 / 1024,
      heapTotalMB: usage.heapTotal / 1024 / 1024,
      externalMB: usage.external / 1024 / 1024,
      arrayBuffersMB: usage.arrayBuffers / 1024 / 1024
    };
    this.snapshots.push(snapshot);
    if (this.snapshots.length > this.maxSnapshots) {
      this.snapshots.shift();
    }
    return snapshot;
  }
  /**
   * Check for potential memory leaks
   */
  checkForLeaks() {
    if (this.snapshots.length < 10)
      return;
    const recent = this.snapshots.slice(-10);
    const first = recent[0];
    const last = recent[recent.length - 1];
    const heapGrowthMB = last.heapUsedMB - first.heapUsedMB;
    const timeElapsedMinutes = (last.timestamp - first.timestamp) / 1e3 / 60;
    const growthRateMBPerMinute = heapGrowthMB / timeElapsedMinutes;
    if (growthRateMBPerMinute > 1) {
      Logger.warn("Potential memory leak detected:", {
        heapGrowthMB: heapGrowthMB.toFixed(2),
        timeElapsedMinutes: timeElapsedMinutes.toFixed(2),
        growthRateMBPerMinute: growthRateMBPerMinute.toFixed(2)
      });
    }
  }
  /**
   * Get memory usage report
   */
  getReport() {
    if (this.snapshots.length === 0) {
      return "No memory snapshots available";
    }
    const latest = this.snapshots[this.snapshots.length - 1];
    const oldest = this.snapshots[0];
    const growth = latest.heapUsedMB - oldest.heapUsedMB;
    return `Memory Report:
  Current Heap: ${latest.heapUsedMB.toFixed(2)} MB
  Total Heap: ${latest.heapTotalMB.toFixed(2)} MB
  External: ${latest.externalMB.toFixed(2)} MB
  Growth since monitoring started: ${growth.toFixed(2)} MB
  Snapshots collected: ${this.snapshots.length}`;
  }
  /**
   * Get current memory usage
   */
  getCurrentUsage() {
    if (this.snapshots.length === 0) {
      return null;
    }
    return this.snapshots[this.snapshots.length - 1];
  }
  /**
   * Clear all snapshots
   */
  clearSnapshots() {
    this.snapshots = [];
  }
  /**
   * Check if monitoring is active
   */
  isMonitoring() {
    return this.monitoringInterval !== null;
  }
};

// src/utils/iconData.ts
var PURPLE_ICON_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABgAAAAAQAAAGAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABigAwAEAAAAAQAAABgAAAAAPuetXQAAAAlwSFlzAAAOxAAADsQBlSsOGwAABDNJREFUSA2lVN9rHFUU/ubeuXdm9kc2v1pJGmkloLEUH1QKkipGQVHqi/rSp7740Aeh4pNQCksV/AcqgiISbZWiPkTUJiC2WKHGGoi1IWkam7T53U12d3Y3uzM7s/d6Rgism01S8b7MvXfO+b5zvnPuAe5zXb24fOCPXwqPaK1j9+nyj5mxm/EH6YmEs9F5uq1LnIjv4ZKbWNBQU5YlJtxifuTo8Z5LO2Hw7X6m02l2fOD8UZVLDlazidfbH9SWjBmmoVg7lPlwzZdH3Ezl2D7xQnb01rlr2+Fsm8HwudUT2fnYh76r4RerOHiEQ0gOTUhBtQbP09DKwJ2pVTCBdxfl8pl0eiBsJGKNF9FZ6zSrVtgxaZrgdoj4XgOxVgYR17CSGnbMgGMbkFIj3iYwM5k7vXg5ONQMy2x2efP6W/sDL3yC2T6kApwYg5UADFPDIFGrAmDgyGQKuDL8F5TvwGkV/YQ13ojXNIPl2eB5S8Tj0laItQC1oIYrX3oYHwmxMKHgbxCBXcPvl++AhRyphESqRbyoib+RYEsGkdHwebzCuYYgGbjQuDmlUMwwlLIaKzM1mEIh1aWgqgba2+IwTUFyscNjY0sdQPdaPckWgunpQkfoV/stGSCRZFhbCFDKkN6kOyN5WORBlS6vmeju2YvCukdhGwirwQPXhzK99PdfBFskmhstV4r3SgsqCOGVfSxMUcQWwKmgpqNgUqF5jArDa1SFBFr3SSiusF4ozo7dyMzURx/tt2gWXX7+/uRrlbz1dTFbhmAOTEaFoOi5pcGkQe1JBAHDRjGPGxO3EfqUFq++MfjbS59E/vVrSwbRz553LgxJx//eCCVy2XWImEcZAMJikMIgzRnshMLS8gqMqqQ79atV2/NZPfDmvinBgJEOex+TbyujnC1lQ9zLrFK/k0SSmjMCdzj8MI9y3kc8birL4emPxp4MNkHrv00JIoOnX+2d1sw7SRUN795ykXfXIIQPi9oz0Rpi+XYWqWQLYjH27dlLz43Ug9bvm9Zg04Amp3Hy2Z8mgsB6VIuAoi5TBhz7H0oBpUgaG6HyXz514fGLmz6N320ziAyj9gug5pkhKXKGcpFadt3H2lIZrZ1J2C2ikkhZE42g9ecdCQhf11j4Y8hKNCo0Eo5AW4sNTkPOdGgeteKHrtzBxXrAxv2Wh9ZoUOn95jt3Vb136JkB6f45idm5efiej3zuADzkhr746uNao0/9eVeCvOt6brlQnpodl5niCrLeIo3rKjIFo1athcv1YM32O0tEHgYsThMJwpS0Z1ChIt00NkplOnN6fjuvXQkssArnjAkpqE0FGIveAoe0JN3qHbswot6VoFRKrVm28+nc3F24bgG27SBJ/U/Igzz0ft45/m1mUTOnw0/1v8kZTuWyLk+2JM9eG716ppnd/7rr6+vr6O7u7vwvIH8DwCqf0vItrMwAAAAASUVORK5CYII=";
var GREEN_ICON_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABgAAAAAQAAAGAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABigAwAEAAAAAQAAABgAAAAAPuetXQAAAAlwSFlzAAAOxAAADsQBlSsOGwAABDZJREFUSA2tVV1oHFUU/u7cO3dmdme2u8nmv5SmiD5EKoEgVlpiCfokkfpQ7KsoaH2sT6LpVkEffKt/KFp8EIQ2iFKFKmnaUqnakpoYSA02Jm2TbP72L7ubzM7f9U4wEJJNNoIzD/fOme+e75zvnnsusKtHkIvZT/ddKZx/SAhh7GrJvyBSC3z2r1RsNjbWl2TJl5qCNq5AeQBCxhhjY5ncyk8n2/uu7eRjW4KUSCk0fbc3y5bOLPPswceCJ1EvmgEq4FMHPnMxv5hxB4ZvnhroHfpgOxK23Y/2Be2VGVP5SPc4XDuGBG+ERqQ6PuB4FJ4doD4aVx9tf/js4ZEnmruzDaePHk15m/0pmw3h95WnBLNJ8YQqODQvigbahLjSgAhiMEkcUSUGg0TXCOMsjqH5kTf6st8crOaragbmt5f32W65k7sGAiJgUBNREgMjHAoomCQWNEC+WMKl8UE4agUGjzwuCW5vJqmawT1/rEeVIerChEUScAIH/aXPcNnpxx3/FsqkAFXoGJz8GT53YFoGEmbimRTEFn9bMghBK8F7varQoMMCJQzjlUHkxSKKXhZT/p9QZSZJtMFlFdTH6sBUJqUzjjw9dyOZasbCxiy2MJ5YHqpzSPkQ9wxYNI5MsICsWICmGNCpIeWKSqlUFJUM2hvb0KK3ooEn4auV5Hdz5/ZvdB7OtxCM2N/bi6X8olMBik4Z496wdMigKgxcRq7JVye6XKhAjbpoYS0IbIHSkjOTLmenNhNUPQfvj731Qo6kv16w5yFiRTDTkxurrhGEGw0hpJABChkXo6PTqJAKzCBx8vrxoU82E2zJIAS8fv7tfinRD2F1LC2uQnctmYG6VpacaGsS6cLCzIMCXL0CTtWbzR0HvtjsPPyuSkBSxOuMHjkFl+ZyTgHp6RXEZP1zhcsNVmGwCCo5BXkvj0hUDwxLO32h44Kza4IQ+NyB4+N70X6GKUz8vXgfhbQAc+UOBPK4+Q2YzMzASkQQ5ZGLV3v++LGa89C2pUw3Ap/3X/z4WnHgVcbZI6P3J1C+U5atSMX+xr0Qpo96Xg9SoZ+DQGxct3FeVaJ1QFdXl1tx/LucSWkoRdEvyZJdQtpOI6knQ9nsuGqOruOrjTsShAsSouFGUCbQZHuI6ByWqSOgLqIwkVDqLnV30ulqjtdtdH2y3di951jGvU1f7ml8luJ3C6XrBJVfOfSJJuSuinf7jn01vN3a0L7jHoSApdm51bI8cRPDM3w5bcOeDuA6Anms+K7tzoaYnZ6aEhFdo7KBEqbKZMPLRnjySvBRXilB9o+aAdYEaFBWqaIoXFOhqrJdU9mwBQXXuDTTqp1gY0Y1MyiV9izpunFuavIeCvkCdM1AzIqFJ/TLKPN2vI9DopoRrEfTdejwa6qCN3O5vGJZ1oe3fvvlnfV//9vY0dFR19ramvwvDv8BxwGDgevhw4MAAAAASUVORK5CYII=";
var YELLOW_ICON_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABgAAAAAQAAAGAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABigAwAEAAAAAQAAABgAAAAAPuetXQAAAAlwSFlzAAAOxAAADsQBlSsOGwAABBBJREFUSA2VVVtonEUU/mbmv+19001MabpIpIqiEYrVFjEQib4Wn/qiPuiDoeAFS9GXSoXqg8+VUpRSX0SsDxEkiBWRUoxaqJDGapJaa7pJzOa21/z733bG87emTeKf7HqWYWcO3/m+OWfOzA+0ZYrZfxzJ24U3e5RSvK2Qf0GsFXjh+4FkzKy9pWd2v9Y0coASfwLBuOByvLJsj3bv/+LH7Ti2FFAKrDbef1DzVo7rsr43SB8ASEBwDo0HYMxGbaXmzY9PHn3ghd9ObiWypUB56o2hJK6cDpwqvIYD0fkswC3ioQpJB6pZBmc+grIDmch/kHkofYyxd4PNQtpmR7geGFAaky8/DyHgKxPMStPud1J5AEY/xciHJi1rcMlX//2Ht6cvzp+j0F8280UKDH/25W5eqe71JO2YEEzrAhMdd2KZtMnZhFPxsTT2LWK8gaRmPhElENkRrDH2TCIukorvADe66UwV/OunEMwNQ1bGoAIbknWgPnWZyF0kEnFY8Vj/nR2sm0RkoDhXRw4qFqPdd95qu1w8D+UViXgRsv4rZWMA1n3QNapPljCaoJMx+gtXz+3IP3xoZR1/eGIbrTw9kuGo7/dVBky/B2qViJ0ZIqW6h0OjsjFBWc3B2tkDkckD8Rwsk+VF+cIjG9lutcRGl1P+3POr1TkVxNB0XMjSJUIRIR04BCUs9NuDKQijChXfBc8XWF7xZuzitYmNbGFTRFhx9NXnLKM67NaL0OQ8EdVIhMg5kZNY2ElMcNhVHcXJBcK4aASpVx57ferjzXT/KVEIeGf85Ijr6iNms0SdoqB4JxHqNAywUITmSmRR/9tGXHi0Nn9WZuqTzeThOlLgoyHmB6mnjjq2Voa9BHuR7o9JIhoJhMOIw6snwNwarGRSWdmu9/cNXfbbFgiBux59acI3Hzyh0YE6xQLqpQRdrSQkz9Du74W3tIhkOkbz1Ne9hy6NRJGHvog2vQv173/xlJw5f1izrD3V2VnMT9ChKoF0d4CUFkBL5SAD8zRjTN6N2jiLLNEapLf3aSeAmhBWgh45Bi2oQPcWwVYL0NM5BHrKMTPZK2v4qP9tBcIAj3ddbDQUNY+BmKEjETco7QaUloAUuW+ys2IminjNt22JQtDx7/Z9ZfgLJwYHB42JyasoTN+A6znI9+ZQXuXDZ8982lwji/pvKVAqV5x6xV2NjxWMhQUXN2eb8DwJR7ObsunPRZGu97UsUZy+MEIwGBqn6yVpNKm3JezVOj1B9Ai1sJYC0mINzhm34hZMywSnL5rQNeiGLrbvwdvKLQX8SmXZMq0zN67/hdJyiR41C+lkGroQZ00EF1okQBm3aY8fePIwlelYaaUs0tn0hz+Njr7XZmj7sL6+vo6eHrpd/8P+AaolgMPx0J5bAAAAAElFTkSuQmCC";
var RED_ICON_BASE64 = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABgAAAAAQAAAGAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABigAwAEAAAAAQAAABgAAAAAPuetXQAAAAlwSFlzAAAOxAAADsQBlSsOGwAABCpJREFUSA2tVVtoHFUY/s7cd7LXxIQ0iQk0MYEsBSstJeqLGlGKAV+LBN/0wRuiIuiDC14QhYJQEATBiqAYvNWE2lCxXmirJfQhSrw0Kblt0nbNbDK7c9mZneM/kdJ1d+JGcOAw55z5zvf93/+fcwbY5VM4+kq3M/nJ3mXOY7tcsg1jzcD5sTFdM1aeYAcOPusPDukQpRVa85ssS3ObRmm675nnv/43DnGnjzyXEx7vax9TreJxzbbHq8NZPUinZJGhTfYrQ4pp3uFcvXLkPiZsfLC0cmEnHmmnD4Wk+ogeU98OWnRYQQB0doLHdPjk2XcEuJUK9Na03HPbvmOz9492FXzxpbtyOb+eT6if2B5zLsLcPBKoKtyWOIQ9XWDtHWDxOLUEEDaaRywGlkjg6tmzL9iTH++L4op0kD892c3s8q0VIuCcA4k0hEQSkAguCuDlMsADmGUL86dOQXEcBJJ6kAQu1otECii/X7pbU5RkWaMIKVpe3ELw5usQenrAbhkC6+2DT26Wvv8BStVHPJWEB3Y7kb9TL9C4izhnhaOvfapWrAetZAaCrIB9/hn48iIYOWACZVVREOztxx9mGYFt0VCG73pzRTmx//DJk26tSEMNjDNnUnCsEU+n3Le1QVxZBsuvQNDJDRUcScq/pkJcX0PHnk6ovT2QCCfJ0mArKv215GG/QcCdmvLMza28S5F7tgP+4/ntiMOoQUXfbmFtyE28XILY2QUXDEXLXSxVzCv1Ao0pIsTF5548rAh8yikUkFlfR9rcAqc0QCEBWQanNIWRXSPiX1bXAEqT7fOHH5qbf79eoMFBCPjijbemA0GelE0T67SJnJvawcgRYtrfW5OcVDOtWKUaqK4LUZbPl/T0h/Xk4ThSIMeYHxve/7Tr84JvFLHkB+AddA5oV4UiLBHHhhpDhZzF4nqgpxK5R2dmvF0LhMCB8fFLnig8JXieZywuIq/pcFMp+OkMvJ5eFNbySJGQ2BL/cvSbn6ajyMO5yBrUgNnp4YFZ1qJlnUwGtmHQCgGZ/gHolglV0+Ax9sChj05M1az5RzfyoNUgeIWxhZiuZ0VGsfxpgFerqFAN2gb7w2LbIpNma/AN3cga1KL8ZPI72/UgiTJaqNBpItcsK0wNpHTrVwuGvVqLr+83c4CJ7KEpby3/6ui99yi/zv6MpfkFuK6Dm02GUsk/8d7ERLWetHbcVGDDKLqbtmvNXF5S1ssOlv0qvCpHdatcpSdfSxbVb5oi2vki/WSYIooQ6AYFCYDqYJVMyNsXUxTtjbmmDgRBshgRKZoCma4Lga5riUt0c6giF4NmuzD6oN3QB+X5WkFVY+9eXlhEkQ6dpmpI0E+GXB2Ha31bi43qN43g+qIDI3c+porsRWPDEFtSiWMXzp17+fq3/+09ks22dnd3t/0Xwr8AlfeB0c709XMAAAAASUVORK5CYII=";

// src/main.ts
var path8 = __toESM(require("path"));
var IdeatrPlugin = class extends import_obsidian67.Plugin {
  settings;
  localLLMService;
  modelManager;
  pluginContext;
  statusBarItem;
  statusUpdateInterval;
  memoryMonitor;
  unhandledRejectionHandler;
  uncaughtExceptionHandler;
  // Public properties for settings modal access
  get nameVariantService() {
    return this.pluginContext.nameVariantService;
  }
  get errorLogService() {
    return this.pluginContext.errorLogService;
  }
  async onload() {
    await this.loadSettings();
    this.unhandledRejectionHandler = (reason, promise) => {
      console.error("Ideatr: Unhandled Rejection at:", promise, "reason:", reason);
      Logger.error("Unhandled Rejection:", reason);
    };
    process.on("unhandledRejection", this.unhandledRejectionHandler);
    this.uncaughtExceptionHandler = (error) => {
      console.error("Ideatr: Uncaught Exception:", error);
      Logger.error("Uncaught Exception:", error);
    };
    process.on("uncaughtException", this.uncaughtExceptionHandler);
    await Logger.initialize(this.app, this.settings.debugMode);
    this.modelManager = new ModelManager();
    if (isFirstLaunch(this.settings)) {
      setTimeout(() => {
        new FirstLaunchSetupModal(
          this.app,
          this.modelManager,
          this.settings,
          async () => {
            await this.saveSettings();
          }
        ).open();
      }, 100);
    }
    const { context, localLLMService: localLLM } = await ServiceInitializer.initialize(this.app, this, this.settings);
    this.pluginContext = context;
    this.localLLMService = localLLM;
    this.addStatusBarIndicator();
    await this.ensureTutorialsAvailable();
    this.registerView(
      "ideatr-dashboard",
      (leaf) => new DashboardView(
        leaf,
        this.pluginContext.ideaRepository,
        this.pluginContext.clusteringService,
        this.pluginContext.resurfacingService,
        this.pluginContext.projectElevationService,
        this.settings.dashboardItemsPerPage,
        this.settings.dashboardPersistFilters
      )
    );
    this.registerView(
      "ideatr-graph",
      (leaf) => new GraphView(
        leaf,
        this.pluginContext.clusteringService,
        this.pluginContext.graphLayoutService,
        this.pluginContext.ideaRepository,
        this.pluginContext.projectElevationService
      )
    );
    this.addSettingTab(new IdeatrSettingTab(this.app, this));
    Logger.debug("Starting command registration...");
    try {
      if (!this.pluginContext) {
        throw new Error("PluginContext is not initialized");
      }
      if (!this.pluginContext.commandContext) {
        throw new Error("CommandContext is not initialized");
      }
      CommandRegistry.registerAll(this, this.pluginContext.commandContext);
      if (Logger.isDebugEnabled()) {
        const debugMainCallback = async () => {
          console.log("[Ideatr DEBUG MAIN] Command callback invoked!");
          console.log("[Ideatr DEBUG MAIN] Stack trace:", new Error().stack);
          Logger.info("DEBUG MAIN: Command executed successfully");
          new import_obsidian67.Notice("Ideatr Debug (Main) command executed - check console");
        };
        Logger.debug("Debug main callback type:", typeof debugMainCallback);
        this.addCommand({
          id: "ideatr-debug-main",
          name: "Ideatr Debug (Main)",
          callback: debugMainCallback
        });
        Logger.debug("Registered debug command directly in main.ts");
      }
      (0, import_obsidian67.addIcon)(IDEATR_ICON_ID, createPNGIconSVG(`data:image/png;base64,${PURPLE_ICON_BASE64}`));
      (0, import_obsidian67.addIcon)(IDEATR_ICON_GREEN, createPNGIconSVG(`data:image/png;base64,${GREEN_ICON_BASE64}`));
      (0, import_obsidian67.addIcon)(IDEATR_ICON_YELLOW, createPNGIconSVG(`data:image/png;base64,${YELLOW_ICON_BASE64}`));
      (0, import_obsidian67.addIcon)(IDEATR_ICON_RED, createPNGIconSVG(`data:image/png;base64,${RED_ICON_BASE64}`));
      this.addRibbonIcon(IDEATR_ICON_ID, "Capture Idea", () => {
        this.openCaptureModal();
      });
      this.addCommand({
        id: "force-kill-server",
        name: "Force Kill AI Server",
        callback: () => {
          if (this.localLLMService) {
            this.localLLMService.stopServer();
            new import_obsidian67.Notice("AI Server stopped (Force Kill)");
          }
        }
      });
      this.addCommand({
        id: "show-memory-report",
        name: "Show Memory Report",
        callback: () => {
          if (this.memoryMonitor) {
            const report = this.memoryMonitor.getReport();
            console.log(report);
            const usage = this.memoryMonitor.getCurrentUsage();
            if (usage) {
              new import_obsidian67.Notice(`Heap: ${usage.heapUsedMB.toFixed(0)}MB | Ext: ${usage.externalMB.toFixed(0)}MB`);
            } else {
              new import_obsidian67.Notice("Memory report logged to console");
            }
          } else {
            new import_obsidian67.Notice("Memory monitoring is not enabled (requires Debug Mode)");
          }
        }
      });
      Logger.debug("All commands registered successfully");
      console.log("[Ideatr] Commands registered successfully");
    } catch (error) {
      console.error("[Ideatr] Error registering commands:", error);
      console.error("[Ideatr] Error details:", error instanceof Error ? error.stack : error);
      new import_obsidian67.Notice("Failed to register Ideatr commands. Check console for details.");
    }
    if (this.settings.debugMode) {
      this.memoryMonitor = new MemoryMonitor();
      this.memoryMonitor.startMonitoring(6e4);
      Logger.debug("Memory monitoring started");
    }
  }
  openCaptureModal() {
    new CaptureModal(
      this.app,
      this.pluginContext.fileManager,
      this.pluginContext.classificationService,
      this.pluginContext.duplicateDetector,
      this.settings,
      this.pluginContext.domainService,
      this.pluginContext.webSearchService,
      this.pluginContext.nameVariantService,
      this.pluginContext.llmService
    ).open();
  }
  /**
   * Ensure the LLM service is ready (abstracts away implementation details)
   * This works for both local and cloud providers
   */
  async ensureLLMReady() {
    if (this.pluginContext.llmService?.ensureReady) {
      await this.pluginContext.llmService.ensureReady();
    }
  }
  onunload() {
    Logger.debug("Unloading Ideatr plugin");
    if (this.unhandledRejectionHandler) {
      process.removeListener("unhandledRejection", this.unhandledRejectionHandler);
      this.unhandledRejectionHandler = void 0;
    }
    if (this.uncaughtExceptionHandler) {
      process.removeListener("uncaughtException", this.uncaughtExceptionHandler);
      this.uncaughtExceptionHandler = void 0;
    }
    if (this.statusUpdateInterval) {
      clearInterval(this.statusUpdateInterval);
      this.statusUpdateInterval = void 0;
    }
    if (this.memoryMonitor) {
      Logger.debug("Memory report before unload:");
      Logger.debug(this.memoryMonitor.getReport());
      this.memoryMonitor.stopMonitoring();
      this.memoryMonitor = void 0;
    }
    if (this.pluginContext?.llmService) {
      this.pluginContext.llmService.cleanup?.();
    }
    LlamaService.destroyInstance();
    Logger.debug("Ideatr plugin unloaded successfully");
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    if (loadedData && "cloudApiKey" in loadedData && loadedData.cloudApiKey && (!this.settings.cloudApiKeys || Object.values(this.settings.cloudApiKeys).every((key) => !key))) {
      const legacyKey = loadedData.cloudApiKey;
      const provider = loadedData.cloudProvider || "none";
      if (legacyKey && provider !== "none" && provider !== "custom") {
        if (!this.settings.cloudApiKeys) {
          this.settings.cloudApiKeys = {
            anthropic: "",
            openai: "",
            gemini: "",
            groq: "",
            openrouter: ""
          };
        }
        if (provider === "anthropic" || provider === "openai" || provider === "gemini" || provider === "groq" || provider === "openrouter") {
          this.settings.cloudApiKeys[provider] = legacyKey;
        }
        await this.saveSettings();
      }
    }
    if (!this.settings.cloudApiKeys) {
      this.settings.cloudApiKeys = {
        anthropic: "",
        openai: "",
        gemini: "",
        groq: "",
        openrouter: ""
      };
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.localLLMService) {
      this.localLLMService.updateSettings(this.settings);
    }
  }
  /**
   * Add status indicator to the status bar
   */
  addStatusBarIndicator() {
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBarIndicator();
    this.statusUpdateInterval = window.setInterval(() => {
      this.updateStatusBarIndicator();
    }, 5e3);
  }
  /**
   * Update the status bar indicator with current model status
   */
  updateStatusBarIndicator() {
    if (!this.statusBarItem)
      return;
    this.statusBarItem.innerHTML = "";
    const statusIndicator = createModelStatusIndicator(
      this.pluginContext.llmService,
      this.settings,
      this.app
    );
    this.statusBarItem.appendChild(statusIndicator);
  }
  /**
   * Ensure tutorials are available in the vault by copying from plugin directory if needed
   */
  async ensureTutorialsAvailable() {
    try {
      const vaultBasePath = this.app.vault.adapter.basePath || this.app.vault.configDir;
      const configDir = path8.isAbsolute(this.app.vault.configDir) ? this.app.vault.configDir : path8.join(vaultBasePath, this.app.vault.configDir);
      const pluginDir = path8.resolve(path8.join(configDir, "plugins", this.manifest.id));
      const tutorialManager = new TutorialManager(this.app, pluginDir);
      const tutorialsInVault = await tutorialManager.tutorialsExistInVault();
      if (!tutorialsInVault) {
        const bundledAvailable = await tutorialManager.bundledTutorialsAvailable();
        if (bundledAvailable) {
          Logger.info("Tutorials not found in vault, copying from plugin directory...");
          await tutorialManager.resetTutorials();
        } else {
          Logger.warn("Tutorial files not found in plugin directory. They may need to be manually restored.");
        }
      }
    } catch (error) {
      Logger.warn("Error ensuring tutorials are available:", error);
    }
  }
};
/*! Bundled license information:

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@google/generative-ai/dist/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
