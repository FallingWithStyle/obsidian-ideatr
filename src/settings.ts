import { App, PluginSettingTab, Setting, Notice } from 'obsidian';
import type IdeatrPlugin from './main';
import { FirstLaunchSetupModal } from './views/FirstLaunchSetupModal';
import { ModelManager } from './services/ModelManager';
import { ProviderFactory } from './services/providers/ProviderFactory';
import type { CloudProviderType } from './types/llm-provider';
import { FeatureRequestModal } from './views/FeatureRequestModal';

export interface IdeatrSettings {
    llmProvider: 'llama' | 'anthropic' | 'openai' | 'gemini' | 'groq' | 'openrouter' | 'custom' | 'none';
    llamaServerUrl: string; // Keep for backward compatibility or external server
    llamaBinaryPath: string;
    modelPath: string;
    llamaServerPort: number;
    concurrency: number;
    llmTimeout: number;
    autoClassify: boolean;

    // Domain checking settings
    enableDomainCheck: boolean;
    autoCheckDomains: boolean;
    enableProspectr: boolean; // Feature flag to show/hide Prospectr references
    prospectrUrl: string;
    domainCheckTimeout: number; // milliseconds

    // Web search settings
    enableWebSearch: boolean;
    autoSearchExistence: boolean;
    webSearchProvider: 'google' | 'duckduckgo' | 'none';
    googleSearchApiKey: string;
    googleSearchEngineId: string;
    webSearchTimeout: number; // milliseconds
    maxSearchResults: number; // 1-10, default 5

    // Name variant generation
    enableNameVariants: boolean;
    autoGenerateVariants: boolean; // Auto-generate on capture vs manual
    maxVariants: number; // 5-10, default 8
    useLLMForNameExtraction: boolean; // Use LLM for intelligent name extraction
    variantCacheMaxSize: number; // Maximum cache entries (0 = unlimited)
    variantCachePersist: boolean; // Persist cache to disk

    // Scaffold generation
    enableScaffolds: boolean;
    scaffoldDefaultAction: 'append' | 'new-note'; // Append to current or create new

    // Dashboard settings
    dashboardDefaultView: 'table' | 'graph' | 'inbox';
    dashboardItemsPerPage: number;
    dashboardAutoRefresh: boolean;
    dashboardPersistFilters: boolean; // Persist filter state across sessions

    // Clustering settings
    enableClustering: boolean;
    clusteringAlgorithm: 'hierarchical' | 'kmeans' | 'dbscan';
    maxClusters: number; // 0 = auto-determine
    clusterColorScheme: 'category' | 'age' | 'random';
    clusteringSimilarityThreshold: number; // 0-1, default 0.3

    // Resurfacing settings
    enableResurfacing: boolean;
    resurfacingThresholdDays: number; // Default 7
    resurfacingFrequency: 'daily' | 'weekly' | 'manual';
    resurfacingTime: string; // HH:MM format, if scheduled (e.g., "09:00")
    autoGenerateDigest: boolean; // Auto-generate on schedule (v2)
    digestIncludeSummary: boolean; // Include summary in digest
    digestMaxIdeas: number; // Max ideas per digest (0 = unlimited)

    // Project elevation settings
    enableElevation: boolean; // Enable project elevation feature
    elevationProjectsDirectory: string; // Directory for elevated projects (default: "Projects")
    elevationCreateDevraMetadata: boolean; // Create Devra metadata file on elevation
    elevationDefaultFolders: string; // Comma-separated list of default folders (e.g., "docs,notes,assets")

    // AI Model Management
    setupCompleted: boolean; // First-launch setup completed
    modelDownloaded: boolean; // Model has been downloaded
    keepModelLoaded: boolean; // Keep model loaded in memory
    preloadOnStartup: boolean; // Preload model on Obsidian startup

    // Cloud AI
    preferCloud: boolean; // Prefer cloud AI over local
    cloudProvider: 'anthropic' | 'openai' | 'gemini' | 'groq' | 'openrouter' | 'custom' | 'none';
    cloudApiKey: string; // API key for cloud provider
    customEndpointUrl: string; // Custom endpoint URL (for self-hosted)
    openRouterModel: string; // OpenRouter model selection

    // File Organization
    moveArchivedToFolder: boolean; // Move archived ideas to Ideas/Archived/ directory

    // Error Logging (for bug reports)
    errorLoggingEnabled: boolean; // Enable error logging
    errorLogMaxEntries: number; // Maximum number of error log entries
    errorLogRetentionDays: number; // Days to retain error logs

    // Debug Mode (for developers)
    debugMode: boolean; // Enable debug logging (gates console.log/info/warn)
}

export const DEFAULT_SETTINGS: IdeatrSettings = {
    llmProvider: 'llama',
    llamaServerUrl: 'http://127.0.0.1:8080',
    llamaBinaryPath: '',
    modelPath: '',
    llamaServerPort: 8080,
    concurrency: 1,
    llmTimeout: 10000, // Increased default for local inference
    autoClassify: true,

    // Domain checking
    enableDomainCheck: true,
    autoCheckDomains: false, // Manual by default (user can enable auto)
    enableProspectr: false, // Hidden by default until Prospectr is live
    prospectrUrl: 'http://localhost:3000',
    domainCheckTimeout: 10000, // 10 seconds

    // Web search
    enableWebSearch: true,
    autoSearchExistence: false, // Manual by default
    webSearchProvider: 'google',
    googleSearchApiKey: '',
    googleSearchEngineId: '',
    webSearchTimeout: 15000, // 15 seconds
    maxSearchResults: 5,

    // Name variant generation
    enableNameVariants: true,
    autoGenerateVariants: false, // Manual by default (user can enable auto)
    maxVariants: 8,
    useLLMForNameExtraction: false, // Rule-based by default (user can enable LLM)
    variantCacheMaxSize: 100, // Default: 100 entries
    variantCachePersist: true, // Persist cache by default

    // Scaffold generation
    enableScaffolds: true,
    scaffoldDefaultAction: 'append', // Append to current note by default

    // Dashboard
    dashboardDefaultView: 'table',
    dashboardItemsPerPage: 50,
    dashboardAutoRefresh: true,
    dashboardPersistFilters: true,

    // Clustering
    enableClustering: true,
    clusteringAlgorithm: 'hierarchical',
    maxClusters: 0, // Auto
    clusterColorScheme: 'category',
    clusteringSimilarityThreshold: 0.3,

    // Resurfacing
    enableResurfacing: true,
    resurfacingThresholdDays: 7,
    resurfacingFrequency: 'manual', // Manual for v1
    resurfacingTime: '09:00',
    autoGenerateDigest: false, // Manual for v1
    digestIncludeSummary: true,
    digestMaxIdeas: 0, // Unlimited

    // Project elevation
    enableElevation: true,
    elevationProjectsDirectory: 'Projects',
    elevationCreateDevraMetadata: true, // Create .devra.json metadata file
    elevationDefaultFolders: 'docs,notes,assets', // Default folders to create

    // AI Model Management
    setupCompleted: false,
    modelDownloaded: false,
    keepModelLoaded: false,
    preloadOnStartup: false,

    // Cloud AI
    preferCloud: false,
    cloudProvider: 'none',
    cloudApiKey: '',
    customEndpointUrl: '',
    openRouterModel: '',

    // File Organization
    moveArchivedToFolder: false, // Default: don't move files, just update status

    // Error Logging
    errorLoggingEnabled: true, // Default: enabled
    errorLogMaxEntries: 50, // Default: 50 entries
    errorLogRetentionDays: 7, // Default: 7 days

    // Debug Mode (for developers)
    debugMode: false // Default: false (only enabled for developer vaults)
};

export class IdeatrSettingTab extends PluginSettingTab {
    plugin: IdeatrPlugin;

    constructor(app: App, plugin: IdeatrPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;

        containerEl.empty();

        containerEl.createEl('h2', { text: 'Ideatr Project Internal Settings' });

        // AI Configuration Section
        containerEl.createEl('h2', { text: 'AI Configuration' });

        // Local AI settings
        new Setting(containerEl)
            .setName('Local AI')
            .setDesc('Use local Llama model for classification (offline, free)')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.llmProvider === 'llama')
                .onChange(async (value) => {
                    this.plugin.settings.llmProvider = value ? 'llama' : 'none';
                    await this.plugin.saveSettings();
                    this.display(); // Refresh to show/hide related settings
                }));

        // Model download status
        if (this.plugin.settings.llmProvider === 'llama') {
            const modelStatus = this.plugin.settings.modelDownloaded 
                ? `Model downloaded (${this.plugin.settings.modelPath || 'configured'})`
                : 'Model not downloaded';
            
            new Setting(containerEl)
                .setName('Model Status')
                .setDesc(modelStatus)
                .setDisabled(true);

            new Setting(containerEl)
                .setName('Keep model loaded')
                .setDesc('Keep the AI model loaded in memory (uses ~4GB RAM, but faster responses)')
                .addToggle(toggle => toggle
                    .setValue(this.plugin.settings.keepModelLoaded)
                    .onChange(async (value) => {
                        this.plugin.settings.keepModelLoaded = value;
                        await this.plugin.saveSettings();
                    }));

            new Setting(containerEl)
                .setName('Preload on startup')
                .setDesc('Automatically load the AI model when Obsidian starts')
                .addToggle(toggle => toggle
                    .setValue(this.plugin.settings.preloadOnStartup)
                    .onChange(async (value) => {
                        this.plugin.settings.preloadOnStartup = value;
                        await this.plugin.saveSettings();
                    }));

            // Manual start button (works for both local and cloud)
            new Setting(containerEl)
                .setName('Ensure LLM Ready')
                .setDesc('Manually ensure the AI model is ready now. Not needed in most cases (model auto-starts when you use AI features), but helpful if: the model stopped unexpectedly, you want to test your configuration, or you prefer to preload before using features.')
                .addButton(button => button
                    .setButtonText('Ensure Ready')
                    .setCta()
                    .onClick(async () => {
                        button.setDisabled(true);
                        button.setButtonText('Preparing...');
                        try {
                            await this.plugin.ensureLLMReady();
                            new Notice('AI model is ready');
                            // Reset button after a delay
                            setTimeout(() => {
                                button.setDisabled(false);
                                button.setButtonText('Ensure Ready');
                            }, 2000);
                        } catch (error) {
                            new Notice('Failed to prepare model. Check console for details.');
                            button.setDisabled(false);
                            button.setButtonText('Ensure Ready');
                        }
                    }));

            // Setup AI button (if not configured)
            if (!this.plugin.settings.setupCompleted) {
                new Setting(containerEl)
                    .setName('Setup AI')
                    .setDesc('Configure AI model download or API key')
                    .addButton(button => button
                        .setButtonText('Setup AI')
                        .setCta()
                        .onClick(() => {
                            // Open first-launch setup modal
                            const modelManager = new ModelManager();
                            new FirstLaunchSetupModal(
                                this.app,
                                modelManager,
                                this.plugin.settings,
                                async () => {
                                    // Save settings after setup completion
                                    await this.plugin.saveSettings();
                                    // Refresh settings UI to show updated state
                                    this.display();
                                }
                            ).open();
                        }));
            }
        }

        // Cloud AI settings
        containerEl.createEl('h3', { text: 'Cloud AI' });

        new Setting(containerEl)
            .setName('Enable Cloud AI')
            .setDesc('Use cloud AI providers for better quality and faster responses (requires API key)')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.cloudProvider !== 'none' && this.plugin.settings.cloudApiKey.length > 0)
                .onChange(async (value) => {
                    if (value) {
                        // Enable cloud AI - will need to select provider
                        this.plugin.settings.preferCloud = true;
                    } else {
                        this.plugin.settings.cloudProvider = 'none';
                        this.plugin.settings.cloudApiKey = '';
                        this.plugin.settings.preferCloud = false;
                    }
                    await this.plugin.saveSettings();
                    this.display(); // Refresh to show/hide provider settings
                }));

        if (this.plugin.settings.cloudProvider !== 'none' || this.plugin.settings.cloudApiKey.length > 0) {
            new Setting(containerEl)
                .setName('Cloud Provider')
                .setDesc('Select the cloud AI provider')
                .addDropdown(dropdown => {
                    dropdown
                        .addOption('anthropic', 'Anthropic (Claude 3.5 Haiku)')
                        .addOption('openai', 'OpenAI (GPT-4o Mini)')
                        .addOption('gemini', 'Google Gemini (Gemini 1.5 Flash)')
                        .addOption('groq', 'Groq (Llama 3.3 70B)')
                        .addOption('openrouter', 'OpenRouter (Multiple Models)')
                        .addOption('custom', 'Custom Endpoint (Ollama/LM Studio)')
                        .addOption('none', 'None')
                        .setValue(this.plugin.settings.cloudProvider === 'none' ? 'none' : this.plugin.settings.cloudProvider)
                        .onChange(async (value) => {
                            this.plugin.settings.cloudProvider = value as any;
                            if (value === 'none') {
                                this.plugin.settings.cloudApiKey = '';
                            }
                            await this.plugin.saveSettings();
                            this.display(); // Refresh to show provider-specific settings
                        });
                });

            if (this.plugin.settings.cloudProvider !== 'none') {
                // API Key field (for most providers)
                if (this.plugin.settings.cloudProvider !== 'custom') {
                    const providerNames: Record<string, string> = {
                        'anthropic': 'Anthropic',
                        'openai': 'OpenAI',
                        'gemini': 'Google Gemini',
                        'groq': 'Groq',
                        'openrouter': 'OpenRouter'
                    };
                    const apiKeyUrls: Record<string, string> = {
                        'anthropic': 'https://console.anthropic.com/',
                        'openai': 'https://platform.openai.com/api-keys',
                        'gemini': 'https://makersuite.google.com/app/apikey',
                        'groq': 'https://console.groq.com/keys',
                        'openrouter': 'https://openrouter.ai/keys'
                    };

                    new Setting(containerEl)
                        .setName('API Key')
                        .setDesc(`Enter your ${providerNames[this.plugin.settings.cloudProvider] || 'provider'} API key`)
                        .addText(text => {
                            text.setPlaceholder('sk-...')
                                .setValue(this.plugin.settings.cloudApiKey);
                            text.inputEl.setAttribute('type', 'password');
                            text.onChange(async (value: string) => {
                                this.plugin.settings.cloudApiKey = value;
                                await this.plugin.saveSettings();
                            });
                        });

                    // Help text with link to API key registration
                    const helpText = containerEl.createDiv('setting-item-description');
                    helpText.style.marginTop = '5px';
                    const providerName = providerNames[this.plugin.settings.cloudProvider] || 'provider';
                    const apiKeyUrl = apiKeyUrls[this.plugin.settings.cloudProvider] || '#';
                    helpText.innerHTML = `<a href="${apiKeyUrl}" target="_blank">Get your ${providerName} API key</a>`;

                    // Cost estimate display
                    const costEstimates: Record<string, string> = {
                        'anthropic': '~$0.002 per idea (Claude 3.5 Haiku)',
                        'openai': '~$0.001 per idea (GPT-4o Mini)',
                        'gemini': '~$0.0005 per idea (Gemini 1.5 Flash)',
                        'groq': 'Free (Llama 3.3 70B)',
                        'openrouter': 'Varies by model (see OpenRouter pricing)'
                    };
                    const costEstimate = costEstimates[this.plugin.settings.cloudProvider] || 'Varies';
                    const costText = containerEl.createDiv('setting-item-description');
                    costText.style.marginTop = '5px';
                    costText.style.color = 'var(--text-muted)';
                    costText.textContent = `Cost estimate: ${costEstimate}`;

                    // Test Connection button
                    new Setting(containerEl)
                        .setName('Test Connection')
                        .setDesc('Verify your API key is valid')
                        .addButton(button => button
                            .setButtonText('Test Connection')
                            .onClick(async () => {
                                const apiKey = this.plugin.settings.cloudApiKey.trim();
                                if (!apiKey) {
                                    new Notice('Please enter an API key first');
                                    return;
                                }

                                button.setButtonText('Testing...');
                                button.setDisabled(true);

                                try {
                                    // Create provider instance
                                    const provider = ProviderFactory.createProvider(
                                        this.plugin.settings.cloudProvider as CloudProviderType,
                                        apiKey,
                                        {
                                            openRouterModel: this.plugin.settings.openRouterModel,
                                            customEndpointUrl: this.plugin.settings.customEndpointUrl
                                        }
                                    );

                                    // Test authentication
                                    const authResult = await provider.authenticate(apiKey);
                                    if (!authResult) {
                                        new Notice('Authentication failed: Invalid API key format');
                                        return;
                                    }

                                    // Try a simple classification test
                                    const testResult = await provider.classify('Test idea for connection verification');
                                    
                                    if (testResult && (testResult.category || testResult.tags.length > 0)) {
                                        new Notice(`✓ Connection successful! Provider: ${provider.name}`);
                                    } else {
                                        new Notice('Connection test completed, but got unexpected response');
                                    }
                                } catch (error) {
                                    console.error('Connection test failed:', error);
                                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                                    new Notice(`Connection failed: ${errorMessage}`);
                                } finally {
                                    button.setButtonText('Test Connection');
                                    button.setDisabled(false);
                                }
                            }));
                }

                // OpenRouter model selection
                if (this.plugin.settings.cloudProvider === 'openrouter') {
                    new Setting(containerEl)
                        .setName('Model')
                        .setDesc('Select the model to use via OpenRouter')
                        .addText(text => text
                            .setPlaceholder('openai/gpt-4o-mini')
                            .setValue(this.plugin.settings.openRouterModel || 'openai/gpt-4o-mini')
                            .onChange(async (value) => {
                                this.plugin.settings.openRouterModel = value;
                                await this.plugin.saveSettings();
                            }));
                }

                // Custom endpoint URL
                if (this.plugin.settings.cloudProvider === 'custom') {
                    new Setting(containerEl)
                        .setName('Endpoint URL')
                        .setDesc('Enter your custom endpoint URL (e.g., http://localhost:11434/api/chat for Ollama)')
                        .addText(text => text
                            .setPlaceholder('http://localhost:11434/api/chat')
                            .setValue(this.plugin.settings.customEndpointUrl || '')
                            .onChange(async (value) => {
                                this.plugin.settings.customEndpointUrl = value;
                                await this.plugin.saveSettings();
                            }));

                    // Cost estimate for custom endpoint
                    const customCostText = containerEl.createDiv('setting-item-description');
                    customCostText.style.marginTop = '5px';
                    customCostText.style.color = 'var(--text-muted)';
                    customCostText.textContent = 'Cost estimate: Free (self-hosted)';

                    // Test Connection button for custom endpoint
                    new Setting(containerEl)
                        .setName('Test Connection')
                        .setDesc('Verify your custom endpoint is accessible')
                        .addButton(button => button
                            .setButtonText('Test Connection')
                            .onClick(async () => {
                                const endpointUrl = this.plugin.settings.customEndpointUrl.trim();
                                if (!endpointUrl) {
                                    new Notice('Please enter an endpoint URL first');
                                    return;
                                }

                                button.setButtonText('Testing...');
                                button.setDisabled(true);

                                try {
                                    // Create provider instance
                                    const provider = ProviderFactory.createProvider(
                                        'custom' as CloudProviderType,
                                        '', // No API key for custom
                                        {
                                            customEndpointUrl: endpointUrl
                                        }
                                    );

                                    // Test authentication (URL validation)
                                    const authResult = await provider.authenticate(endpointUrl);
                                    if (!authResult) {
                                        new Notice('Authentication failed: Invalid endpoint URL');
                                        return;
                                    }

                                    // Try a simple classification test
                                    const testResult = await provider.classify('Test idea for connection verification');
                                    
                                    if (testResult && (testResult.category || testResult.tags.length > 0)) {
                                        new Notice(`✓ Connection successful! Provider: ${provider.name}`);
                                    } else {
                                        new Notice('Connection test completed, but got unexpected response');
                                    }
                                } catch (error) {
                                    console.error('Connection test failed:', error);
                                    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                                    new Notice(`Connection failed: ${errorMessage}`);
                                } finally {
                                    button.setButtonText('Test Connection');
                                    button.setDisabled(false);
                                }
                            }));
                }

                // Test Connection button
                new Setting(containerEl)
                    .setName('Test Connection')
                    .setDesc('Test your API key connection')
                    .addButton(button => button
                        .setButtonText('Test')
                        .onClick(async () => {
                            // This will be implemented to test the API key
                            new Notice('Testing connection...');
                            // TODO: Implement test connection
                        }));

                // Cost estimate
                const costEstimate = containerEl.createDiv('setting-item-description');
                costEstimate.style.marginTop = '5px';
                costEstimate.style.padding = '10px';
                costEstimate.style.backgroundColor = 'var(--background-secondary)';
                costEstimate.style.borderRadius = '4px';
                const costPerIdea = this.plugin.settings.cloudProvider === 'anthropic' ? '$0.002' : '$0.001';
                costEstimate.innerHTML = `<strong>Cost estimate:</strong> ~${costPerIdea} per idea classification`;

                // Prefer Cloud toggle
                new Setting(containerEl)
                    .setName('Prefer Cloud AI')
                    .setDesc('Use cloud AI when available, fallback to local AI on failure')
                    .addToggle(toggle => toggle
                        .setValue(this.plugin.settings.preferCloud)
                        .onChange(async (value) => {
                            this.plugin.settings.preferCloud = value;
                            await this.plugin.saveSettings();
                        }));
            }
        }

        // Legacy LLM Provider setting (for backward compatibility)
        containerEl.createEl('h3', { text: 'Legacy Settings' });
        new Setting(containerEl)
            .setName('LLM Provider (Legacy)')
            .setDesc('Select the AI provider for classification (legacy setting)')
            .addDropdown(dropdown => dropdown
                .addOption('llama', 'Llama.cpp (Local)')
                .addOption('none', 'None (Disable AI)')
                .setValue(this.plugin.settings.llmProvider)
                .onChange(async (value) => {
                    this.plugin.settings.llmProvider = value as 'llama' | 'none';
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Llama Server URL')
            .setDesc('URL of your local Llama.cpp server (e.g., http://127.0.0.1:8080)')
            .addText(text => text
                .setPlaceholder('http://127.0.0.1:8080')
                .setValue(this.plugin.settings.llamaServerUrl)
                .onChange(async (value) => {
                    this.plugin.settings.llamaServerUrl = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Llama Server Binary')
            .setDesc('Absolute path to the llama-server executable')
            .addText(text => text
                .setPlaceholder('/path/to/llama-server')
                .setValue(this.plugin.settings.llamaBinaryPath)
                .onChange(async (value) => {
                    this.plugin.settings.llamaBinaryPath = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Model Path')
            .setDesc('Absolute path to the .gguf model file')
            .addText(text => text
                .setPlaceholder('/path/to/model.gguf')
                .setValue(this.plugin.settings.modelPath)
                .onChange(async (value) => {
                    this.plugin.settings.modelPath = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Server Port')
            .setDesc('Port to run the local server on')
            .addText(text => text
                .setPlaceholder('8080')
                .setValue(String(this.plugin.settings.llamaServerPort))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue)) {
                        this.plugin.settings.llamaServerPort = numValue;
                        // Update URL automatically
                        this.plugin.settings.llamaServerUrl = `http://127.0.0.1:${numValue}`;
                        await this.plugin.saveSettings();
                    }
                }));

        new Setting(containerEl)
            .setName('API Timeout (ms)')
            .setDesc('Maximum time to wait for AI response')
            .addText(text => text
                .setPlaceholder('5000')
                .setValue(String(this.plugin.settings.llmTimeout))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue)) {
                        this.plugin.settings.llmTimeout = numValue;
                        await this.plugin.saveSettings();
                    }
                }));

        new Setting(containerEl)
            .setName('Auto-Classify')
            .setDesc('Automatically classify ideas upon capture')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoClassify)
                .onChange(async (value) => {
                    this.plugin.settings.autoClassify = value;
                    await this.plugin.saveSettings();
                }));

        // Validation Tools Section
        containerEl.createEl('h2', { text: 'Validation Tools' });

        // Domain checking settings
        new Setting(containerEl)
            .setName('Enable Domain Checking')
            .setDesc('Check domain availability for extracted domains')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.enableDomainCheck)
                .onChange(async (value) => {
                    this.plugin.settings.enableDomainCheck = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Auto-check domains on capture')
            .setDesc('Automatically check domains when capturing ideas')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoCheckDomains)
                .onChange(async (value) => {
                    this.plugin.settings.autoCheckDomains = value;
                    await this.plugin.saveSettings();
                }));

        // Only show Prospectr settings if feature flag is enabled
        if (this.plugin.settings.enableProspectr) {
            new Setting(containerEl)
                .setName('Prospectr URL')
                .setDesc('URL of the Prospectr service for domain checking')
                .addText(text => text
                    .setPlaceholder('http://localhost:3000')
                    .setValue(this.plugin.settings.prospectrUrl)
                    .onChange(async (value) => {
                        this.plugin.settings.prospectrUrl = value;
                        await this.plugin.saveSettings();
                    }));
        }

        new Setting(containerEl)
            .setName('Domain check timeout (ms)')
            .setDesc('Maximum time to wait for domain check response')
            .addText(text => text
                .setPlaceholder('10000')
                .setValue(String(this.plugin.settings.domainCheckTimeout))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue > 0) {
                        this.plugin.settings.domainCheckTimeout = numValue;
                        await this.plugin.saveSettings();
                    }
                }));

        // Web search settings
        new Setting(containerEl)
            .setName('Enable Web Search')
            .setDesc('Search for similar ideas/products/services on the web')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.enableWebSearch)
                .onChange(async (value) => {
                    this.plugin.settings.enableWebSearch = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Auto-search existence on capture')
            .setDesc('Automatically search for similar items when capturing ideas')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoSearchExistence)
                .onChange(async (value) => {
                    this.plugin.settings.autoSearchExistence = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Web Search Provider')
            .setDesc('Select the web search provider to use')
            .addDropdown(dropdown => dropdown
                .addOption('google', 'Google')
                .addOption('duckduckgo', 'DuckDuckGo')
                .addOption('none', 'None')
                .setValue(this.plugin.settings.webSearchProvider)
                .onChange(async (value) => {
                    this.plugin.settings.webSearchProvider = value as 'google' | 'duckduckgo' | 'none';
                    await this.plugin.saveSettings();
                    // Refresh settings UI to show/hide Google-specific fields
                    this.display();
                }));

        // Google-specific settings (shown only if Google is selected)
        if (this.plugin.settings.webSearchProvider === 'google') {
            new Setting(containerEl)
                .setName('Google API Key')
                .setDesc('Google Custom Search API key')
                .addText(text => text
                    .setPlaceholder('Enter your Google API key')
                    .setValue(this.plugin.settings.googleSearchApiKey)
                    .onChange(async (value) => {
                        this.plugin.settings.googleSearchApiKey = value;
                        await this.plugin.saveSettings();
                    }));

            new Setting(containerEl)
                .setName('Google Search Engine ID')
                .setDesc('Google Custom Search Engine ID (CSE ID)')
                .addText(text => text
                    .setPlaceholder('Enter your Google CSE ID')
                    .setValue(this.plugin.settings.googleSearchEngineId)
                    .onChange(async (value) => {
                        this.plugin.settings.googleSearchEngineId = value;
                        await this.plugin.saveSettings();
                    }));
        }

        new Setting(containerEl)
            .setName('Web search timeout (ms)')
            .setDesc('Maximum time to wait for web search response')
            .addText(text => text
                .setPlaceholder('15000')
                .setValue(String(this.plugin.settings.webSearchTimeout))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue > 0) {
                        this.plugin.settings.webSearchTimeout = numValue;
                        await this.plugin.saveSettings();
                    }
                }));

        new Setting(containerEl)
            .setName('Max search results (1-10)')
            .setDesc('Maximum number of search results to store in frontmatter')
            .addText(text => text
                .setPlaceholder('5')
                .setValue(String(this.plugin.settings.maxSearchResults))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue >= 1 && numValue <= 10) {
                        this.plugin.settings.maxSearchResults = numValue;
                        await this.plugin.saveSettings();
                    }
                }));

        // Transformation Tools Section
        containerEl.createEl('h2', { text: 'Transformation Tools' });

        // Name variant generation settings
        new Setting(containerEl)
            .setName('Enable Name Variants')
            .setDesc('Generate name variants for ideas')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.enableNameVariants)
                .onChange(async (value) => {
                    this.plugin.settings.enableNameVariants = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Auto-generate variants on capture')
            .setDesc('Automatically generate name variants when capturing ideas')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoGenerateVariants)
                .onChange(async (value) => {
                    this.plugin.settings.autoGenerateVariants = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Max variants (5-10)')
            .setDesc('Maximum number of name variants to generate')
            .addText(text => text
                .setPlaceholder('8')
                .setValue(String(this.plugin.settings.maxVariants))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue >= 5 && numValue <= 10) {
                        this.plugin.settings.maxVariants = numValue;
                        await this.plugin.saveSettings();
                    }
                }));

        new Setting(containerEl)
            .setName('Use LLM for name extraction')
            .setDesc('Use AI to intelligently extract idea names (more accurate but slower)')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.useLLMForNameExtraction)
                .onChange(async (value) => {
                    this.plugin.settings.useLLMForNameExtraction = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Cache max size')
            .setDesc('Maximum number of cached variants (0 = unlimited)')
            .addText(text => text
                .setPlaceholder('100')
                .setValue(String(this.plugin.settings.variantCacheMaxSize || 0))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue >= 0) {
                        this.plugin.settings.variantCacheMaxSize = numValue;
                        await this.plugin.saveSettings();
                    }
                }));

        new Setting(containerEl)
            .setName('Persist cache to disk')
            .setDesc('Save variant cache to disk (survives plugin reloads)')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.variantCachePersist)
                .onChange(async (value) => {
                    this.plugin.settings.variantCachePersist = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Clear variant cache')
            .setDesc('Clear all cached name variants')
            .addButton(button => button
                .setButtonText('Clear Cache')
                .setCta()
                .onClick(async () => {
                    if (this.plugin.nameVariantService) {
                        this.plugin.nameVariantService.clearCache();
                        new Notice('Variant cache cleared');
                    }
                }));

        // Scaffold generation settings
        new Setting(containerEl)
            .setName('Enable Scaffolds')
            .setDesc('Generate scaffold templates for ideas')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.enableScaffolds)
                .onChange(async (value) => {
                    this.plugin.settings.enableScaffolds = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Scaffold default action')
            .setDesc('Default action when generating scaffold: append to current note or create new note')
            .addDropdown(dropdown => dropdown
                .addOption('append', 'Append to current note')
                .addOption('new-note', 'Create new note')
                .setValue(this.plugin.settings.scaffoldDefaultAction)
                .onChange(async (value) => {
                    this.plugin.settings.scaffoldDefaultAction = value as 'append' | 'new-note';
                    await this.plugin.saveSettings();
                }));

        // Project Elevation Section
        containerEl.createEl('h2', { text: 'Project Elevation' });

        new Setting(containerEl)
            .setName('Enable Project Elevation')
            .setDesc('Allow elevating ideas to full projects')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.enableElevation)
                .onChange(async (value) => {
                    this.plugin.settings.enableElevation = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Projects Directory')
            .setDesc('Directory where elevated projects will be created (relative to vault root)')
            .addText(text => text
                .setPlaceholder('Projects')
                .setValue(this.plugin.settings.elevationProjectsDirectory)
                .onChange(async (value) => {
                    // Sanitize directory name (remove leading/trailing slashes, spaces)
                    const sanitized = value.trim().replace(/^\/+|\/+$/g, '').replace(/\s+/g, '-');
                    this.plugin.settings.elevationProjectsDirectory = sanitized || 'Projects';
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Default Folders')
            .setDesc('Comma-separated list of folders to create in each elevated project (e.g., docs,notes,assets)')
            .addText(text => text
                .setPlaceholder('docs,notes,assets')
                .setValue(this.plugin.settings.elevationDefaultFolders)
                .onChange(async (value) => {
                    // Sanitize: remove spaces, keep only valid folder name characters
                    const sanitized = value
                        .split(',')
                        .map(f => f.trim().replace(/[^a-zA-Z0-9_-]/g, ''))
                        .filter(f => f.length > 0)
                        .join(',');
                    this.plugin.settings.elevationDefaultFolders = sanitized || 'docs,notes,assets';
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('Create Devra Metadata')
            .setDesc('Create .devra.json metadata file for future Devra integration (currently stubbed)')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.elevationCreateDevraMetadata)
                .onChange(async (value) => {
                    this.plugin.settings.elevationCreateDevraMetadata = value;
                    await this.plugin.saveSettings();
                }));

        // Help text for elevation
        const elevationHelp = containerEl.createDiv('setting-item-description');
        elevationHelp.style.marginTop = '10px';
        elevationHelp.style.padding = '10px';
        elevationHelp.style.backgroundColor = 'var(--background-secondary)';
        elevationHelp.style.borderRadius = '4px';
        elevationHelp.innerHTML = `
            <strong>About Project Elevation:</strong><br>
            Elevating an idea moves it from the Ideas/ directory to a project folder structure in ${this.plugin.settings.elevationProjectsDirectory || 'Projects'}/.
            The original idea file becomes the project's README.md, and default folders are created automatically.
            <br><br>
            <strong>Note:</strong> Folder structure customization is planned for v2. Currently, the default structure is used for all projects.
        `;

        // Feedback Section
        containerEl.createEl('h2', { text: 'Feedback & Support' });

        new Setting(containerEl)
            .setName('View existing issues')
            .setDesc('Browse and search existing bug reports and feature requests on GitHub')
            .addButton(button => button
                .setButtonText('View Issues')
                .onClick(() => {
                    window.open('https://github.com/FallingWithStyle/obsidian-ideatr/issues', '_blank');
                }));

        new Setting(containerEl)
            .setName('Submit Feedback')
            .setDesc('Report bugs, suggest features, or report performance issues. Error logs can be included to help diagnose issues.')
            .addButton(button => button
                .setButtonText('Submit Feedback')
                .setCta()
                .onClick(() => {
                    // Get Obsidian version - try multiple methods
                    let obsidianVersion = 'Unknown';
                    try {
                        // @ts-ignore - Obsidian internal API
                        obsidianVersion = this.app.appVersion || this.app.version || 'Unknown';
                    } catch {
                        obsidianVersion = 'Unknown';
                    }

                    const systemInfo: FeatureRequestModal['systemInfo'] = {
                        obsidianVersion,
                        pluginVersion: this.plugin.manifest.version,
                        platform: this.app.isMobile ? 'mobile' : 'desktop',
                        os: navigator.platform || 'Unknown'
                    };

                    const modal = new FeatureRequestModal(
                        this.app,
                        systemInfo,
                        this.plugin.errorLogService
                    );
                    modal.open();
                }));

        // Error Logging Settings
        containerEl.createEl('h3', { text: 'Error Logging' });

        new Setting(containerEl)
            .setName('Enable error logging')
            .setDesc('Collect error logs for bug reports. Logs are stored locally and only sent if you choose to include them.')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.errorLoggingEnabled)
                .onChange(async (value) => {
                    this.plugin.settings.errorLoggingEnabled = value;
                    await this.plugin.saveSettings();
                    // Update error log service settings
                    if (this.plugin.errorLogService) {
                        this.plugin.errorLogService.updateSettings({
                            enabled: value,
                            maxEntries: this.plugin.settings.errorLogMaxEntries,
                            retentionDays: this.plugin.settings.errorLogRetentionDays
                        });
                    }
                }));

        new Setting(containerEl)
            .setName('Maximum log entries')
            .setDesc('Maximum number of error log entries to keep in memory (default: 50)')
            .addText(text => text
                .setPlaceholder('50')
                .setValue(String(this.plugin.settings.errorLogMaxEntries))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue > 0 && numValue <= 500) {
                        this.plugin.settings.errorLogMaxEntries = numValue;
                        await this.plugin.saveSettings();
                        // Update error log service settings
                        if (this.plugin.errorLogService) {
                            this.plugin.errorLogService.updateSettings({
                                enabled: this.plugin.settings.errorLoggingEnabled,
                                maxEntries: numValue,
                                retentionDays: this.plugin.settings.errorLogRetentionDays
                            });
                        }
                    }
                }));

        new Setting(containerEl)
            .setName('Log retention (days)')
            .setDesc('Number of days to retain error logs (default: 7)')
            .addText(text => text
                .setPlaceholder('7')
                .setValue(String(this.plugin.settings.errorLogRetentionDays))
                .onChange(async (value) => {
                    const numValue = Number(value);
                    if (!isNaN(numValue) && numValue > 0 && numValue <= 30) {
                        this.plugin.settings.errorLogRetentionDays = numValue;
                        await this.plugin.saveSettings();
                        // Update error log service settings
                        if (this.plugin.errorLogService) {
                            this.plugin.errorLogService.updateSettings({
                                enabled: this.plugin.settings.errorLoggingEnabled,
                                maxEntries: this.plugin.settings.errorLogMaxEntries,
                                retentionDays: numValue
                            });
                        }
                    }
                }));

        new Setting(containerEl)
            .setName('Clear error logs')
            .setDesc('Clear all stored error logs')
            .addButton(button => button
                .setButtonText('Clear Logs')
                .onClick(() => {
                    if (this.plugin.errorLogService) {
                        this.plugin.errorLogService.clearLogs();
                        new Notice('Error logs cleared');
                    }
                }));
    }
}
