import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ProjectElevationService } from '../../src/services/ProjectElevationService';
import type { Vault, TFile } from 'obsidian';
import type { IdeaFile, IdeaFrontmatter } from '../../src/types/idea';
import type { IdeatrSettings } from '../../src/settings';
import { FrontmatterParser } from '../../src/services/FrontmatterParser';

// Mock Vault API
function createMockVault(): Vault {
    const files = new Map<string, string>();
    const folders = new Set<string>();

    return {
        getAbstractFileByPath: vi.fn((path: string) => {
            if (files.has(path)) {
                return { path, extension: 'md' } as TFile;
            }
            if (folders.has(path)) {
                return { path } as any;
            }
            return null;
        }),
        createFolder: vi.fn(async (path: string) => {
            folders.add(path);
            return { path } as unknown as any;
        }),
        create: vi.fn(async (path: string, content: string) => {
            files.set(path, content);
            return { path, extension: 'md' } as unknown as TFile;
        }),
        read: vi.fn(async (file: TFile) => {
            return files.get(file.path) || '';
        }),
        rename: vi.fn(async (file: TFile, newPath: string) => {
            const content = files.get(file.path);
            if (content) {
                files.delete(file.path);
                files.set(newPath, content);
            }
            return { path: newPath, extension: 'md' } as unknown as TFile;
        }),
        delete: vi.fn(async (file: TFile) => {
            files.delete(file.path);
        }),
        adapter: {
            write: vi.fn(async (path: string, content: string) => {
                files.set(path, content);
            }),
            rmdir: vi.fn(async (path: string, recursive: boolean) => {
                folders.delete(path);
            })
        } as any,
        process: vi.fn(async (file: TFile, processor: (content: string) => string) => {
            const currentContent = files.get(file.path) || '';
            const newContent = processor(currentContent);
            files.set(file.path, newContent);
        })
    } as unknown as Vault;
}

function createMockIdeaFile(name: string, body: string = 'Test idea content'): IdeaFile {
    return {
        frontmatter: {
            type: 'idea',
            status: 'captured',
            created: '2025-11-28',
            category: 'app',
            tags: ['test'],
            related: [],
            domains: [],
            'existence-check': []
        },
        body,
        filename: name
    };
}

// Mock settings
function createMockSettings(): IdeatrSettings {
    return {
        llmProvider: 'llama',
        llamaServerUrl: 'http://127.0.0.1:8080',
        llamaBinaryPath: '',
        modelPath: '',
        llamaServerPort: 8080,
        concurrency: 1,
        llmTimeout: 10000,
        autoClassify: true,
        enableDomainCheck: true,
        autoCheckDomains: false,
        prospectrUrl: 'http://localhost:3000',
        domainCheckTimeout: 10000,
        enableWebSearch: true,
        autoSearchExistence: false,
        webSearchProvider: 'google',
        googleSearchApiKey: '',
        googleSearchEngineId: '',
        webSearchTimeout: 15000,
        maxSearchResults: 5,
        enableNameVariants: true,
        autoGenerateVariants: false,
        maxVariants: 8,
        useLLMForNameExtraction: false,
        variantCacheMaxSize: 100,
        variantCachePersist: true,
        enableScaffolds: true,
        scaffoldDefaultAction: 'append',
        dashboardDefaultView: 'table',
        dashboardItemsPerPage: 50,
        dashboardAutoRefresh: true,
        dashboardPersistFilters: true,
        enableClustering: true,
        clusteringAlgorithm: 'hierarchical',
        maxClusters: 0,
        clusterColorScheme: 'category',
        clusteringSimilarityThreshold: 0.3,
        enableResurfacing: true,
        resurfacingThresholdDays: 7,
        resurfacingFrequency: 'manual',
        resurfacingTime: '09:00',
        autoGenerateDigest: false,
        digestIncludeSummary: true,
        digestMaxIdeas: 0,
        enableElevation: true,
        elevationProjectsDirectory: 'Projects',
        elevationCreateDevraMetadata: true,
        elevationDefaultFolders: 'docs,notes,assets'
    };
}

describe('ProjectElevationService', () => {
    let vault: Vault;
    let frontmatterParser: FrontmatterParser;
    let settings: IdeatrSettings;
    let service: ProjectElevationService;

    beforeEach(() => {
        vault = createMockVault();
        frontmatterParser = new FrontmatterParser();
        settings = createMockSettings();
        service = new ProjectElevationService(vault, frontmatterParser, settings);
    });

    describe('canElevate', () => {
        it('should return true for captured ideas', () => {
            const ideaFile = createMockIdeaFile('test-idea.md');
            expect(service.canElevate(ideaFile)).toBe(true);
        });

        it('should return false for already elevated ideas', () => {
            const ideaFile = createMockIdeaFile('test-idea.md');
            ideaFile.frontmatter.status = 'elevated';
            expect(service.canElevate(ideaFile)).toBe(false);
        });

        it('should return false for ideas without required frontmatter', () => {
            const ideaFile = createMockIdeaFile('test-idea.md');
            delete (ideaFile.frontmatter as any).type;
            expect(service.canElevate(ideaFile)).toBe(false);
        });
    });

    describe('generateProjectName', () => {
        it('should extract project name from idea body', () => {
            const ideaFile = createMockIdeaFile('test-idea.md', 'My Awesome Project');
            const name = service.generateProjectName(ideaFile);
            expect(name).toBe('my-awesome-project');
        });

        it('should extract project name from first line of body', () => {
            const ideaFile = createMockIdeaFile('test-idea.md', 'First Line\n\nSecond paragraph');
            const name = service.generateProjectName(ideaFile);
            expect(name).toBe('first-line');
        });

        it('should sanitize special characters', () => {
            const ideaFile = createMockIdeaFile('test-idea.md', 'My Project: Version 2.0!');
            const name = service.generateProjectName(ideaFile);
            expect(name).toBe('my-project-version-20');
        });

        it('should handle empty body by using filename', () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', '');
            const name = service.generateProjectName(ideaFile);
            expect(name).toBe('test-idea');
        });

        it('should truncate very long names', () => {
            const longName = 'a'.repeat(100);
            const ideaFile = createMockIdeaFile('test-idea.md', longName);
            const name = service.generateProjectName(ideaFile);
            expect(name.length).toBeLessThanOrEqual(50);
        });

        it('should handle only whitespace in body', () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', '   \n\n  ');
            const name = service.generateProjectName(ideaFile);
            expect(name).toBe('test-idea');
        });
    });

    describe('isProjectNameAvailable', () => {
        it('should return true if project folder does not exist', async () => {
            vi.mocked(vault.getAbstractFileByPath).mockReturnValue(null);
            const available = await service.isProjectNameAvailable('my-project');
            expect(available).toBe(true);
        });

        it('should return false if project folder exists', async () => {
            vi.mocked(vault.getAbstractFileByPath).mockReturnValue({
                path: 'Projects/my-project',
                type: 'folder'
            } as any);
            const available = await service.isProjectNameAvailable('my-project');
            expect(available).toBe(false);
        });
    });

    describe('elevateIdea', () => {
        it('should successfully elevate an idea to a project', async () => {
            // Setup: Create a mock idea file in vault
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-28
category: app
tags: [test]
related: []
domains: []
existence-check: []
---

My Test Project`;

            // Create the file in the vault
            await vault.create(originalPath, fileContent);
            const mockFile = vault.getAbstractFileByPath(originalPath) as TFile;

            const result = await service.elevateIdea(ideaFile);

            expect(result.success).toBe(true);
            expect(result.projectPath).toBe('Projects/my-test-project');
            expect(result.error).toBeUndefined();

            // Verify project folder was created
            expect(vault.createFolder).toHaveBeenCalledWith('Projects/my-test-project');
            expect(vault.createFolder).toHaveBeenCalledWith('Projects/my-test-project/docs');
            expect(vault.createFolder).toHaveBeenCalledWith('Projects/my-test-project/notes');
            expect(vault.createFolder).toHaveBeenCalledWith('Projects/my-test-project/assets');

            // Verify README.md was created
            expect(vault.create).toHaveBeenCalledWith(
                'Projects/my-test-project/README.md',
                expect.stringContaining('My Test Project')
            );

            // Verify original file was deleted
            expect(vault.delete).toHaveBeenCalledWith(mockFile);
        });

        it('should update frontmatter with elevation metadata', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-28
category: app
tags: [test]
related: []
domains: []
existence-check: []
---

My Test Project`;

            await vault.create(originalPath, fileContent);
            const mockFile = vault.getAbstractFileByPath(originalPath) as TFile;

            const result = await service.elevateIdea(ideaFile);

            expect(result.success).toBe(true);

            // Verify README.md contains updated frontmatter
            const createCalls = vi.mocked(vault.create).mock.calls;
            const readmeCall = createCalls.find(call => call[0] === 'Projects/my-test-project/README.md');
            expect(readmeCall).toBeDefined();

            const readmeContent = readmeCall![1] as string;
            expect(readmeContent).toContain('status: elevated');
            expect(readmeContent).toContain('elevated:');
            expect(readmeContent).toContain('projectPath: Projects/my-test-project');
        });

        it('should preserve original frontmatter fields', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            ideaFile.frontmatter.category = 'saas';
            ideaFile.frontmatter.tags = ['web', 'app'];
            ideaFile.frontmatter.created = '2025-11-20';

            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-20
category: saas
tags: [web, app]
related: []
domains: []
existence-check: []
---

My Test Project`;

            await vault.create(originalPath, fileContent);
            const mockFile = vault.getAbstractFileByPath(originalPath) as TFile;

            await service.elevateIdea(ideaFile);

            const createCalls = vi.mocked(vault.create).mock.calls;
            const readmeCall = createCalls.find(call => call[0] === 'Projects/my-test-project/README.md');
            const readmeContent = readmeCall![1] as string;

            expect(readmeContent).toContain('type: idea');
            expect(readmeContent).toContain('created: 2025-11-20');
            expect(readmeContent).toContain('category: saas');
            expect(readmeContent).toContain('tags: [web, app]');
        });

        it('should create Devra metadata file', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-28
category: app
tags: [test]
related: []
domains: []
existence-check: []
---

My Test Project`;

            await vault.create(originalPath, fileContent);
            const mockFile = vault.getAbstractFileByPath(originalPath) as TFile;

            await service.elevateIdea(ideaFile);

            // Verify .devra.json was created
            expect(vault.adapter.write).toHaveBeenCalledWith(
                'Projects/my-test-project/.devra.json',
                expect.stringContaining('"devraReady": false')
            );

            const writeCalls = vi.mocked(vault.adapter.write).mock.calls;
            const devraCall = writeCalls.find(call => call[0] === 'Projects/my-test-project/.devra.json');
            expect(devraCall).toBeDefined();

            const devraContent = JSON.parse(devraCall![1] as string);
            expect(devraContent.name).toBe('my-test-project');
            expect(devraContent.type).toBe('project');
            expect(devraContent.source).toBe('ideatr');
            expect(devraContent.devraReady).toBe(false);
        });

        it('should handle project name collisions', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Project');
            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-28
category: app
tags: [test]
related: []
domains: []
existence-check: []
---

My Project`;

            await vault.create(originalPath, fileContent);
            // Create existing project folder to simulate collision
            await vault.createFolder('Projects/my-project');
            const mockFile = vault.getAbstractFileByPath(originalPath) as TFile;

            const result = await service.elevateIdea(ideaFile);

            expect(result.success).toBe(true);
            expect(result.projectPath).toBe('Projects/my-project-2');
        });

        it('should return error if idea cannot be elevated', async () => {
            const ideaFile = createMockIdeaFile('test-idea.md');
            ideaFile.frontmatter.status = 'elevated';

            const result = await service.elevateIdea(ideaFile);

            expect(result.success).toBe(false);
            expect(result.error).toContain('cannot be elevated');
        });

        it('should return error if file does not exist', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            // Don't create the file, so it won't exist

            const result = await service.elevateIdea(ideaFile);

            expect(result.success).toBe(false);
            expect(result.error).toBeDefined();
        });

        it('should rollback on folder creation failure', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-28
category: app
tags: [test]
related: []
domains: []
existence-check: []
---

My Test Project`;

            await vault.create(originalPath, fileContent);
            // Make folder creation fail
            vi.mocked(vault.createFolder).mockRejectedValueOnce(new Error('Permission denied'));

            const result = await service.elevateIdea(ideaFile);

            expect(result.success).toBe(false);
            expect(result.error).toBeDefined();
        });

        it('should use provided project name if given', async () => {
            const ideaFile = createMockIdeaFile('2025-11-28 Test idea.md', 'My Test Project');
            const originalPath = 'Ideas/2025-11-28 Test idea.md';
            const fileContent = `---
type: idea
status: captured
created: 2025-11-28
category: app
tags: [test]
related: []
domains: []
existence-check: []
---

My Test Project`;

            await vault.create(originalPath, fileContent);
            const mockFile = vault.getAbstractFileByPath(originalPath) as TFile;

            const result = await service.elevateIdea(ideaFile, 'custom-project-name');

            expect(result.success).toBe(true);
            expect(result.projectPath).toBe('Projects/custom-project-name');
        });
    });
});

