import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { LlamaService } from '../../src/services/LlamaService';
import type { IdeatrSettings } from '../../src/settings';

// Mock requestUrl (used by LlamaService instead of fetch)
const mockRequestUrl = vi.hoisted(() => vi.fn());

// Mock fs
vi.mock('fs', async () => {
    return {
        existsSync: vi.fn(() => true),
        accessSync: vi.fn(),
        constants: {
            X_OK: 1
        }
    };
});

// Mock child_process
const mocks = vi.hoisted(() => {
    const mockSpawn = vi.fn();
    const createMockChildProcess = () => ({
        stdout: { on: vi.fn(), removeListener: vi.fn() },
        stderr: { on: vi.fn(), removeListener: vi.fn() },
        on: vi.fn(),
        once: vi.fn(),
        removeListener: vi.fn(),
        kill: vi.fn(),
        pid: 12345,
        exitCode: null,
        killed: false
    });
    const mockChildProcess = createMockChildProcess();
    mockSpawn.mockReturnValue(mockChildProcess);
    return {
        spawn: mockSpawn,
        childProcess: mockChildProcess,
        createMockChildProcess
    };
});

vi.mock('child_process', async () => {
    return {
        spawn: mocks.spawn,
        ChildProcess: class { }
    };
});

// Mock Obsidian Notice and requestUrl
vi.mock('obsidian', () => ({
    Notice: class {
        constructor(message: string) { }
    },
    requestUrl: mockRequestUrl
}));

describe('LlamaService - Idle Timeout', () => {
    let service: LlamaService;
    let mockSettings: IdeatrSettings;

    beforeEach(() => {
        vi.useFakeTimers();
        vi.clearAllMocks();

        mockSettings = {
            llmProvider: 'llama',
            llamaServerUrl: 'http://127.0.0.1:8080',
            llamaBinaryPath: '/path/to/llama-server',
            modelPath: '/path/to/model.gguf',
            llamaServerPort: 8080,
            concurrency: 1,
            llmTimeout: 10000,
            autoClassify: true,
            enableDomainCheck: true,
            autoCheckDomains: false,
            prospectrUrl: 'http://localhost:3000',
            domainCheckTimeout: 10000,
            enableWebSearch: true,
            autoSearchExistence: false,
            webSearchProvider: 'google',
            googleSearchApiKey: '',
            googleSearchEngineId: '',
            webSearchTimeout: 15000,
            maxSearchResults: 5,
            enableNameVariants: true,
            autoGenerateVariants: false,
            maxVariants: 8,
            useLLMForNameExtraction: false,
            variantCacheMaxSize: 100,
            variantCachePersist: true,
            enableScaffolds: true,
            scaffoldDefaultAction: 'append',
            dashboardDefaultView: 'table',
            dashboardItemsPerPage: 50,
            dashboardAutoRefresh: true,
            dashboardPersistFilters: true,
            enableClustering: true,
            clusteringAlgorithm: 'hierarchical',
            maxClusters: 0,
            clusterColorScheme: 'category',
            clusteringSimilarityThreshold: 0.3,
            enableResurfacing: true,
            resurfacingThresholdDays: 7,
            resurfacingFrequency: 'manual',
            resurfacingTime: '09:00',
            autoGenerateDigest: false,
            digestIncludeSummary: true,
            digestMaxIdeas: 0,
            enableElevation: true,
            elevationProjectsDirectory: 'Projects',
            elevationCreateDevraMetadata: true,
            elevationDefaultFolders: 'docs,notes,assets',
            setupCompleted: false,
            modelDownloaded: false,
            keepModelLoaded: false,
            preloadOnStartup: false,
            preferCloud: false,
            cloudProvider: 'none' as const,
            cloudApiKey: '',
            customEndpointUrl: '',
            openRouterModel: ''
        };

        // Reset mocks before creating new service
        mocks.spawn.mockClear();
        mocks.childProcess.stdout.on.mockClear();
        mocks.childProcess.stderr.on.mockClear();
        mocks.childProcess.on.mockClear();
        mocks.childProcess.kill.mockClear();
        service = LlamaService.getInstance(mockSettings);
        mockRequestUrl.mockReset();
    });

    afterEach(() => {
        vi.useRealTimers();
    });

    describe('idle timeout', () => {
        it('should unload model after 15 minutes of inactivity', async () => {
            // Start server
            const startPromise = service.startServer();

            // Wait a tick for spawn to complete and register stdout listener
            await vi.advanceTimersByTimeAsync(0);

            // Get the stdout callback and trigger it to set isServerReady
            const stdoutCallbacks = mocks.childProcess.stdout.on.mock.calls.filter(call => call[0] === 'data');
            if (stdoutCallbacks.length > 0 && stdoutCallbacks[0][1]) {
                const stdoutCallback = stdoutCallbacks[0][1];
                stdoutCallback(Buffer.from('HTTP server listening'));
                // Also send model loaded message to set isServerReady
                stdoutCallback(Buffer.from('main: model loaded'));
            }

            // Advance timers to complete startup delay (2000ms)
            await vi.advanceTimersByTimeAsync(2000);
            await startPromise;

            // Use the service
            mockRequestUrl.mockResolvedValue({
                status: 200,
                json: { content: '{"category":"saas","tags":["app"]}' }
            });

            // Ensure server is ready before classifying
            // The server should already be ready from the setup above
            const classifyPromise = service.classify('test idea');
            // Advance timers enough to complete classification (timeout is 10000ms)
            // But limit to avoid running all ensureReady() wait loops
            await vi.advanceTimersByTimeAsync(11000);
            await classifyPromise;

            // Advance time by 15 minutes + 1 second
            await vi.advanceTimersByTimeAsync(15 * 60 * 1000 + 1000);

            // Model should be unloaded - check if process manager stopped the process
            expect(service.hasServerProcess()).toBe(false);
        });

        it('should reset idle timer on each classification', async () => {
            // Start server
            const startPromise = service.startServer();
            await vi.advanceTimersByTimeAsync(0);

            const stdoutCallbacks = mocks.childProcess.stdout.on.mock.calls.filter(call => call[0] === 'data');
            if (stdoutCallbacks.length > 0 && stdoutCallbacks[0][1]) {
                stdoutCallbacks[0][1](Buffer.from('HTTP server listening'));
                // Also send model loaded message to set isServerReady
                stdoutCallbacks[0][1](Buffer.from('main: model loaded'));
            }

            await vi.advanceTimersByTimeAsync(2000);
            await startPromise;

            mockRequestUrl.mockResolvedValue({
                status: 200,
                json: { content: '{"category":"saas","tags":["app"]}' }
            });

            // First classification
            const classify1Promise = service.classify('test idea 1');
            await vi.advanceTimersByTimeAsync(11000);
            await classify1Promise;

            await vi.advanceTimersByTimeAsync(14 * 60 * 1000); // 14 minutes

            // Second classification (should reset timer)
            const classify2Promise = service.classify('test idea 2');
            await vi.advanceTimersByTimeAsync(11000);
            await classify2Promise;

            await vi.advanceTimersByTimeAsync(14 * 60 * 1000); // Another 14 minutes

            // Model should still be loaded (only 14 minutes since last use)
            expect(service.hasServerProcess()).toBe(true);

            // Advance another 2 minutes to trigger timeout
            await vi.advanceTimersByTimeAsync(2 * 60 * 1000);

            // Now model should be unloaded
            expect(service.hasServerProcess()).toBe(false);
        });

        it('should not unload model if keepModelLoaded is true', async () => {
            mockSettings.keepModelLoaded = true;
            mocks.childProcess.kill.mockClear();
            // Destroy existing instance and create new one with updated settings
            LlamaService.destroyInstance();
            service = LlamaService.getInstance(mockSettings);

            // Start server
            const startPromise = service.startServer();
            await vi.advanceTimersByTimeAsync(0);

            const stdoutCallbacks = mocks.childProcess.stdout.on.mock.calls.filter(call => call[0] === 'data');
            if (stdoutCallbacks.length > 0 && stdoutCallbacks[0][1]) {
                stdoutCallbacks[0][1](Buffer.from('HTTP server listening'));
                // Also send model loaded message to set isServerReady
                stdoutCallbacks[0][1](Buffer.from('main: model loaded'));
            }

            await vi.advanceTimersByTimeAsync(2000);
            await startPromise;

            mockRequestUrl.mockResolvedValue({
                status: 200,
                json: { content: '{"category":"saas","tags":["app"]}' }
            });

            const classifyPromise = service.classify('test idea');
            // Advance timers enough to complete classification (timeout is 10000ms)
            await vi.advanceTimersByTimeAsync(11000);
            await classifyPromise;

            // Advance time by 20 minutes
            await vi.advanceTimersByTimeAsync(20 * 60 * 1000);

            // Model should NOT be unloaded
            expect(service.hasServerProcess()).toBe(true);
        });

        it('should handle rapid classifications without unloading', async () => {
            // Start server
            const startPromise = service.startServer();
            await vi.advanceTimersByTimeAsync(0);

            const stdoutCallbacks = mocks.childProcess.stdout.on.mock.calls.filter(call => call[0] === 'data');
            if (stdoutCallbacks.length > 0 && stdoutCallbacks[0][1]) {
                stdoutCallbacks[0][1](Buffer.from('HTTP server listening'));
                // Also send model loaded message to set isServerReady
                stdoutCallbacks[0][1](Buffer.from('main: model loaded'));
            }

            await vi.advanceTimersByTimeAsync(2000);
            await startPromise;

            mockRequestUrl.mockResolvedValue({
                status: 200,
                json: { content: '{"category":"saas","tags":["app"]}' }
            });

            // Multiple rapid classifications
            for (let i = 0; i < 10; i++) {
                const classifyPromise = service.classify(`test idea ${i}`);
                await vi.advanceTimersByTimeAsync(11000);
                await classifyPromise;
                await vi.advanceTimersByTimeAsync(1000);
            }

            // Advance time by 14 minutes (should not unload)
            await vi.advanceTimersByTimeAsync(14 * 60 * 1000);

            // Model should still be loaded
            expect(service.hasServerProcess()).toBe(true);
        });
    });

    describe('loading states', () => {
        it('should track loading state correctly', async () => {
            // Destroy existing instance to start fresh (avoid "Server already running" issue)
            LlamaService.destroyInstance();
            service = LlamaService.getInstance(mockSettings);

            // Initially not loaded
            expect(service.isAvailable()).toBe(true);

            // Start loading
            const startPromise = service.startServer();
            await vi.advanceTimersByTimeAsync(0);

            const stdoutCallbacks = mocks.childProcess.stdout.on.mock.calls.filter(call => call[0] === 'data');
            if (stdoutCallbacks.length > 0 && stdoutCallbacks[0][1]) {
                stdoutCallbacks[0][1](Buffer.from('HTTP server listening'));
                // Also send model loaded message to set isServerReady
                stdoutCallbacks[0][1](Buffer.from('main: model loaded'));
            }

            // Server should be starting
            expect(mocks.spawn).toHaveBeenCalled();

            // Complete startup
            await vi.advanceTimersByTimeAsync(2000);
            await startPromise;

            // Server should be ready
            expect(service.isAvailable()).toBe(true);
        });
    });
});

